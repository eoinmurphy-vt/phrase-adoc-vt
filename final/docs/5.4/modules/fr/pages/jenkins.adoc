= Détails de Jenkins
:revdate: 2025-05-05
:page-revdate: {revdate}
:page-opendocs-origin: /06.scanning/03.build/01.jenkins/01.jenkins.md
:page-opendocs-slug:  /scanning/build/jenkins

== Detailed configuration for the Jenkins plug-in

Containers provide an easy and efficient way to deploy applications. But container images may contain open source code over which you do not have full control. Many vulnerabilities in open source projects have been reported, and you can decide whether to use these libraries with vulnerabilities or not after analyzing the images and reviewing the vulnerability information about them.

The {product-name} Jenkins Vulnerability Scanner plug-in can scan images after your image is built in Jenkins. The source of the plug-in and the latest documentation can be found https://github.com/jenkinsci/neuvector-vulnerability-scanner-plugin[here] on the GitHub page {product-name}.

The plug-in supports two scanning modes. The first is the "Controller & Scanner" mode. The second is the standalone scanner mode. Vous pouvez sélectionner le mode d'analyse dans la page de configuration du projet. By default, it uses the "Controller & Scanner" mode.

For the "Controller & Scanner" mode, you need to deploy the controller and scanner {product-name} in the network. To scan the local image (the image on the Jenkins machine), the "Controller & Scanner" must be installed on the same node where the image exists.

For the standalone scanner mode, Docker runtime must be installed on the same host as Jenkins. Additionally, add the jenkins user to the docker group.

[,bash]
----
sudo usermod -aG docker jenkins
----

=== Installing the Jenkins plug-in

First, go to Jenkins in your browser to search for the {product-name} plug-in. This can be found in:

-> Gérer Jenkins -> Gérer les plugins -> Disponible -> filtre -> recherche `{product-name} Vulnerability Scanner` ->

Sélectionnez-le et cliquez sur `install without restart.`

Déployez le {product-name} conteneur Controller et Scanner si vous ne l'avez pas déjà fait sur un hôte accessible par le serveur Jenkins. Cela peut être sur le même serveur que Jenkins si désiré. Notez l'adresse IP de l'hôte où le Controller fonctionne. Remarque : Le port API REST par défaut est 10443. Ce port doit être exposé via l'Allinone ou le Controller à travers un service dans Kubernetes ou un mappage de port (par exemple - 10443:10443) dans le fichier Docker run ou compose.

De plus, assurez-vous qu'il y a un conteneur {product-name} scanner déployé en mode autonome et configuré pour se connecter au Controller (si le Controller est utilisé).

Il existe deux scénarios pour le scan d'images, le scan local et le scan de registre.

. *Scan d'image local*. Si vous utilisez le plugin pour scanner des images locales (avant de les pousser vers des registres), vous pouvez scanner sur le même hôte que le controller/scanner ou configurer le scanner pour accéder au moteur docker sur un hôte distant.
. *Scan d'image de registre*. Si vous utilisez le plugin pour scanner des images de registre (après les avoir poussées vers des registres, mais dans le cadre du processus de construction Jenkins), le {product-name} Scanner peut être installé sur n'importe quel nœud du réseau avec connectivité entre le registre, le {product-name} Scanner et Jenkins.

=== Configuration globale dans Jenkins

Après avoir installé le plugin, trouvez la section '\`{product-name} Vulnerability Scanner\`' dans la page de configuration globale (Jenkins '\`Configure System\`'). Entrez les valeurs pour l'IP du {product-name} Controller, le port, le nom d'utilisateur et le mot de passe. Vous pouvez cliquer sur le bouton '\`Test Connection\`' pour valider les valeurs. Cela affichera '\`Connection Success\`' ou un message d'erreur.

La valeur des minutes de délai d'attente mettra fin à l'étape de construction dans le temps saisi. La valeur par défaut de 0 signifie qu'aucun délai d'attente ne se produira.

Click on the '\`Add Registry\`' to enter the values for the registry you will use in your project. If you are only scanning local images, you do not need to add a registry here.

Scenario 1: example of global configuration for scanning local images

image:jenkins1a.png[global-image]

Scenario 2: example of global configuration for scanning registry images

For global registry configuration, follow the instructions above for local, then add the registry details as below.

image:registry_console.png[global-registry]

==== Standalone Scanner

Running the Jenkins scan in standalone mode is a lightweight way to scan for vulnerabilities in images in the pipeline. The scanner is invoked dynamically and no controller configuration installation is required. This is particularly useful when scanning an image before it is pushed to a registry. There is also no limit to the number of scan tasks that can run at the same time.

To run a vulnerability scan in standalone mode, the Jenkins plugin must pull the scanner image to the host where the agent runs, so you need to enter the URL of the registry {product-name} Scanner, the image repository, and credentials if necessary, in the plugin configuration page {product-name}.

The scan result can also be submitted to the controller and used in the admission control function. In this case, you need a controller configuration and specify how to connect to the controller in the plugin configuration page {product-name}.

=== Local configuration to scan a remote Docker host

==== Prerequisites for a local scan on a remote Docker host

To allow {product-name} to scan an image that is not on the same host as the controller/allinone:

* Assurez-vous que le socket de l'API d'exécution Docker est exposé via TCP
* Add the following environment variable to the controller/allinone: SCANNER_DOCKER_URL=tcp://192.168.1.10:2376

=== Project configuration

Dans votre projet, choisissez le plugin '{product-name} Scanner de vulnérabilités' dans le menu déroulant 'Ajouter une étape de construction.' Cochez la case "Scanner avec le scanner autonome" si vous souhaitez effectuer le scan en mode scanner autonome. Par défaut, il utilise le mode "Contrôleur & Scanner" pour effectuer le scan.

Choisissez Local ou un nom de registre qui est le surnom que vous avez entré dans la configuration globale. Entrez le dépôt et le nom de la balise d'image à scanner. Vous pouvez choisir les variables d'environnement par défaut de Jenkins pour le dépôt ou la balise, par exemple $JOB_NAME, $BUILD_TAG, $BUILD_NUMBER. Entrez les valeurs pour le nombre de vulnérabilités élevées ou moyennes, et pour tout nom des vulnérabilités présentes pour échouer la construction.

Après la fin de la construction, un rapport {product-name} sera généré. Il affichera les détails du scan et les erreurs s'il y en a.

Scénario 1 : exemple de configuration locale

image:jenkins_local.png[local-image]

Scénario 2 : exemple de configuration de registre

image:jenkins_registry.png[registre-local]

=== Pipeline Jenkins

Pour le projet de pipeline Jenkins, vous pouvez écrire votre propre script de pipeline directement, ou cliquer sur le '\`pipeline syntax\`' pour générer le script si vous êtes nouveau dans la tâche de style pipeline.

image:jenkins5a.png[pipeline]

Sélectionnez le {product-name} Scanner de vulnérabilités dans le menu déroulant, configurez-le et générez le script.

image:jenkins6a.png[script]

Copiez le script dans votre script de tâche Jenkins.

Scénario 1 : Exemple de script de pipeline local simple (à insérer dans votre script de pipeline) :

[,shell]
----
...
  stage('Scan local image') \{
    neuvector registrySelection: 'Local', repository: 'your_username/your_image'
  \}
...
----

Scénario 2 : Exemple de script de pipeline de registre simple (à insérer dans votre script de pipeline) :

[,shell]
----
...
  stage('Scan local image') \{
    neuvector registrySelection: 'your_registry', repository: 'your_username/your_image'
  \}
...
----

=== Étapes supplémentaires

Ajoutez vos propres étapes de scan d'image avant et après, par exemple dans l'exemple de vue d'étape de pipeline ci-dessous.

image:jenkins7a.png[étapes]

Vous êtes maintenant prêt à commencer vos builds Jenkins et à déclencher le {product-name} Scanner de vulnérabilités pour signaler toute vulnérabilité !

=== Configuration du pipeline pour construire des scans parallèles à grande échelle

Disponible avec NeuVector v5.4.3 et ultérieur, le plug-in Jenkins NeuVector Vulnerability Scanner v2.5 et ultérieur prend en charge le scan parallèle de jusqu'à 2000 scans simultanés lors de l'utilisation du mode clé API. Pour les versions antérieures de NeuVector, le nombre maximum de scans simultanés est limité à 32 avec l'utilisation du mode Token. Cliquez pour développer et voir les exemples ci-dessous pour des configurations de pipeline échantillons.

.Utilisation de la configuration d'exemple en mode Token (plug-in v2.4 et inférieur, ou v2.5 et ultérieur) 
[%collapsible]
====
[,groovy]
----
pipeline {
    agent any
    environment {
        REPO_NAME = 'your repo'
        REGISTRY_SELECTION = 'your registry'
        CONTROLLER = 'your controller'
        MAX_CONCURRENT_SCANS = 32
    }
    stages {
        stage('Parallel Vulnerability Scanning') {
            steps {
                script {
                    // There is a limit of 250 tags per list (by Jenkins) 
                    TAGS_LIST_PART1 = ["your tags"...]
                    TAGS_LIST_PART2 = ["your tags"...]
                    TAGS_LIST_PART3 = ["your tags"...]
                    TAGS_LIST_PART4 = ["your tags"...]
                    TAGS_LIST_PART5 = ["your tags"...]...
                    def allTags = TAGS_LIST_PART1 + TAGS_LIST_PART2 + TAGS_LIST_PART3 + TAGS_LIST_PART4 + TAGS_LIST_PART5
                    def batches = allTags.collate(MAX_CONCURRENT_SCANS.toInteger()) // Ensure MAX_CONCURRENT_SCANS is an integer
                    def batchCounter = 1                    for (batch in batches) {
                        stage("Batch ${batchCounter}") {
                            def scans = [:]
                            batch.each { tag ->
                                def currentTag = tag
                                scans["Scan ${currentTag}"] = {
                                    stage("Scan ${currentTag}") {
                                        neuvector(
                                            controllerEndpointUrlSelection: CONTROLLER,
                                            registrySelection: REGISTRY_SELECTION,
                                            repository: REPO_NAME,
                                            scanTimeout: 20,
                                            tag: "${currentTag}"
                                        )
                                        echo "Scan for tag ${currentTag} complete"
                                    }
                                }
                            }
                            parallel scans
                        }
                        batchCounter++
                    }
                }
            }
        }
    }
}
----
====

.Utilisation du mode clé API (plug-in v2.5 et ultérieur)
[%collapsible]
====
[,groovy]
----
pipeline {
    agent any
    environment {
        REPO_NAME = 'your repo'
        REGISTRY_SELECTION = 'your registry'
        CONTROLLER = 'your controller'
    }
    stages {
        stage('Parallel Vulnerability Scanning') {
            steps {
                script {
                    // There is a limit of 250 tags per list (by Jenkins) 
                    TAGS_LIST_PART1 = ["your tags"...]
                    TAGS_LIST_PART2 = ["your tags"...]
                    TAGS_LIST_PART3 = ["your tags"...]
                    TAGS_LIST_PART4 = ["your tags"...]
                    TAGS_LIST_PART5 = ["your tags"...]...
                    def allTags = TAGS_LIST_PART1 + TAGS_LIST_PART2 + TAGS_LIST_PART3 + TAGS_LIST_PART4 + TAGS_LIST_PART5
                    def scans = [:]

                    allTags.each { tag ->
                        def currentTag = tag
                        scans["Scan ${currentTag}"] = {
                            stage("Scan ${currentTag}") {
                                neuvector(
                                    controllerEndpointUrlSelection: CONTROLLER,
                                    registrySelection: REGISTRY_SELECTION,
                                    repository: REPO_NAME,
                                    scanTimeout: 20,
                                    tag: "${currentTag}"
                                )
                                echo "Scan for tag ${currentTag} complete"
                            }
                        }
                    }
                    parallel scans
                }
            }
        }
    }
}
----
====

== Exemple de route OpenShift et de token de registre

Pour configurer le plug-in en utilisant une route OpenShift pour l'ingress vers le contrôleur, ajoutez la route dans le champ IP du contrôleur.

image:rhos_jenkins_route.png[openshift]

Pour utiliser l'authentification basée sur un token pour le registre OpenShift, utilisez NONAME comme utilisateur et entrez le token dans le mot de passe.

== Cas d'utilisation spécial pour Jenkins dans le même cluster Kubernetes

Pour effectuer un scan en phase de construction où le logiciel Jenkins s'exécute dans le même cluster Kubernetes que le scanner, assurez-vous que le scanner et Jenkins sont configurés pour s'exécuter sur le même nœud. Le nœud doit être étiqueté afin que les conteneurs Jenkins et scanner s'exécutent sur le même nœud, car le scanner a besoin d'accéder au docker.sock du nœud local pour accéder à l'image.
