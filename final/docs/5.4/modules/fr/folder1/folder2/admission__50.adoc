= Contrôles d'admission
:revdate: 2025-06-25
:page-revdate: {revdate}
:page-opendocs-origin: /05.policy/03.admission/03.admission.md
:page-opendocs-slug:  /policy/admission

== Contrôle des déploiements d'images et de conteneurs

Avec l'intégration du contrôle d'admission aux plateformes d'orchestration telles que Kubernetes et OpenShift, {product-name} joue un rôle important au sein du pipeline de déploiement de la plateforme d'orchestration. Lorsqu'une ressource de cluster telle que le déploiement est créée, la demande de l'apiserver de cluster est transmise à l'un des contrôleurs {product-name} afin de déterminer s'il doit être autorisé à déployer ou refusé sur la base des règles de contrôle d'admission définies par l'utilisateur avant la création de la ressource de cluster. La décision de politique générale prise par {product-name} sera transmise à l'apiserver du cluster pour application.

Cette fonctionnalité est prise en charge dans Kubernetes 1.9+ et Openshift 3.9+. Avant d'utiliser la fonction de contrôle d'admission dans {product-name}, bien qu'il soit possible de configurer le contrôle d'admission à partir de l'argument `--admission-control` transmis à l'apiserver de la grappe, il est recommandé d'utiliser le contrôle d'admission dynamique. Veuillez consulter les sections Kubernetes et Openshift ci-dessous pour la configuration.

=== Kubernetes

Les plugins ValidatingAdmissionWebhook et MutatingAdmissionWebhook sont activés par défaut.

Vérifier si admissionregistration.kubernetes.io/v1beta1 est activé

[,bash]
----
kubectl api-versions | grep admissionregistration
admissionregistration.k8s.io/v1beta1
----

=== Openshift

Les plugins ValidatingAdmissionWebhook et MutatingAdmissionWebhook ne sont PAS activés par défaut. Veuillez consulter les exemples dans les sections relatives au déploiement d'OpenShift pour savoir comment les activer. Un redémarrage des services OpenShift api et controllers est nécessaire.

Vérifier si admissionregistration.kubernetes.io/v1beta1 est activé

[,bash]
----
oc api-versions | grep admissionregistration
admissionregistration.k8s.io/v1beta1
----

== Activation du contrôle d'admission (Webhook) en {product-name}

La fonction de contrôle d'admission est désactivée par défaut. Veuillez vous rendre sur la page Policy -> Admission Control pour l'activer dans la console {product-name}.

image:ac_enable.png[Activer]

Une fois que la fonction de contrôle d'admission est activée avec succès, la ressource ValidatingWebhookConfiguration suivante est créée automatiquement. Pour le vérifier :

[,shell]
----
kubectl get ValidatingWebhookConfiguration neuvector-validating-admission-webhook
----

Exemple de sortie :

[,shell]
----
NAME                                     CREATED AT
neuvector-validating-admission-webhook   2019-03-28T00:05:09Z
----

Les informations les plus importantes dans la ressource ValidatingWebhookConfiguration pour {product-name} sont les ressources du cluster. Actuellement, lorsqu'une ressource de cluster telle que Deployment {product-name} est enregistrée, la demande est envoyée de la plateforme d'orchestration apiserver à l'un des contrôleurs {product-name} afin de déterminer si elle doit être autorisée ou refusée sur la base des règles définies par l'utilisateur dans la page {product-name} Policy -> Admission Control (Contrôle d'admission).

Si le déploiement de la ressource est refusé, un événement sera enregistré dans les notifications.

Pour tester la connexion Kubernetes pour l'accès en mode client, allez à Advanced Setting.

image:ac_advanced.png[Avancé]

Dans des cas particuliers, la méthode d'accès par URL utilisant le service NodePort peut être nécessaire.

== Événements/Notifications du contrôle d'admission

Tous les événements de contrôle d'admission pour les événements autorisés et refusés se trouvent dans le menu Notifications -> Risques de sécurité.

== Critères de contrôle d'admission

{product-name} prend en charge de nombreux critères pour la création d'une règle de contrôle d'admission. Il s'agit notamment du nombre élevé de CVE, des noms de CVE, des étiquettes d'image, de l'imageScanned, de l'espace de noms, de l'utilisateur, de runAsRoot, etc. Il existe deux sources possibles d'évaluation des critères : les analyses d'images et les analyses de fichiers Yaml de déploiement. Si un critère nécessite une analyse d'image, les résultats de l'analyse du registre seront utilisés. Si l'image n'a pas été numérisée, la règle de contrôle d'admission ne sera pas appliquée. Si un critère nécessite l'analyse du yaml de déploiement, il sera évalué à partir du déploiement Kubernetes. Certains critères utiliseront les résultats d'une analyse d'image OU d'une analyse yaml de déploiement.

* Le score CVE est un exemple de critère nécessitant une analyse d'image.
* Les variables d'environnement avec secrets sont un exemple de critère utilisant le scan yaml de déploiement.
* Les étiquettes et les variables d'environnement sont des exemples de critères qui utiliseront les DEUX résultats des analyses d'image et de déploiement yaml (OU logique) pour déterminer les correspondances.

image:adm_control_criteria.png[Critères]

Une fois le critère sélectionné, les opérateurs possibles s'affichent. Cliquez sur le bouton '`+`' pour ajouter chaque critère.

*Utilisation de plusieurs critères dans une seule règle*La logique de correspondance pour plusieurs critères dans une règle de contrôle des admissions est la suivante :

* Pour différents types de critères au sein d'une même règle, appliquer "et".
* Pour plusieurs critères du même type (par exemple, plusieurs espaces de noms, registres, images),
** Appliquer 'et' pour toutes les correspondances négatives ("ne contient aucun", "n'est pas l'un des") jusqu'à la première correspondance positive ;
** Après la première correspondance positive, appliquer "ou".

=== Exemple de correspondance avec l'étiquette d'un pod

[,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: iperfserver
  namespace: neuvector-1
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: iperfserver
----

La règle à appliquer serait la suivante :

image:ac_label.png[Admission]

=== Exemple de correspondance entre des variables d'environnement et des secrets

[,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: iperfserver
  namespace: neuvector-1
  labels:
    name: iperfserver
spec:
  selector:
    matchLabels:
      name: iperfserver
  replicas: 1
  template:
    metadata:
      labels:
        name: iperfserver
    spec:
      containers:
        - name: iperfserver
          image: nvlab/iperf
          env:
            - name: env1
              value: AIDAJQABLZS4A3QDU576
            - name: env2
              valueFrom:
                fieldRef:
                  fieldPath: status.podIP
            - name: env5
              value: AIDAJQABLZS4A3QDU57E
          command:
            - iperf
            - -s
            - -p
            - "6068"
      nodeSelector:
        nvallinone: "true"
      restartPolicy: Always
----

La règle de correspondance serait la suivante :

image:ac_environment.png[Admission]

=== Critères liés aux résultats du scanner

Les critères suivants sont liés aux résultats de la page {product-name} Assets > Registry scan :

Image, imageScanned, cveHighCount, cveMediumCount, Image compliance violations, cveNames et autres.

Avant que {product-name} n'effectue la comparaison avec les règles de contrôle d'admission, {product-name} récupère les informations relatives à l'image (par exemple, 10.1.127.3:5000/neuvector/toolbox/iperf:latest) auprès de l'apiserver de la grappe (voir la section Requête de l'apiserver ci-dessous). L'image est composée d'un serveur de registre (`https://10.1.127.3:5000`), d'un référentiel (neuvector/toolbox/iperf) et d'une balise (latest).

{product-name} utilise ces informations pour faire correspondre les résultats de la page d'analyse du registre {product-name} Assets -> et recueille les informations correspondantes, telles que le nom du cve, le nombre de cve élevé ou moyen, etc. Les violations de la conformité des images sont considérées comme des images comportant des secrets ou des violations setuid/setgid.
Si les utilisateurs utilisent l'image du registre Docker pour créer une ressource cluster, les informations du serveur de registre sont normalement vides ou docker.io et actuellement {product-name} utilise les serveurs de registre codés en dur suivants pour correspondre au résultat de l'analyse du registre au lieu d'une chaîne vide ou docker.io. Bien entendu, s'il existe d'autres serveurs de registre Docker pris en charge que ceux définis dans la page d'analyse du registre, {product-name} ne peut pas obtenir les résultats de l'analyse du registre avec succès.

Si les utilisateurs utilisent l'image intégrée telle que alpine ou ubuntu à partir du registre Docker, il existe un nom d'organisation caché appelé library. Lorsque vous regardez les résultats pour l'image docker build-in dans {product-name} Assets > Registry scan page, le nom du dépôt sera library/alpine ou library/ubuntu. Actuellement, {product-name} suppose qu'il n'y a qu'un seul nom d'organisation de bibliothèque cachée dans le registre Docker. S'il y en a plus d'un, {product-name} n'est pas en mesure d'obtenir les résultats de l'analyse du registre avec succès.
La limitation ci-dessus peut également s'appliquer à d'autres types de serveurs de registre Docker, le cas échéant.

=== Création de règles de critères personnalisées

Les utilisateurs peuvent créer un critère personnalisé à utiliser pour autoriser ou bloquer les déploiements sur la base d'objets communs trouvés dans l'image yaml (scannée lors du déploiement). Sélectionnez l'objet à utiliser, par exemple imagePullSecrets, et la valeur correspondante, par exemple existe. Il est également recommandé d'utiliser des critères supplémentaires pour mieux cibler la règle, tels que l'espace de noms, le PSP/PSA, les conditions CVE, etc.

image:custom_admission.png[admission]

==== Explications des critères

Les critères accompagnés d'une icône de disque nécessitent l'analyse de l'image (voir l'analyse du registre), et les critères accompagnés d'une icône de fichier analysent le fichier yaml de déploiement. Si les deux icônes sont répertoriées, la correspondance se fera pour l'une ou l'autre (OU). Si un critère exige l'analyse d'une image, mais que l'image n'est PAS analysée, cette partie de la règle sera ignorée (c'est-à-dire que la règle sera contournée, ou si le yaml de déploiement est également listé, seul le yaml de déploiement sera utilisé pour établir la correspondance). Pour empêcher les images non numérisées de contourner les règles, voir le critère Image numérisée ci-dessous. 

* Ajouter un critère personnalisé. Sélectionnez l'objet dans le menu déroulant. Tous les critères personnalisés prennent en charge les opérateurs existants et inexistants. Pour ceux qui autorisent les valeurs, des opérateurs supplémentaires et la valeur peuvent être saisis. Les valeurs peuvent être statiques, séparées par des virgules et inclure des caractères génériques. 
* Permettre l'escalade des privilèges. Si le conteneur permet des escalades de privilèges, il peut être bloqué en définissant Deny comme action. 
* Nombre de CVE de haute sévérité. Il prend les résultats d'une analyse d'image (registre) et les fait correspondre au nombre d'éléments de gravité élevée (scores CVSS de 7 ou plus). Un opérateur supplémentaire peut être ajouté pour restreindre l'accès aux CVE signalés un certain nombre de jours auparavant, ce qui laisse le temps de remédier aux CVE récents. 
* Nombre de CVE de haute sévérité avec correctif. Il prend les résultats d'une analyse d'image (registre) et les fait correspondre à une gravité élevée (scores CVSS de 7 ou plus), ET s'il existe un correctif pour le CVE. Sélectionnez cette option si vous envisagez de bloquer les déploiements de CVE élevés uniquement si un correctif aurait dû être appliqué. Un opérateur supplémentaire peut être ajouté pour restreindre l'accès aux CVE signalés un certain nombre de jours auparavant, ce qui laisse le temps de remédier aux CVE récents. 
* Nombre de CVE de gravité moyenne. Il prend les résultats d'une analyse d'image (registre) et établit une correspondance sur la base du nombre de failles de gravité moyenne (scores CVSS compris entre 4 et 6). Un opérateur supplémentaire peut être ajouté pour restreindre l'accès aux CVE signalés un certain nombre de jours auparavant, ce qui laisse le temps de remédier aux CVE récents. 
* Noms CVE. Il s'agit d'une correspondance avec des noms de CVE spécifiques (par exemple CVE-2023-23914, 2023-23914, 23914, ou un texte unique) où les noms multiples sont séparés par des virgules. 
* Score CVE. Configurez à la fois le score minimum et le nombre de CVE correspondant ou dépassant le score CVSS minimum. 
* Variables d'environnement avec secrets. Si le yaml de déploiement ou le résultat de l'analyse de l'image contient (ou ne contient pas) de variables d'environnement avec des secrets. Voir les critères de correspondance des secrets ci-dessous. 
* Variables d'environnement. Cette option permet d'exiger ou d'exclure certaines variables d'environnement dans le fichier yaml de déploiement ou dans l'analyse d'image. 
* Image. Correspondance sur des noms d'images spécifiques, généralement combinée à d'autres critères de la règle. 
* Violations de la conformité de l'image. Vérifie si l'analyse de l'image (registre) a donné lieu à des violations de la conformité. Voir la xref:compliance.adoc#_managing_compliance_and_cis_benchmarks[conformité] pour plus de détails sur les contrôles de conformité. 
* Image sans information sur le système d'exploitation. Correspond si l'analyse de l'image (registre) ne permet pas de récupérer les informations relatives au système d'exploitation. 
* Registre des images. Correspond à des noms de registres d'images spécifiques. Généralement utilisé pour restreindre les déploiements à partir de certains registres ou pour exiger des déploiements uniquement à partir de certains registres approuvés. Souvent utilisé avec d'autres critères tels que les espaces de noms. 
* Image numérisée. Exiger qu'une image soit scannée. Souvent utilisé pour s'assurer que toutes les images sont analysées afin de garantir que les critères basés sur l'analyse, tels que les CVE élevés, peuvent être appliqués aux déploiements. 
* Image signée. Exiger qu'une image soit signée grâce à l'intégration de Sigstore/Cosign. Ce critère vérifie simplement s'il existe un vérificateur dans le résultat de l'analyse.
* Image Sigstore Verifiers. Exiger qu'une image soit signée par un nom de confiance Sigstore spécifique, tel que configuré dans Assets -> Sigstore Verifiers. Vérifie si les vérificateurs du résultat de l'analyse correspondent aux vérificateurs de la configuration des règles.
* Étiquettes. Exiger qu'une ou plusieurs étiquettes soient présentes dans le fichier yaml de déploiement ou dans les résultats de l'analyse d'image. 
* Modules. Exige ou exclut la présence de certains modules (paquets, bibliothèques) dans l'image à la suite de l'analyse de l'image (registre). 
* Monter les volumes. Généralement utilisé pour empêcher certains volumes d'être montés. 
* Espace de noms. Autoriser ou restreindre les déploiements pour certains espaces de noms. Utilisé indépendamment, mais souvent combiné à d'autres critères pour limiter la correspondance des règles à l'espace de noms. 
* Meilleure pratique PSP. Règles équivalentes pour les PSP (note : PSP est complètement supprimé de kubernetes 1.25+, mais cet équivalent {product-name} peut encore être utilisé dans 1.25+). Inclut Exécuter en tant que privilégié, Exécuter en tant que root, Partager les espaces de noms PID de l'hôte, Partager les espaces de noms IPC de l'hôte, Partager le réseau de l'hôte, Autoriser l'escalade des privilèges. 
* Configuration de la limite des ressources (RLC). Nécessite la configuration de limites de ressources pour le CPU Limit/Request, Memory Limit/Request, et peut exiger que l'opérateur soit > ou \<= à une valeur de ressource configurée. 
* Exécuter en tant que privilégié. Généralement utilisé pour limiter ou bloquer les déploiements de conteneurs privilégiés. 
* Exécuter en tant que root. Généralement utilisé pour limiter ou bloquer les déploiements de conteneurs exécutés en tant que root. 
* Service Account Bound High Risk Role. Peut correspondre à plusieurs critères susceptibles de représenter un rôle de compte de service à haut risque, notamment l'énumération de secrets, l'exécution d'opérations sur des charges de travail, la modification de ressources RBAC, la création de ressources de charge de travail et l'autorisation d'exécuter dans un conteneur. 
* Partager les espaces de noms IPC de l'hôte. Correspond aux espaces de noms IPC. 
* Partager le réseau de l'animateur. Autoriser ou non les déploiements à partager le réseau de l'hôte. 
* {blank}
** Partager les espaces de noms PID de l'hôte . Recherche sur les espaces de noms PID. 
* Utilisateur. Autoriser ou interdire les https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-subjects[utilisateurs] lors de l'exécution, visible dans le champ userInfo. Remarque : La fonction d'audit yaml (upload) ne pourra pas le vérifier car elle est liée à l'exécution. 
* Groupes d'utilisateurs. Autoriser ou interdire les https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-subjects[groupes d'utilisateurs] au moment de l'exécution, visibles dans le champ userInfo.  Remarque : La fonction d'audit yaml (upload) ne pourra pas le vérifier car elle est liée à l'exécution. 
* Violation de la politique de l'APS. Vérifie si le déploiement viole une PSA restreinte ou de base https://kubernetes.io/docs/concepts/security/pod-security-standards/[Pod Security Standard] (équivalent aux définitions PSA dans kubernetes 1.25+). 

=== Détection des secrets

La détection des secrets, par exemple dans les variables d'environnement, se fait à l'aide de l'expression rationnelle suivante :

[,shell]
----
Rule{Description: "Password.in.YML", 
Expression: `(?i)(password|passwd|api_token)\S{0,32}\s*:\s*(?-i)([0-9a-zA-Z\/+]{16,40}\b)`, ExprFName: `.*\.ya?ml`, Tags: []string{share.SecretProgram, "yaml", "yml"}, 
Suggestion: msgReferVender}, 
----

Dans la page **Rapports sur les risques**, lorsque des secrets sont détectés, le format d'alerte s'affiche avec les informations générales suivantes : "${variable}=${value}". Par exemple, dans l'image ci-dessous, on peut voir la variable "env1=AIDAJQ...".

image::https://github.com/user-attachments/assets/848533ed-70c1-494b-b7d5-6e9b60951f77[secret_detection]

Une liste des types de secrets détectés peut être consultée xref:compliance.adoc#_secrets_auditing[ici.] 

== Modes de contrôle d'admission

Deux modes sont pris en charge par {product-name}: le mode "surveillance" et le mode "protection".

* Moniteur : un message d'alerte apparaît dans le journal des événements si une décision est refusée. Dans ce cas, l'apiserver du cluster est autorisé à créer une ressource avec succès. Remarque : même si l'action de la règle est Deny, en mode Monitor, cela ne fera qu'alerter.
* Protect : il s'agit d'un mode de protection en ligne. Lorsqu'une décision est refusée, la ressource cluster ne peut pas être créée avec succès et un événement est enregistré.

== Règles de contrôle d'admission

Les règles peuvent être des règles d'autorisation (liste blanche) ou de refus (liste noire). Les règles sont évaluées dans l'ordre affiché, de haut en bas. Les règles Allow sont évaluées en premier et sont utiles pour définir des exceptions (sous-ensembles) aux règles Deny. Si le déploiement d'une ressource ne correspond à aucune règle, l'action par défaut est d'autoriser le déploiement.

Il existe deux règles préconfigurées qui devraient être autorisées pour permettre les déploiements de conteneurs système Kubernetes et de {product-name}.

Les règles de contrôle d'admission s'appliquent à toutes les ressources qui créent des pods (par exemple, les déploiements, les daemonsets, les replicasets, etc.)

Pour les règles de contrôle d'admission, l'ordre de correspondance est le suivant :

. Règles d'autorisation par défaut (par exemple, espaces de noms du système)
. Règles d'autorisation fédérées (si elles existent)
. Règles de refus fédérées (si elles existent)
. Règles d'autorisation appliquées par le CRD (si elles existent)
. Règles de refus appliquées par le CRD (si elles existent)
. Règles d'autorisation définies par l'utilisateur
. Règles de refus définies par l'utilisateur
. Autoriser la demande si elle ne correspond à aucun des critères de la règle ci-dessus.

Dans chacune des étapes de l'appariement (1~7), l'ordre des règles n'a pas d'importance. Tant que la demande correspond aux critères d'une règle, l'action (autoriser ou refuser) est prise et la demande est autorisée ou refusée.

== Le balayage fédéré aboutit à des règles de contrôle d'admission

Le cluster primaire (maître) peut analyser un registre/répo désigné comme registre fédéré. Les résultats de l'analyse de ces registres seront synchronisés avec tous les clusters gérés (à distance). Cela permet d'afficher les résultats de l'analyse dans la console du cluster géré et de les utiliser dans les règles de contrôle d'admission du cluster géré. Les registres ne doivent être analysés qu'une seule fois au lieu de l'être par chaque grappe, ce qui réduit l'utilisation de l'unité centrale, de la mémoire et de la bande passante du réseau. Voir la section sur xref:multicluster.adoc[les grappes multiples] pour plus de détails.

== Configuration des vérificateurs Sigstore/Cosign pour la signature d'images

Voir xref:sigstore.adoc[cette section] pour la configuration des vérificateurs.

== Dépannage

Si vous rencontrez des erreurs et que vous avez accès au nœud principal, vous pouvez inspecter le journal de kube-apiserver pour rechercher des événements de webhook d'admission. Exemples :

[,shell]
----
W0406 13:16:49.012234 1 admission.go:236] Failed calling webhook, failing open neuvector- validating-admission-webhook.neuvector.svc: failed calling admission webhook "neuvector-validating- admission-webhook.neuvector.svc": Post https://neuvector-svc-admission- webhook.neuvector.svc:443/v1/validate/1554514310852084622-1554514310852085078?timeout=30s: dial tcp: lookup neuvector-svc-admission-webhook.neuvector.svc on 8.8.8.8:53: no such host
----

Le journal ci-dessus indique que le cluster kube-apiserver n'est pas en mesure d'envoyer la requête au webhook {product-name} avec succès car il ne parvient pas à résoudre le nom neuvector-svc-admission-webhook.neuvector.svc.

[,shell]
----
W0405 23:43:01.901346 1 admission.go:236] Failed calling webhook, failing open neuvector- validating-admission-webhook.neuvector.svc: failed calling admission webhook "neuvector-validating- admission-webhook.neuvector.svc": Post https://neuvector-svc-admission-webhook.neuvector.svc:443/v1/validate/1554500399933067744-1554500399933068005?timeout=30s: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)
----

Le journal ci-dessus indique que le cluster kube-apiserver n'est pas en mesure d'envoyer la requête au webhook {product-name} avec succès car il résout le nom neuvector-svc-admission-webhook.neuvector.svc avec la mauvaise adresse IP. Cela peut également indiquer un problème de connectivité réseau ou de pare-feu entre le serveur api et les nœuds du contrôleur.

[,shell]
----
W0406 01:14:48.200513 1 admission.go:236] Failed calling webhook, failing open neuvector- validating-admission-webhook.xyz.svc: failed calling admission webhook "neuvector-validating- admission-webhook.xyz.svc": Post https://neuvector-svc-admission- webhook.xyz.svc:443/v1/validate/1554500399933067744-1554500399933068005?timeout=30s: x509: certificate is valid for neuvector-svc-admission-webhook.neuvector.svc, not neuvector-svc-admission- webhook.xyz.svc
----

Le journal ci-dessus indique que le cluster kube-apiserver peut envoyer la requête au webhook {product-name} avec succès mais que le certificat dans caBundle est erroné.

[,shell]
----
W0404 23:27:15.270619 1 admission.go:236] Failed calling webhook, failing open neuvector- validating-admission-webhook.neuvector.svc: failed calling admission webhook "neuvector-validating- admission-webhook.neuvector.svc": Post https://neuvector-svc-admission- webhook.neuvector.svc:443/v1/validate/1554384671766437200-1554384671766437404?timeout=30s: service "neuvector-svc-admission-webhook" not found
----

Le journal ci-dessus indique que le cluster kube-apiserver n'est pas en mesure d'envoyer la requête au webhook {product-name} avec succès car le service neuvector-svc-admission-webhook n'est pas trouvé.

=== Examiner les configurations du contrôle d'admission

Tout d'abord, vérifiez votre version de Kubernetes ou d'OpenShift. Le contrôle d'admission est pris en charge dans Kubernetes 1.9+ et OpenShift 3.9+.
Pour OpenShift, assurez-vous que vous avez édité le master-config.yaml pour ajouter la configuration MutatingAdmissionWebhook et redémarré les api-servers du master.

==== Vérifier le Clusterrole

[,shell]
----
kubectl get clusterrole neuvector-binding-admission -o json
----

Veillez à ce que les verbes comprennent :

[,json]
----
                "get",
                "list",
                "watch",
                "create",
                "update",
                "delete"
----

Vérifiez ensuite :

[,shell]
----
kubectl get clusterrole neuvector-binding-app -o json
----

Veillez à ce que les verbes comprennent :

[,json]
----
   "get",
   "list",
   "watch",
   "update"
----

Si les verbes ci-dessus ne figurent pas dans la liste, le bouton Test échouera.

==== Contrôler la fixation du rôle de la grappe

[,shell]
----
kubectl get clusterrolebinding neuvector-binding-admission -o json
----

Assurez-vous que le ServiceAccount est correctement défini :

[,json]
----
"subjects": [
        {
            "kind": "ServiceAccount",
            "name": "default",
            "namespace": "neuvector"
----

==== Vérifier la configuration du Webhook

[,shell]
----
kubectl get ValidatingWebhookConfiguration --as system:serviceaccount:neuvector:default -o yaml > nv_validation.txt
----

Le fichier nv_validation.txt doit avoir un contenu similaire :

.Cliquez ici pour plus d'informations
[%collapsible]
====
[,yaml]
----
apiVersion: v1
items:
- apiVersion: admissionregistration.k8s.io/v1beta1
  kind: ValidatingWebhookConfiguration
  metadata:
    creationTimestamp: "2019-09-11T00:51:08Z"
    generation: 1
    name: neuvector-validating-admission-webhook
    resourceVersion: "6859045"
    selfLink: /apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations/neuvector-validating-admission-webhook
    uid: 3e1793ed-d42e-11e9-ba43-000c290f9e12
  webhooks:
  - admissionReviewVersions:
    - v1beta1
    clientConfig:
      caBundle: {.........................}
      service:
        name: neuvector-svc-admission-webhook
        namespace: neuvector
        path: /v1/validate/{.........................}
    failurePolicy: Ignore
    name: neuvector-validating-admission-webhook.neuvector.svc
    namespaceSelector: {}
    rules:
    - apiGroups:
      - '*'
      apiVersions:
      - v1
      - v1beta1
      operations:
      - CREATE
      resources:
      - cronjobs
      - daemonsets
      - deployments
      - jobs
      - pods
      - replicasets
      - replicationcontrollers
      - services
      - statefulsets
      scope: '*'
    - apiGroups:
      - '*'
      apiVersions:
      - v1
      - v1beta1
      operations:
      - UPDATE
      resources:
      - daemonsets
      - deployments
      - replicationcontrollers
      - statefulsets
      - services
      scope: '*'
    - apiGroups:
      - '*'
      apiVersions:
      - v1
      - v1beta1
      operations:
      - DELETE
      resources:
      - daemonsets
      - deployments
      - services
      - statefulsets
      scope: '*'
    sideEffects: Unknown
    timeoutSeconds: 30
kind: List
metadata:
  resourceVersion: ""
  selfLink: ""
----
====

Si vous voyez un contenu comme "Error from server ...." ou "... is forbidden", cela signifie que le compte de service du contrôleur NV n'a pas le droit d'accéder à la ressource ValidatingWebhookConfiguration. Dans ce cas, cela signifie généralement que le neuvector-binding-admission clusterrole/clusterrolebinding présente un problème. La suppression et la recréation de neuvector-binding-admission clusterrole/clusterrolebinding constituent généralement la solution la plus rapide.

==== Tester le bouton de connexion du contrôle d'admission

Dans la console {product-name}, dans Policy -> Admission Control, allez dans More Operations -> Advanced Setting et cliquez sur le bouton "Test". {product-name} modifiera le service neuvector-svc-admission-webhook et verra si notre serveur webhook peut recevoir la notification de changement ou s'il échoue.

. Exécuter
+
--
[,shell]
----
kubectl get svc neuvector-svc-admission-webhook -n neuvector -o yaml
----

La sortie devrait ressembler à ceci :

[,yaml]
----
apiVersion: v1
   kind: Service
   metadata:
     annotations:
       ...................
     creationTimestamp: "2019-09-10T22:53:03Z"
     labels:
       echo-neuvector-svc-admission-webhook: "1568163072"      //===> from last test. could be missing if it's a fresh NV deployment
       tag-neuvector-svc-admission-webhook: "1568163072"       //===> from last test. could be missing if it's a fresh NV deployment
     name: neuvector-svc-admission-webhook
     namespace: neuvector
     ...................
   spec:
     clusterIP: 10.107.143.177
     ports:
     - name: admission-webhook
       port: 443
       protocol: TCP
       targetPort: 20443
     selector:
       app: neuvector-controller-pod
     sessionAffinity: None
     type: ClusterIP
   status:
     loadBalancer: {}
----
--
. Cliquez ensuite sur le bouton "Test" des paramètres avancés du contrôle d'admission ->. Attendez qu'il indique un succès ou un échec.{product-name} modifiera implicitement l'étiquette du service neuvector-svc-admission-webhook dans le tag-neuvector-svc-admission-webhook.
. Attendre le fonctionnement interne du contrôleur. Si le serveur webhook {product-name} reçoit une demande de mise à jour de kube-apiserver concernant ce changement de service, {product-name} modifiera le label echo-neuvector-svc-admission-webhook du service neuvector-svc-admission-webhook pour lui donner la même valeur que le label tag-neuvector-svc-admission-webhook.
. Exécuter
+
--
[,shell]
----
kubectl get svc neuvector-svc-admission-webhook -n neuvector -o yaml
----

Le résultat devrait ressembler à

[,yaml]
----
   apiVersion: v1
   kind: Service
   metadata:
     annotations:
       .............
     creationTimestamp: "2019-09-10T22:53:03Z"
     labels:
       echo-neuvector-svc-admission-webhook: "1568225712"      //===> changed in step 3-3 after receiving request from kube-apiserver
       tag-neuvector-svc-admission-webhook: "1568225712"       //===> changed in step 3-2 because of UI operation
     name: neuvector-svc-admission-webhook
     namespace: neuvector
     .................
   spec:
     clusterIP: 10.107.143.177
     ports:
     - name: admission-webhook
       port: 443
       protocol: TCP
       targetPort: 20443
     selector:
       app: neuvector-controller-pod
     sessionAffinity: None
     type: ClusterIP
   status:
     loadBalancer: {}
----
--
. Après le test, si la valeur de l'étiquette tag-neuvector-svc-admission-webhook ne change pas, cela signifie que le service contrôleur ne parvient pas à mettre à jour le service neuvector-svc-admission-webhook. Vérifier si neuvector-binding-app clusterrole/clusterrolebinding sont configurés correctement.
. Après le test, si la valeur du label tag-neuvector-svc-admission-webhook est modifiée mais pas celle du label echo-neuvector-svc-admission-webhook, cela signifie que le serveur webhook n'a pas reçu la requête du kube-apiserver. La requête de kub-apiserver ne peut pas atteindre le serveur webhook de {product-name}. Cela peut être dû à des problèmes de connectivité réseau, à des pare-feu qui bloquent la demande (sur le port par défaut 443), à la résolution d'une mauvaise adresse IP pour le contrôleur ou à d'autres facteurs.
