= Évaluer et tester {product-name}
:revdate: 2025-05-08
:page-revdate: {revdate}
:page-opendocs-origin: /09.testing/01.testing/01.testing.md
:page-opendocs-slug:  /testing/testing

== Exemples d'applications

Après avoir déployé les composants de {product-name}, vous pouvez l'évaluer à l'aide des exemples d'applications de test que nous fournissons. Ceux-ci sont situés dans le dépôt `'nvbeta`' sur docker hub.

Un environnement de test typique basé sur Kubernetes comporte un nœud maître et deux ou trois nœuds de travail. Vous pouvez contrôler si les pods d'application et les conteneurs {product-name} sont déployés sur un nœud maître (désactivé par défaut).

== Plan de test Kubernetes

Pour déployer une application multi-tiers à l'aide de Nginx, Nodejs et Redis, utilisez les exemples ci-dessous (dans l'ordre). Il peut être nécessaire de les éditer pour le déploiement sur OpenShift, Rancher et d'autres outils basés sur Kubernetes.

Créer un espace de noms de démonstration

[,shell]
----
kubectl create namespace demo
----

[NOTE]
====
L'exemple ci-dessous utilise apiVersion : apps/v1 requis par Kubernetes 1.16+.
====

Créer le service Redis et le déploiement en utilisant ce yaml :

[,yaml]
----
apiVersion: v1
kind: Service
metadata:
  name: redis
  namespace: demo
spec:
  ports:
  - port: 6379
    protocol: "TCP"
    name: "cluster-tcp-6379"
  clusterIP: None
  selector:
    app: redis-pod

---

apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis-pod
  namespace: demo
spec:
  selector:
    matchLabels:
      app: redis-pod
  template:
    metadata:
      labels:
        app: redis-pod
    spec:
      containers:
      - name: redis-pod
        image: redis
----

Créez le service Nodejs et le déploiement à l'aide de ce fichier yaml :

[,yaml]
----
apiVersion: v1
kind: Service
metadata:
  name: node
  namespace: demo
spec:
  ports:
  - port: 8888
    protocol: "TCP"
    name: "cluster-tcp-8888"
  clusterIP: None
  selector:
    app: node-pod

---

apiVersion: apps/v1
kind: Deployment
metadata:
  name: node-pod
  namespace: demo
spec:
  selector:
    matchLabels:
      app: node-pod
  replicas: 3
  template:
    metadata:
      labels:
        app: node-pod
    spec:
      containers:
      - name: node-pod
        image: nvbeta/node
----

Créez le service Nginx et le déploiement à l'aide de ce fichier yaml :

[,yaml]
----
apiVersion: v1
kind: Service
metadata:
  name: nginx-webui
  namespace: demo
spec:
  ports:
    - port: 80
      name: webui
      protocol: TCP
  type: NodePort
  selector:
    app: nginx-pod

---

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-pod
  namespace: demo
spec:
  selector:
    matchLabels:
      app: nginx-pod
  template:
    metadata:
      labels:
        app: nginx-pod
    spec:
      containers:
      - name: nginx-pod
        image: nvbeta/swarm_nginx
        ports:
        - containerPort: 80
          protocol: TCP
----

Pour accéder au service Nginx-webui de manière externe, trouvez le port aléatoire qui lui est attribué (mappé sur le port 80) par le NodePort :

[,shell]
----
kubectl get svc -n demo
----

Ensuite, connectez-vous à l'adresse IP publique/au port de l'un des nœuds kubernetes, par exemple `http://(public_IP):(NodePort)`

Après avoir déployé {product-name}, vous pouvez exécuter un trafic de test via les applications de démonstration pour générer les règles de la liste blanche, puis faire passer tous les services en mode Monitor ou Protect pour voir les violations et les attaques.

=== Générer des violations de réseau sur Kubernetes

Pour générer une violation à partir d'un pod nodejs, il faut trouver un pod :

[,shell]
----
kubectl get pod -n demo
----

Ensuite, essayez quelques violations (remplacez node-pod-name) :

[,shell]
----
kubectl exec node-pod-name curl www.google.com -n demo
----

Vous pouvez également trouver l'adresse IP interne d'un autre nœud, comme 172.30.2.21 dans l'exemple ci-dessous, pour vous connecter d'un nœud à l'autre :

[,shell]
----
kubectl exec node-pod-name curl 172.30.2.21:8888 -n demo
----

==== Générer une menace/attaque

Pour simuler une attaque, connectez-vous à un conteneur, puis tentez une attaque par ping :

[,shell]
----
kubectl exec -it node-pod-name bash -n demo
----

Utiliser l'IP interne d'un autre nœud pod :

[,shell]
----
ping 172.30.2.21 -s 40000
----

Pour tous les éléments ci-dessus, vous pouvez visualiser les événements de sécurité dans la carte d'activité réseau de la console {product-name}, ainsi que dans l'onglet Notifications.

=== Tests de protection des processus et des fichiers

Essayez différentes activités de processus et de fichiers en vous exécutant dans un conteneur et en lançant des commandes telles que apt-get update, ssh, scp ou autres. Toute activité de processus ou tout accès à un fichier non autorisé génère des alertes dans les notifications.

=== Analyse du registre et contrôle d'admission

Un test courant consiste à configurer l'analyse d'image d'un registre dans Assets -> Registries. Une fois l'analyse terminée, configurez une règle de contrôle d'admission dans Politique. Veillez à activer les contrôles d'admission et à définir une règle de refus en cas de vulnérabilité élevée d'une image. Choisissez ensuite une image qui présente des vulnérabilités élevées et essayez de la déployer dans Kubernetes. Le déploiement sera bloqué en mode protection et vous verrez un événement dans les notifications -> Security Risks.

Des tests de contrôle d'admission plus avancés peuvent être effectués en utilisant différents critères dans les règles, ou en combinant des critères.

==== Déployer une autre application

L'application de démonstration Kubernetes Guestbook peut également être déployée sur Kubernetes. Il est recommandé de le déployer dans son propre espace de noms afin que vous puissiez voir le filtrage basé sur l'espace de noms dans la console {product-name}.

== Plan de test Docker-native

Après avoir déployé les composants {product-name} et les exemples d'application, vous serez en mesure de découvrir, de surveiller et de protéger les conteneurs en cours d'exécution. Le plan de test ci-dessous propose des suggestions pour générer des violations du comportement autorisé de l'application au cours de l'exécution et pour rechercher les vulnérabilités dans les conteneurs.

xref:attachment$testplan.pdf[{product-name} Plan de test]

Si le lien ci-dessus ne fonctionne pas, vous pouvez http://neuvector.com/sample-applications-test-plan/[le télécharger] à partir de notre site web en utilisant le mot de passe nv1851blvd.

{product-name} peut également détecter les menaces pesant sur vos conteneurs, telles que les attaques DDOS. Si vous exécutez un outil pour générer de telles attaques sur vos conteneurs, les résultats s'afficheront dans l'activité du réseau et dans le tableau de bord.

Par exemple, une simple commande ping avec une charge utile élevée affichera l'attaque Ping.Death dans la console. Pour essayer, faites ce qui suit à l'adresse IP de l'un des conteneurs (IP interne du conteneur).

[,shell]
----
ping <container_ip> -s 40000
----

Dans Kubernetes, vous pouvez le faire à partir de n'importe quel nœud, y compris le maître. Dans d'autres environnements, il est possible que vous deviez être connecté au nœud où le conteneur est en cours d'exécution.
