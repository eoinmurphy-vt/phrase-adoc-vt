= Amazon ECS
:revdate: 2024-09-27
:page-revdate: {revdate}
:page-opendocs-origin: /02.deploying/09.ecs/09.ecs.md
:page-opendocs-slug: /Bereitstellung/ecs

== Das ist wichtig: Die Bereitstellung auf Amazon ECS wird nicht mehr unterstützt

Der nachstehende Referenzabschnitt wird nicht mehr gepflegt. Es kann jedoch eine Hilfe sein, um zu verstehen, wie Allinone auf ECS eingesetzt werden kann.

== Bereitstellen auf AWS mit ECS

Dies ist ein Beispiel für die Bereitstellung von {product-name} mit ECS.

[NOTE]
====
Bitte sehen Sie sich die Kubernetes-Beispiele für EKS an.
====

. Bereiten Sie mehrere Amazon ECS-Instanzen vor, in denen die Docker-Engine und ECS-Agent-Container integriert sind. Wählen Sie einen Knoten für die Verwaltungskonsole. Definieren Sie dann Regeln für Sicherheitsgruppen, die den eingehenden TCP-Port 8443 (den Standard-Port der Verwaltungskonsole{product-name}) für den Zugriff durch Ihren Client-Browser zulassen.
. Definieren Sie eine Sicherheitsgruppe, die TCP- und UDP-Ports auf 18300, 18301, 18400, 18401 zulässt. Dies wird von {product-name} Vollstreckern benutzt, um mit den Kontrolleuren/Allinone zu sprechen. Wenden Sie diese Sicherheitsgruppe auf alle ECS-Instanzen an, die die {product-name} enforcers und controllers/allinone bereitstellen werden.
. Legen Sie ein Attribut für die Knoten fest, die Sie bereitstellen möchten {product-name} allinone oder controller container. Wenn Sie z. B. {product-name} in einem Controller-HA-Modus betreiben möchten, empfiehlt es sich, mindestens 3 Knoten auszuwählen und das Attribut allen 3 Knoten hinzuzufügen.
+
--
So fügen Sie Attribute zu Ihren ECS-Instanzen hinzu:

Wählen Sie die Instanz aus und wählen Sie dann "`View/Edit Attributes`" aus dem Dropdown-Menü "Aktionen".

image:1viewattributes.png[Attribute]

Fügen Sie dann ein neues Attribut hinzu. Zum Beispiel "`allinone-node`" mit dem Wert "`true`".

image:2addattribute.png[AddAttributes]
--
. Erstellen Sie die Allinone-Aufgabendefinition. Erstellen Sie eine neue Aufgabendefinition für den Allinone-Container. Sie können die ECS-Schnittstelle verwenden, um sie manuell zu erstellen, oder die JSON-Beispieldatei einfügen (siehe unten für Beispiele). Wie Sie den Allinone konfigurieren, erfahren Sie in Abschnitt "`1. Deploying {product-name}`" dieser Dokumentation.
+
--
Geben Sie die Platzierungsbeschränkung ein. Wenn Sie z. B. die obige Attributbeschriftung verwendet haben, dann geben Sie dies in die Einschränkung ein.

[,json]
----
attribute:allinone-node=~true
----

image:3taskdef.png[AllinoneTask]

[NOTE]
====
Wenn Sie die aktualisierte JSON-Datei jetzt untersuchen, sehen Sie, dass die Platzierungsbeschränkung hinzugefügt wurde.
====
--
. Erstellen Sie einen neuen Dienst für die Aufgabe Allinone. Stellen Sie "`Placement Templates`" auf "`One Task Per Host`" ein, damit nur ein Allinone/Controller auf einem Host laufen kann. Sie werden auch sehen, dass die Einschränkung "`memberOf(attribute:allinone-node=~true)" verwendet wird, die erfordert, dass der Knoten dieses Attribut hat.
+
--
image:3taskplacement.png[AllinonePlace]
--
. Jetzt können Sie den Allinone-Dienst einsetzen. Stellen Sie die "`Number of tasks`" auf die gewünschte Allinone/Controller-Nummer ein. Jetzt werden die {product-name} Allinone- oder Controller-Container auf den ausgewählten Knoten gestartet. Nachdem Allinone gestartet ist, sollten Sie in der Lage sein, sich über HTTPS auf Port 8443 mit der {product-name} Konsole zu verbinden.
. Erstellen Sie die Enforcer-Aufgabendefinition. Dies ist ähnlich wie die Allinone-Aufgabe. Konfigurieren Sie manuell über die ECS-Konsole oder verwenden Sie das unten stehende JSON-Beispiel.
+
--
Für die Platzierungsbeschränkung "Enforcer" müssen Sie festlegen, dass sich der "Enforcer" NICHT auf demselben Knoten wie der "Allinone" befinden darf.

[,json]
----
attribute:allinone-node!~true
----

image:4enforcertask.png[EnforcerTask]
--
. Erstellen Sie einen neuen Dienst für die Aufgabe Enforcer. Setzen Sie auch hier die Task-Platzierung auf "`One Task Per Host`", damit auf jedem Host nur ein Enforcer eingesetzt wird. Beachten Sie auch, dass die zusätzliche Einschränkung zeigen sollte, dass sie den Einsatz auf einem All-in-One-Knoten verhindert.
+
--
image:5taskplacement.png[EnforcerPlacement]

Stellen Sie diesen Dienst mit der gewünschten Anzahl von Enforcer-Knoten in "`Number of tasks`" bereit. In Kürze werden alle Vollstrecker einsatzbereit sein. Auf der Konsole {product-name} können Sie alle Knoten sehen, die mit Enforcern erkannt werden.
--

== Beispiele für ECS JSON-Aufgabendefinitionen

Sie können die folgenden Beispiele als Ausgangspunkt für die Konfiguration der Aufgabendefinitionen für die {product-name} Container verwenden.

Erstellen Sie eine neue Aufgabendefinition, und klicken Sie dann unten auf Über JSON konfigurieren. Ersetzen Sie die IP-Adresse und den Bildpfad, bevor Sie die nachstehende json-Datei einfügen (siehe REPLACE in den Beispielen). In der Regel ist die IP-Adresse die private IP-Adresse der AWS-Instanz, auf der der allinone ausgeführt wird. Sie können auch einen anderen Familiennamen als my-allinone/my-enforcer angeben (am Ende von json).

Beispiel einer Allinone json-Datei:

.Klicken Sie hier für Details
[%collapsible]
====
[,json]
----
{
    "networkMode": "bridge",
    "taskRoleArn": null,
    "pidMode": "host",
    "containerDefinitions": [
        {
            "volumesFrom": [],
            "memory": null,
            "extraHosts": null,
            "dnsServers": null,
            "disableNetworking": null,
            "dnsSearchDomains": null,
            "portMappings": [
                {
                    "hostPort": 18300,
                    "containerPort": 18300,
                    "protocol": "tcp"
                },
                {
                    "hostPort": 18301,
                    "containerPort": 18301,
                    "protocol": "tcp"
                },
                {
                    "hostPort": 18400,
                    "containerPort": 18400,
                    "protocol": "tcp"
                },
                {
                    "hostPort": 18401,
                    "containerPort": 18401,
                    "protocol": "tcp"
                },
                {
                    "hostPort": 18301,
                    "containerPort": 18301,
                    "protocol": "udp"
                },
                {
                    "hostPort": 8443,
                    "containerPort": 8443,
                    "protocol": "tcp"
                },
                {
                    "hostPort": 1443,
                    "containerPort": 10443,
                    "protocol": "tcp"
                }
            ],
            "hostname": null,
            "essential": true,
            "entryPoint": null,
            "mountPoints": [
                {
                    "containerPath": "/lib/modules",
                    "sourceVolume": "modules",
                    "readOnly": null
                },
                {
                    "containerPath": "/var/run/docker.sock",
                    "sourceVolume": "dockersock",
                    "readOnly": null
                },
                {
                    "containerPath": "/host/proc",
                    "sourceVolume": "proc",
                    "readOnly": true
                },
                {
                    "containerPath": "/host/cgroup",
                    "sourceVolume": "cgroup",
                    "readOnly": true
                }
            ],
            "name": "allinone",
            "ulimits": null,
            "dockerSecurityOptions": null,
            "environment": [
                {
                    "name": "CLUSTER_JOIN_ADDR",
                    "value": "REPLACE: Private IP"
                }
            ],
            "links": null,
            "workingDirectory": null,
            "readonlyRootFilesystem": false,
            "image": "REPLACE: Image Path/Name",
            "command": null,
            "user": null,
            "dockerLabels": {
                "com.myself.name": "neuvector"
            },
            "logConfiguration": null,
            "cpu": 0,
            "privileged": true,
            "memoryReservation": 768
        }
    ],
    "volumes": [
        {
            "host": {
                "sourcePath": "/lib/modules"
            },
            "name": "modules"
        },
        {
            "host": {
                "sourcePath": "/var/run/docker.sock"
            },
            "name": "dockersock"
        },
        {
            "host": {
                "sourcePath": "/proc"
            },
            "name": "proc"
        },
        {
            "host": {
                "sourcePath": "/sys/fs/cgroup"
            },
            "name": "cgroup"
        }
    ],
    "family": "my-allinone",
    "placementConstraints": []
}
----
====

Beispiel einer Enforcer json-Datei:

.Klicken Sie hier für Details
[%collapsible]
====
[,json]
----
{
    "networkMode": "bridge",
    "taskRoleArn": null,
    "pidMode": "host",
    "containerDefinitions": [
        {
            "volumesFrom": [],
            "memory": null,
            "extraHosts": null,
            "dnsServers": null,
            "disableNetworking": null,
            "dnsSearchDomains": null,
            "portMappings": [
                {
                    "hostPort": 18301,
                    "containerPort": 18301,
                    "protocol": "tcp"
                },
                {
                    "hostPort": 18401,
                    "containerPort": 18401,
                    "protocol": "tcp"
                },
                {
                    "hostPort": 18301,
                    "containerPort": 18301,
                    "protocol": "udp"
                }
            ],
            "hostname": null,
            "essential": true,
            "entryPoint": null,
            "mountPoints": [
                {
                    "containerPath": "/lib/modules",
                    "sourceVolume": "modules",
                    "readOnly": null
                },
                {
                    "containerPath": "/var/run/docker.sock",
                    "sourceVolume": "dockersock",
                    "readOnly": null
                },
                {
                    "containerPath": "/host/proc",
                    "sourceVolume": "proc",
                    "readOnly": true
                },
                {
                    "containerPath": "/host/cgroup",
                    "sourceVolume": "cgroup",
                    "readOnly": true
                }
            ],
            "name": "enforcer",
            "ulimits": null,
            "dockerSecurityOptions": null,
            "environment": [
                {
                    "name": "CLUSTER_JOIN_ADDR",
                    "value": "REPLACE: Private IP"
                }
            ],
            "links": null,
            "workingDirectory": null,
            "readonlyRootFilesystem": false,
            "image": "REPLACE: Image Path/Name",
            "command": null,
            "user": null,
            "dockerLabels": {
                "com.myself.name": "neuvector"
            },
            "logConfiguration": null,
            "cpu": 0,
            "privileged": true,
            "memoryReservation": 512
        }
    ],
    "volumes": [
        {
            "host": {
                "sourcePath": "/lib/modules"
            },
            "name": "modules"
        },
        {
            "host": {
                "sourcePath": "/var/run/docker.sock"
            },
            "name": "dockersock"
        },
        {
            "host": {
                "sourcePath": "/proc"
            },
            "name": "proc"
        },
        {
            "host": {
                "sourcePath": "/sys/fs/cgroup"
            },
            "name": "cgroup"
        }
    ],
    "family": "my-enforcer",
    "placementConstraints": []
}
----
====

== Live-Aktualisierung {product-name}

Sie können eine Live-Aktualisierung der {product-name} Container in ECS durchführen, ohne die Dienste zu unterbrechen. Die Dienste von {product-name} können problemlos aktualisiert oder aufgerüstet werden, ohne laufende Dienste zu unterbrechen. Um dies in Amazon ECS zu tun:

. Wenn Sie mehrere Controller oder Allinones in einem Cluster einsetzen, überspringen Sie diesen Schritt. Wenn nur ein einziger Allinone/Controller im System vorhanden ist, suchen Sie eine neue ECS-Instanz und stellen Sie einen zweiten Allinone/Controller-Container darauf bereit (folgen Sie den {product-name} allinone/controller ECS-Bereitstellungsschritten). Nach der Bereitstellung sehen Sie in der Verwaltungskonsole {product-name}, dass dieser neue Controller in Betrieb ist (unter Ressourcen > Controller). Dies ist erforderlich, damit alle zustandsbezogenen Daten zwischen den Controllern repliziert werden.
. Setzen Sie in ECS Services den alten Allinone/Controller-Dienst zurück und löschen Sie ihn. Ziehen Sie die aktualisierten {product-name} Images manuell oder veranlassen Sie AWS ECS, neue Versionen von Allinone/Controller-Containern von Dockerhub oder Ihrer privaten Registry zu ziehen.
. Erstellen Sie eine neue Revision der Allinone/Controller-Aufgabe, aktualisieren Sie die "`CLUSTER_JOIN_ADDR`" auf die private Knoten-IP-Adresse des zweiten Allinone/Controllers.
. Erstellen Sie einen neuen Dienst, um diese neue Aufgabe zu verteilen (befolgen Sie die gleichen Schritte für die Verteilung auf ECS). Nach der Fertigstellung sollte die neue Version des Allinone/Controllers betriebsbereit sein. In der Verwaltungskonsole {product-name} sollten alle Protokolle und Richtlinien noch vorhanden sein. Optional können Sie jetzt den 2. Allinone/Controller-Container herunterfahren, da nun ein Allinone/Controller auf dem ursprünglichen Knoten gestartet sein sollte.
. Schalten Sie die ECS-Dienste aus und aktualisieren Sie die Enforcer. Manuelles oder automatisches Auslösen des Abrufs neuer Enforcer-Images. Starten oder aktualisieren Sie dann den Enforcer auf allen Knoten neu. Auf der Konsole {product-name} sehen Sie, dass alle Enforcer auf dem neuesten Stand sind.
. Wenn Sie den separaten Manager-Container anstelle des Allinone-Containers verwenden (in dem der Manager bereits enthalten ist), fahren Sie einfach den alten Manager-Container herunter und entfernen ihn. Ziehen Sie dann die neue Managerversion und setzen Sie sie ein, wobei Sie die CLUSTER_JOIN_ADDR auf die IP des Controllers richten.

Alle {product-name} Container werden jetzt live aktualisiert. Alle Richtlinien, Protokolle und Konfigurationen sind davon nicht betroffen. Die Live-Grafik wird automatisch neu generiert, sobald neuer Live-Verkehr zwischen Containern fließt.
