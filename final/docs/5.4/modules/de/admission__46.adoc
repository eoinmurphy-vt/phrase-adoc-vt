= Zulassungskontrollen
:revdate: 2025-06-25
:page-revdate: {revdate}
:page-opendocs-origin: /05.policy/03.admission/03.admission.md
:page-opendocs-slug:  /policy/zulassung

== Steuerung von Image-/Container-Bereitstellungen

Mit der Integration von Admission Control in Orchestrierungsplattformen wie Kubernetes und OpenShift spielt {product-name} eine wichtige Rolle innerhalb der Bereitstellungspipeline der Orchestrierungsplattform. Wenn eine Cluster-Ressource, wie z. B. eine Bereitstellung, erstellt wird, wird die Anfrage vom Cluster-Api-Server an einen der {product-name} Controller weitergeleitet, um festzustellen, ob die Bereitstellung auf der Grundlage der benutzerdefinierten Zulassungssteuerungsregeln vor der Erstellung der Cluster-Ressource zugelassen oder verweigert werden soll. Die von {product-name} getroffene Richtlinienentscheidung wird zur Durchsetzung an den Cluster-Apiserver zurückgegeben.

Diese Funktion wird in Kubernetes 1.9+ und Openshift 3.9+ unterstützt. Vor der Verwendung der Funktion Admission Control in {product-name} ist es zwar möglich, die Zulassungskontrolle über das an den Cluster-Apiserver übergebene Argument `--admission-control` einzurichten, es wird jedoch empfohlen, eine dynamische Zulassungskontrolle zu verwenden. Informationen zur Konfiguration finden Sie in den Abschnitten zu Kubernetes und Openshift weiter unten.

=== Kubernetes

Die Plugins ValidatingAdmissionWebhook und MutatingAdmissionWebhook sind standardmäßig aktiviert.

Prüfen, ob admissionregistration.kubernetes.io/v1beta1 aktiviert ist

[,bash]
----
kubectl api-versions | grep admissionregistration
admissionregistration.k8s.io/v1beta1
----

=== Openshift

Die Plugins ValidatingAdmissionWebhook und MutatingAdmissionWebhook sind standardmäßig NICHT aktiviert. Bitte lesen Sie die Beispiele in den OpenShift-Bereitstellungsabschnitten, um zu erfahren, wie Sie diese aktivieren können. Ein Neustart der OpenShift api und der Controller-Dienste ist erforderlich.

Prüfen, ob admissionregistration.kubernetes.io/v1beta1 aktiviert ist

[,bash]
----
oc api-versions | grep admissionregistration
admissionregistration.k8s.io/v1beta1
----

== Aktivieren der Zulassungskontrolle (Webhook) in {product-name}

Die Funktion Zulassungskontrolle ist standardmäßig deaktiviert. Rufen Sie die Seite Policy -> Admission Control auf, um sie in der Konsole {product-name} zu aktivieren.

image:ac_enable.png[Aktivieren Sie]

Sobald die Zulassungskontrolle erfolgreich aktiviert ist, wird die folgende ValidatingWebhookConfiguration-Ressource automatisch erstellt. Zur Kontrolle:

[,shell]
----
kubectl get ValidatingWebhookConfiguration neuvector-validating-admission-webhook
----

Beispielhafte Ausgabe:

[,shell]
----
NAME                                     CREATED AT
neuvector-validating-admission-webhook   2019-03-28T00:05:09Z
----

Die wichtigsten Informationen in der ValidatingWebhookConfiguration-Ressource für {product-name} sind die Cluster-Ressourcen. Sobald eine Cluster-Ressource wie z. B. Deployment {product-name} registriert ist, wird die Anfrage von der Orchestrierungsplattform apiserver an einen der {product-name} Controller gesendet, um festzustellen, ob sie auf der Grundlage der benutzerdefinierten Regeln auf der Seite {product-name} Policy -> Admission Control zugelassen oder abgelehnt werden soll.

Wenn die Bereitstellung der Ressource verweigert wird, wird ein Ereignis in den Benachrichtigungen protokolliert.

Um die Kubernetes-Verbindung für den Zugriff im Client-Modus zu testen, gehen Sie zu Erweiterte Einstellungen.

image:ac_advanced.png[Fortgeschrittene]

In besonderen Fällen kann die URL-Zugriffsmethode unter Verwendung des NodePort-Dienstes erforderlich sein.

== Ereignisse/Benachrichtigungen der Zulassungskontrolle

Alle Ereignisse der Zutrittskontrolle für zugelassene und verweigerte Ereignisse finden Sie im Menü Benachrichtigungen -> Sicherheitsrisiken.

== Kriterien für die Zulassungskontrolle

{product-name} unterstützt viele Kriterien für die Erstellung einer Zulassungskontrollregel. Dazu gehören CVE High Count, CVE Names, image labels, imageScanned, namespace, user, runAsRoot, etc. Es gibt zwei mögliche Quellen für die Bewertung der Kriterien: Image Scans und Deployment Yaml File Scans. Wenn ein Kriterium einen Bildscan erfordert, werden die Scanergebnisse des Registrierungsscannings verwendet. Wenn das Bild nicht gescannt wurde, wird die Zulassungskontrollregel nicht angewendet. Wenn ein Kriterium das Scannen der Deployment-Yaml erfordert, wird es vom Kubernetes-Deployment ausgewertet. Bei einigen Kriterien werden entweder die Ergebnisse eines Image-Scans ODER eines Deployment-Yaml-Scans verwendet.

* CVE-Score ist ein Beispiel für ein Kriterium, das einen Bildscan erfordert.
* Umgebungsvariablen mit Geheimnissen sind ein Beispiel für ein Kriterium, bei dem der Einsatz von yaml gescannt wird.
* Beschriftungen und Umgebungsvariablen sind Beispiele für Kriterien, die BEIDE Ergebnisse von Image- und Deployment-Yaml-Scans verwenden (logisches ODER), um Übereinstimmungen zu ermitteln.

image:adm_control_criteria.png[Criteria]

Nachdem das Kriterium ausgewählt wurde, werden die möglichen Operatoren angezeigt. Klicken Sie auf die Schaltfläche '`+`', um jedes Kriterium hinzuzufügen.

*Verwendung mehrerer Kriterien in einer einzigen Regel*Die Anpassungslogik für mehrere Kriterien in einer Zulassungskontrollregel lautet:

* Für verschiedene Kriterientypen innerhalb einer einzigen Regel, verwenden Sie 'und'.
* Für mehrere Kriterien desselben Typs (z. B. mehrere Namespaces, Registries, Bilder),
** Wenden Sie 'und' auf alle negativen Übereinstimmungen ("enthält keine", "ist keine von") an, bis die erste positive Übereinstimmung vorliegt;
** Nach der ersten positiven Übereinstimmung, 'oder' anwenden

=== Beispiel für die Zuordnung eines Pod-Etiketts

[,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: iperfserver
  namespace: neuvector-1
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: iperfserver
----

Die entsprechende Regel würde lauten:

image:ac_label.png[Zulassung]

=== Beispiel für den Abgleich von Umgebungsvariablen mit Geheimnissen

[,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: iperfserver
  namespace: neuvector-1
  labels:
    name: iperfserver
spec:
  selector:
    matchLabels:
      name: iperfserver
  replicas: 1
  template:
    metadata:
      labels:
        name: iperfserver
    spec:
      containers:
        - name: iperfserver
          image: nvlab/iperf
          env:
            - name: env1
              value: AIDAJQABLZS4A3QDU576
            - name: env2
              valueFrom:
                fieldRef:
                  fieldPath: status.podIP
            - name: env5
              value: AIDAJQABLZS4A3QDU57E
          command:
            - iperf
            - -s
            - -p
            - "6068"
      nodeSelector:
        nvallinone: "true"
      restartPolicy: Always
----

Die Matching-Regel würde lauten:

image:ac_environment.png[Zulassung]

=== Kriterien in Bezug auf die Scanergebnisse

Die folgenden Kriterien beziehen sich auf die Ergebnisse auf der Seite {product-name} Assets > Registry scan:

Image, imageScanned, cveHighCount, cveMediumCount, Image compliance violations, cveNames und andere.

Bevor {product-name} den Abgleich mit den Regeln der Zugangskontrolle durchführt, ruft {product-name} die Bildinformationen (z. B. 10.1.127.3:5000/neuvector/toolbox/iperf:latest) vom Cluster-Apiserver ab (siehe Abschnitt Anforderung vom Apiserver weiter unten). Das Bild setzt sich zusammen aus Registrierungsserver (`https://10.1.127.3:5000`), Repository (neuvector/toolbox/iperf) und Tag (latest).

{product-name} verwendet diese Informationen, um die Ergebnisse auf der Seite {product-name} Assets -> Registry scan abzugleichen, und sammelt die entsprechenden Informationen, wie z. B. den Namen des Schädlings, die Anzahl der Schädlinge (hoch oder mittel) usw. Verstöße gegen die Bildkonformität gelten als jedes Bild, das Geheimnisse oder setuid/setgid-Verletzungen aufweist.
Wenn Benutzer das Image aus der Docker-Registry verwenden, um eine Cluster-Ressource zu erstellen, sind die Registry-Server-Informationen normalerweise leer oder docker.io. Derzeit verwendet {product-name} die folgenden hart kodierten Registry-Server, um das Ergebnis des Registry-Scans anstelle des leeren oder docker.io-Strings abzugleichen. Wenn auf der Seite für den Registrierungsscan mehr als die folgenden unterstützten Docker-Registrierungsserver definiert sind, kann {product-name} die Ergebnisse des Registrierungsscans natürlich nicht erfolgreich abrufen.

Wenn Benutzer das integrierte Image wie Alpine oder Ubuntu aus der Docker-Registry verwenden, gibt es einen versteckten Organisationsnamen namens library. Wenn Sie sich die Ergebnisse für das Docker-Build-in-Image auf der Seite {product-name} Assets > Registry scan ansehen, lautet der Repository-Name library/alpine oder library/ubuntu. Derzeit geht {product-name} davon aus, dass es nur einen versteckten Bibliotheksorganisationsnamen in der Docker-Registry gibt. Wenn es mehr als einen gibt, ist {product-name} nicht in der Lage, die Ergebnisse des Registrierungs-Scans auch erfolgreich zu erhalten.
Die obige Einschränkung könnte auch für andere Arten von Docker-Registrierungsservern gelten, falls vorhanden.

=== Benutzerdefinierte Kriterienregeln erstellen

Benutzer können ein benutzerdefiniertes Kriterium erstellen, mit dem Bereitstellungen auf der Grundlage allgemeiner Objekte, die in der (bei der Bereitstellung gescannten) Image-Yaml gefunden werden, zugelassen oder blockiert werden können. Wählen Sie das zu verwendende Objekt, z. B. imagePullSecrets, und den passenden Wert, z. B. exists. Es wird auch empfohlen, zusätzliche Kriterien zu verwenden, um die Regel gezielter zu gestalten, z. B. Namespace, PSP/PSA, CVE-Bedingungen usw.

image:custom_admission.png[Zulassung]

==== Erklärungen zu den Kriterien

Kriterien mit einem Festplattensymbol erfordern, dass das Image gescannt wird (siehe Scannen der Registrierung), und Kriterien mit einem Dateisymbol scannen die Bereitstellungs-Yaml. Wenn beide Symbole aufgelistet sind, erfolgt der Abgleich für eines von beiden (ODER). Wenn ein Kriterium einen Bildscan erfordert, das Bild aber NICHT gescannt wird, wird dieser Teil der Regel ignoriert (d. h. die Regel wird umgangen, oder wenn auch das Bereitstellungsjaml aufgeführt ist, wird nur das Bereitstellungsjaml für die Übereinstimmung verwendet). Um zu verhindern, dass nicht gescannte Bilder die Regeln umgehen, siehe unten das Kriterium "Gescanntes Bild". 

* Individuelles Kriterium hinzufügen. Wählen Sie das Objekt aus der Dropdown-Liste aus. Alle benutzerdefinierten Kriterien unterstützen vorhandene und nicht vorhandene Operatoren. Für diejenigen, die Werte zulassen, können zusätzliche Operatoren und der Wert eingegeben werden. Die Werte können statisch sein, durch Kommas getrennt werden und Wildcards enthalten. 
* Privilegieneskalation zulassen. Erlaubt der Container Privilegienerweiterungen, so kann er durch die Aktion Ablehnen blockiert werden. 
* Anzahl der CVE mit hohem Schweregrad. Dabei werden die Ergebnisse eines Image-Scans (Registry-Scans) herangezogen und mit der Anzahl der hochgradig schwerwiegenden Fälle (CVSS-Scores von 7 oder höher) verglichen. Es kann ein zusätzlicher Operator hinzugefügt werden, um CVEs einzuschränken, die eine bestimmte Anzahl von Tagen zuvor gemeldet wurden, um Zeit für die Behebung neuer CVEs zu haben. 
* Anzahl der hochgradig schwerwiegenden CVEs mit Fix. Dabei werden die Ergebnisse eines Image-Scans (Registry-Scans) herangezogen und auf einen hohen Schweregrad (CVSS-Scores von 7 oder höher) abgestimmt UND darauf, ob ein Fix für die CVE verfügbar ist. Wählen Sie diese Option, wenn Sie die Bereitstellung von hohen CVEs nur dann blockieren wollen, wenn eine Korrektur hätte angewendet werden müssen. Es kann ein zusätzlicher Operator hinzugefügt werden, um CVEs einzuschränken, die eine bestimmte Anzahl von Tagen zuvor gemeldet wurden, um Zeit für die Behebung neuer CVEs zu haben. 
* Anzahl der CVE mit mittlerem Schweregrad. Dabei werden die Ergebnisse eines Image-Scans (Registry-Scans) herangezogen und auf die Anzahl der mittleren Schweregrade (CVSS-Scores zwischen 4 und 6) abgestimmt. Es kann ein zusätzlicher Operator hinzugefügt werden, um CVEs einzuschränken, die eine bestimmte Anzahl von Tagen zuvor gemeldet wurden, um Zeit für die Behebung neuer CVEs zu haben. 
* CVE-Namen. Dies passt zu bestimmten CVE-Namen (z. B. CVE-2023-23914, 2023-23914, 23914 oder eindeutiger Text), wobei mehrere durch Kommas getrennt sind. 
* CVE-Wert. Konfigurieren Sie sowohl die Mindestpunktzahl als auch die Anzahl der CVEs, die der Mindest-CVSS-Punktzahl entsprechen oder diese überschreiten. 
* Umgebungsvariablen mit Geheimnissen. Wenn das Ergebnis des Deployment-Yaml- oder Image-Scans Umgebungsvariablen mit Geheimnissen enthält (oder nicht enthält). Siehe unten die Kriterien für den Abgleich von Geheimnissen. 
* Umgebungsvariablen. Verwenden Sie dies, um bestimmte Umgebungsvariablen in der Bereitstellungs-Yaml oder dem Image-Scan zu verlangen oder auszuschließen. 
* Bild. Abgleich auf bestimmte Bildnamen, in der Regel in Kombination mit anderen Kriterien für die Regel. 
* Verstöße gegen die Bildqualität. Stimmt überein, wenn die Überprüfung des Abbilds (der Registrierung) zu Verstößen gegen die Vorschriften führt. Einzelheiten zu den Konformitätsprüfungen finden Sie unter xref:compliance.adoc#_managing_compliance_and_cis_benchmarks[Konformität]. 
* Bild ohne OS-Informationen. Stimmt überein, wenn die Image-Überprüfung (Registrierung) dazu führt, dass die Betriebssysteminformationen nicht abgerufen werden können. 
* Bildregistrierung. Passt auf bestimmte Bildregistrierungsnamen. Wird in der Regel verwendet, um Verteilungen von bestimmten Registern einzuschränken oder Verteilungen nur von bestimmten zugelassenen Registern zu verlangen. Wird oft in Verbindung mit anderen Kriterien wie Namespaces verwendet. 
* Bild gescannt. Verlangt, dass ein Bild gescannt wird. Wird häufig verwendet, um sicherzustellen, dass alle Images gescannt werden, um zu gewährleisten, dass scanbasierte Kriterien wie hohe CVEs auf Bereitstellungen angewendet werden können. 
* Bild signiert. Verlangen Sie, dass ein Bild durch die Integration von Sigstore/Cosign signiert wird. Mit diesem Kriterium wird lediglich geprüft, ob das Scan-Ergebnis einen Prüfer enthält.
* Image Sigstore Überprüfer. Verlangt, dass ein Image von einem bestimmten Sigstore Root-of-Trust-Namen signiert wird, wie in Assets -> Sigstore Verifiers konfiguriert. Überprüft, ob die Prüfer im Scan-Ergebnis mit den Prüfern in der Regelkonfiguration übereinstimmen.
* Etiketten. Verlangt, dass eine oder mehrere Beschriftungen in der Bereitstellungs-Yaml oder in den Ergebnissen der Bildsuche vorhanden sind. 
* Module. Verlangt, dass bestimmte Module (Pakete, Bibliotheken) im Abbild vorhanden sind, oder schließt sie als Ergebnis der Abbild-(Registrierungs-)Prüfung aus. 
* Bände montieren. Wird in der Regel verwendet, um zu verhindern, dass bestimmte Volumes gemountet werden. 
* Namespace. Erlauben oder beschränken Sie Einsätze für bestimmte Namensräume. Unabhängig verwendet, aber oft mit anderen Kriterien kombiniert, um den Regelabgleich auf den Namensraum zu beschränken. 
* PSP Best Practice. Äquivalente Regeln für PSP (Anmerkung: PSP wurde vollständig aus Kubernetes 1.25+ entfernt, jedoch kann dieses {product-name} Äquivalent weiterhin in 1.25+ verwendet werden). Enthält Als privilegiert ausführen, Als root ausführen, PID-Namensräume des Hosts freigeben, IPC-Namensräume des Hosts freigeben, Netzwerk des Hosts freigeben, Privilegieneskalation zulassen. 
* Konfiguration der Ressourcenbegrenzung (RLC). Erfordert die Konfiguration von Ressourcenlimits für CPU Limit/Request, Memory Limit/Request und kann verlangen, dass der Operator > oder \<= eines konfigurierten Ressourcenwertes ist. 
* Als privilegiert ausführen. Wird in der Regel verwendet, um die Bereitstellung von privilegierten Containern einzuschränken oder zu blockieren. 
* Als root ausführen. Wird in der Regel verwendet, um den Einsatz von Containern, die als Root laufen, zu begrenzen oder zu blockieren. 
* Service Account Bound Hochrisiko-Rolle. Kann mit mehreren Kriterien übereinstimmen, die eine risikoreiche Dienstkontorolle darstellen könnten, einschließlich der Auflistung von Geheimnissen, der Durchführung von Operationen an Workloads, der Änderung von RBAC-Ressourcen, der Erstellung von Workload-Ressourcen und der Erlaubnis zur Ausführung in einem Container. 
* Gemeinsame Nutzung der IPC-Namensräume des Hosts. Passt auf IPC-Namensräume. 
* Share host's Network. Erlauben oder verbieten Sie Verteilungen, das Netzwerk des Hosts gemeinsam zu nutzen. 
* {blank}
** Gemeinsame Nutzung der PID-Namensräume des Hosts . Entspricht den PID-Namensräumen. 
* Benutzer. Erlauben oder verbieten Sie definierte https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-subjects[Benutzer, die von kubernetes] zur Laufzeit, sichtbar im userInfo-Feld. Anmerkung: Die yaml-Überprüfungsfunktion (Upload) ist nicht in der Lage, dies zu überprüfen, da sie zur Laufzeit gebunden ist. 
* Benutzergruppen. Erlauben oder verbieten Sie definierte https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-subjects[Benutzergruppen, die von kubernetes] zur Laufzeit, sichtbar im userInfo-Feld.  Anmerkung: Die yaml-Überprüfungsfunktion (Upload) ist nicht in der Lage, dies zu überprüfen, da sie zur Laufzeit gebunden ist. 
* Verstößt gegen die PSA-Richtlinien. Stimmt überein, wenn der Einsatz entweder gegen einen Restricted oder Baseline PSA https://kubernetes.io/docs/concepts/security/pod-security-standards/[Pod Security Standard] (entspricht den PSA-Definitionen in kubernetes 1.25+) verstößt 

=== Erkennung von Geheimnissen

Die Erkennung von Geheimnissen, z.B. in Umgebungsvariablen, wird mit der folgenden Regex abgeglichen:

[,shell]
----
Rule{Description: "Password.in.YML", 
Expression: `(?i)(password|passwd|api_token)\S{0,32}\s*:\s*(?-i)([0-9a-zA-Z\/+]{16,40}\b)`, ExprFName: `.*\.ya?ml`, Tags: []string{share.SecretProgram, "yaml", "yml"}, 
Suggestion: msgReferVender}, 
----

Auf der Seite **Risikoberichte** wird bei der Erkennung von Geheimnissen das Warnformat mit den allgemeinen Ausgabeinformationen "${variable}=${value}" angezeigt. In der nachstehenden Abbildung ist dies am Beispiel der Variablen "env1=AIDAJQ..." zu sehen.

image::https://github.com/user-attachments/assets/848533ed-70c1-494b-b7d5-6e9b60951f77[secret_detection]

Eine Liste der aufgedeckten Arten von Geheimnissen finden Sie xref:compliance.adoc#_secrets_auditing[hier] 

== Modi der Zulassungskontrolle

Es gibt zwei Modi, die {product-name} unterstützt: Überwachen und Schützen.

* Monitor: Es gibt eine Warnmeldung im Ereignisprotokoll, wenn eine Entscheidung verweigert wird. In diesem Fall kann der Cluster-Apiserver eine Ressource erfolgreich erstellen. Hinweis: Auch wenn die Regelaktion Verweigern lautet, wird im Überwachungsmodus nur eine Warnung ausgegeben.
* Schützen: Dies ist ein Inline-Schutzmodus. Sobald eine Entscheidung verweigert wird, kann die Cluster-Ressource nicht erfolgreich erstellt werden, und es wird ein Ereignis protokolliert.

== Regeln für die Zulassungskontrolle

Regeln können Zulassen (Whitelist) oder Verweigern (Blacklist) sein. Die Regeln werden in der angezeigten Reihenfolge, von oben nach unten, ausgewertet. Erlauben-Regeln werden zuerst ausgewertet und sind nützlich, um Ausnahmen (Teilmengen) von Verweigern-Regeln zu definieren. Wenn eine Ressourcenbereitstellung keinen Regeln entspricht, ist die Standardaktion "Bereitstellung zulassen".

Es gibt zwei vorkonfigurierte Regeln, die erlaubt sein sollten, um Kubernetes-Systemcontainer und {product-name} -Bereitstellungen zu ermöglichen.

Die Regeln der Zulassungskontrolle gelten für alle Ressourcen, die Pods erstellen (z. B. Bereitstellungen, Daemonsets, Replicasets usw.).

Bei Zulassungskontrollregeln ist die Reihenfolge der Übereinstimmung:

. Standard-Zulassungsregeln (z. B. System-Namensräume)
. Regeln für die föderale Zulassung (falls vorhanden)
. Verweigerungsregeln im Verbund (falls vorhanden)
. CRD angewandte Zulässigkeitsregeln (falls vorhanden)
. CRD angewandte Verweigerungsregeln (falls vorhanden)
. Benutzerdefinierte Zulässigkeitsregeln
. Benutzerdefinierte Verweigerungsregeln
. Die Anfrage zulassen, wenn die Anfrage keinem der oben genannten Kriterien der Regel entspricht

In jeder der Anpassungsphasen (1~7) spielt die Reihenfolge der Regeln keine Rolle. Solange die Anfrage den Kriterien einer Regel entspricht, wird die Aktion (zulassen oder ablehnen) durchgeführt und die Anfrage zugelassen oder abgelehnt.

== Verbund-Scanergebnisse in Zulassungskontrollregeln

Der primäre (Master-)Cluster kann eine als Verbundregistry bezeichnete Registry/Repo scannen. Die Scanergebnisse aus diesen Registern werden mit allen verwalteten (entfernten) Clustern synchronisiert. Dies ermöglicht die Anzeige der Scan-Ergebnisse in der Konsole des verwalteten Clusters sowie die Verwendung der Ergebnisse in den Regeln für die Zugangskontrolle des verwalteten Clusters. Die Register müssen nur einmal gescannt werden, anstatt von jedem Cluster, was die CPU/Speicher- und Netzwerkbandbreitennutzung reduziert. Weitere Informationen finden Sie im Abschnitt xref:multicluster.adoc[Multicluster].

== Konfigurieren der Sigstore/Cosign-Prüfer für die Anforderung der Bildsignierung

Bitte lesen Sie xref:sigstore.adoc[diesen Abschnitt] über die Konfiguration von Überprüfern.

== Fehlersuche

Wenn Fehler auftreten und Sie Zugriff auf den Master-Knoten haben, können Sie das kube-apiserver-Protokoll einsehen, um nach Webhook-Ereignissen zu suchen. Beispiele:

[,shell]
----
W0406 13:16:49.012234 1 admission.go:236] Failed calling webhook, failing open neuvector- validating-admission-webhook.neuvector.svc: failed calling admission webhook "neuvector-validating- admission-webhook.neuvector.svc": Post https://neuvector-svc-admission- webhook.neuvector.svc:443/v1/validate/1554514310852084622-1554514310852085078?timeout=30s: dial tcp: lookup neuvector-svc-admission-webhook.neuvector.svc on 8.8.8.8:53: no such host
----

Das obige Protokoll zeigt an, dass der Cluster kube-apiserver nicht in der Lage ist, die Anfrage an den Webhook {product-name} erfolgreich zu senden, da er den Namen neuvector-svc-admission-webhook.neuvector.svc nicht auflösen kann.

[,shell]
----
W0405 23:43:01.901346 1 admission.go:236] Failed calling webhook, failing open neuvector- validating-admission-webhook.neuvector.svc: failed calling admission webhook "neuvector-validating- admission-webhook.neuvector.svc": Post https://neuvector-svc-admission-webhook.neuvector.svc:443/v1/validate/1554500399933067744-1554500399933068005?timeout=30s: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)
----

Das obige Protokoll zeigt, dass der Cluster kube-apiserver nicht in der Lage ist, die Anfrage an den Webhook {product-name} erfolgreich zu senden, da er den Namen neuvector-svc-admission-webhook.neuvector.svc mit der falschen IP-Adresse auflöst. Es könnte auch auf ein Netzwerkverbindungs- oder Firewall-Problem zwischen dem API-Server und den Kontrollknoten hinweisen.

[,shell]
----
W0406 01:14:48.200513 1 admission.go:236] Failed calling webhook, failing open neuvector- validating-admission-webhook.xyz.svc: failed calling admission webhook "neuvector-validating- admission-webhook.xyz.svc": Post https://neuvector-svc-admission- webhook.xyz.svc:443/v1/validate/1554500399933067744-1554500399933068005?timeout=30s: x509: certificate is valid for neuvector-svc-admission-webhook.neuvector.svc, not neuvector-svc-admission- webhook.xyz.svc
----

Das obige Protokoll zeigt, dass der Cluster kube-apiserver die Anfrage an den {product-name} webhook erfolgreich senden kann, aber das Zertifikat in caBundle ist falsch.

[,shell]
----
W0404 23:27:15.270619 1 admission.go:236] Failed calling webhook, failing open neuvector- validating-admission-webhook.neuvector.svc: failed calling admission webhook "neuvector-validating- admission-webhook.neuvector.svc": Post https://neuvector-svc-admission- webhook.neuvector.svc:443/v1/validate/1554384671766437200-1554384671766437404?timeout=30s: service "neuvector-svc-admission-webhook" not found
----

Das obige Protokoll zeigt an, dass der Cluster kube-apiserver nicht in der Lage ist, die Anfrage an den {product-name} Webhook erfolgreich zu senden, da der neuvector-svc-admission-webhook Dienst nicht gefunden wird.

=== Überprüfung der Zulassungskontrollkonfigurationen

Überprüfen Sie zunächst Ihre Kubernetes- oder OpenShift-Version. Die Zulassungskontrolle wird in Kubernetes 1.9+ und OpenShift 3.9+ unterstützt.
Stellen Sie bei OpenShift sicher, dass Sie die master-config.yaml bearbeitet haben, um die MutatingAdmissionWebhook-Konfiguration hinzuzufügen und die Master-Api-Server neu zu starten.

==== Prüfen Sie die Clusterrole

[,shell]
----
kubectl get clusterrole neuvector-binding-admission -o json
----

Achten Sie darauf, dass die Verben enthalten:

[,json]
----
                "get",
                "list",
                "watch",
                "create",
                "update",
                "delete"
----

Dann prüfen Sie:

[,shell]
----
kubectl get clusterrole neuvector-binding-app -o json
----

Achten Sie darauf, dass die Verben enthalten:

[,json]
----
   "get",
   "list",
   "watch",
   "update"
----

Wenn die oben genannten Verben nicht aufgeführt sind, schlägt die Schaltfläche Test fehl.

==== Prüfen Sie die Clusterrollenbindung

[,shell]
----
kubectl get clusterrolebinding neuvector-binding-admission -o json
----

Stellen Sie sicher, dass der ServiceAccount richtig eingestellt ist:

[,json]
----
"subjects": [
        {
            "kind": "ServiceAccount",
            "name": "default",
            "namespace": "neuvector"
----

==== Überprüfen Sie die Webhook-Konfiguration

[,shell]
----
kubectl get ValidatingWebhookConfiguration --as system:serviceaccount:neuvector:default -o yaml > nv_validation.txt
----

Die Datei nv_validation.txt sollte einen ähnlichen Inhalt haben wie diese:

.Klicken Sie hier für Details
[%collapsible]
====
[,yaml]
----
apiVersion: v1
items:
- apiVersion: admissionregistration.k8s.io/v1beta1
  kind: ValidatingWebhookConfiguration
  metadata:
    creationTimestamp: "2019-09-11T00:51:08Z"
    generation: 1
    name: neuvector-validating-admission-webhook
    resourceVersion: "6859045"
    selfLink: /apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations/neuvector-validating-admission-webhook
    uid: 3e1793ed-d42e-11e9-ba43-000c290f9e12
  webhooks:
  - admissionReviewVersions:
    - v1beta1
    clientConfig:
      caBundle: {.........................}
      service:
        name: neuvector-svc-admission-webhook
        namespace: neuvector
        path: /v1/validate/{.........................}
    failurePolicy: Ignore
    name: neuvector-validating-admission-webhook.neuvector.svc
    namespaceSelector: {}
    rules:
    - apiGroups:
      - '*'
      apiVersions:
      - v1
      - v1beta1
      operations:
      - CREATE
      resources:
      - cronjobs
      - daemonsets
      - deployments
      - jobs
      - pods
      - replicasets
      - replicationcontrollers
      - services
      - statefulsets
      scope: '*'
    - apiGroups:
      - '*'
      apiVersions:
      - v1
      - v1beta1
      operations:
      - UPDATE
      resources:
      - daemonsets
      - deployments
      - replicationcontrollers
      - statefulsets
      - services
      scope: '*'
    - apiGroups:
      - '*'
      apiVersions:
      - v1
      - v1beta1
      operations:
      - DELETE
      resources:
      - daemonsets
      - deployments
      - services
      - statefulsets
      scope: '*'
    sideEffects: Unknown
    timeoutSeconds: 30
kind: List
metadata:
  resourceVersion: ""
  selfLink: ""
----
====

Wenn Sie einen Inhalt wie "Error from server ...." oder "... is forbidden" sehen, bedeutet dies, dass das NV-Controller-Dienstkonto keine Zugriffsrechte für die ValidatingWebhookConfiguration-Ressource hat. In diesem Fall bedeutet es normalerweise, dass die neuvector-binding-Zulassung clusterrole/clusterrolebinding ein Problem aufweist. Das Löschen und Neuanlegen von neuvector-binding-admission clusterrole/clusterrolebinding ist normalerweise die schnellste Lösung.

==== Testen Sie die Verbindungstaste der Zulassungskontrolle

In der {product-name} Konsole in der Policy -> Admission Control, gehen Sie zu More Operations -> Advanced Setting und klicken Sie auf die Schaltfläche "Test". {product-name} wird den Dienst neuvector-svc-admission-webhook ändern und sehen, ob unser Webhook-Server die Änderungsbenachrichtigung empfangen kann oder ob sie fehlschlägt.

. ausführen.
+
--
[,shell]
----
kubectl get svc neuvector-svc-admission-webhook -n neuvector -o yaml
----

Die Ausgabe sollte wie folgt aussehen:

[,yaml]
----
apiVersion: v1
   kind: Service
   metadata:
     annotations:
       ...................
     creationTimestamp: "2019-09-10T22:53:03Z"
     labels:
       echo-neuvector-svc-admission-webhook: "1568163072"      //===> from last test. could be missing if it's a fresh NV deployment
       tag-neuvector-svc-admission-webhook: "1568163072"       //===> from last test. could be missing if it's a fresh NV deployment
     name: neuvector-svc-admission-webhook
     namespace: neuvector
     ...................
   spec:
     clusterIP: 10.107.143.177
     ports:
     - name: admission-webhook
       port: 443
       protocol: TCP
       targetPort: 20443
     selector:
       app: neuvector-controller-pod
     sessionAffinity: None
     type: ClusterIP
   status:
     loadBalancer: {}
----
--
. Klicken Sie nun auf die Schaltfläche "Testen" in der erweiterten Einstellung der Zulassungskontrolle ->. Warten Sie, bis der Erfolg oder Misserfolg angezeigt wird.{product-name} wird das Tag-neuvector-svc-admission-webhook-Label des Dienstes neuvector-svc-admission-webhook implizit ändern.
. Warten Sie auf den internen Betrieb des Controllers. Wenn der {product-name} Webhook-Server eine Aktualisierungsanforderung von kube-apiserver über diese Dienständerung erhält, ändert {product-name} das echo-neuvector-svc-admission-webhook-Label des Dienstes neuvector-svc-admission-webhook auf denselben Wert wie das tag-neuvector-svc-admission-webhook-Label.
. ausführen.
+
--
[,shell]
----
kubectl get svc neuvector-svc-admission-webhook -n neuvector -o yaml
----

Die Ausgabe sollte wie folgt aussehen

[,yaml]
----
   apiVersion: v1
   kind: Service
   metadata:
     annotations:
       .............
     creationTimestamp: "2019-09-10T22:53:03Z"
     labels:
       echo-neuvector-svc-admission-webhook: "1568225712"      //===> changed in step 3-3 after receiving request from kube-apiserver
       tag-neuvector-svc-admission-webhook: "1568225712"       //===> changed in step 3-2 because of UI operation
     name: neuvector-svc-admission-webhook
     namespace: neuvector
     .................
   spec:
     clusterIP: 10.107.143.177
     ports:
     - name: admission-webhook
       port: 443
       protocol: TCP
       targetPort: 20443
     selector:
       app: neuvector-controller-pod
     sessionAffinity: None
     type: ClusterIP
   status:
     loadBalancer: {}
----
--
. Wenn sich nach dem Test der Wert des Labels tag-neuvector-svc-admission-webhook nicht ändert, bedeutet dies, dass der Controller-Dienst den Dienst neuvector-svc-admission-webhook nicht aktualisieren kann. Prüfen Sie, ob neuvector-binding-app clusterrole/clusterrolebinding korrekt konfiguriert sind.
. Wenn sich nach dem Test der Wert des Labels tag-neuvector-svc-admission-webhook ändert, nicht aber der Wert des Labels echo-neuvector-svc-admission-webhook, bedeutet dies, dass der Webhook-Server die Anfrage vom kube-apiserver nicht erhalten hat. Die Anfrage des kub-apiserver kann den {product-name} webhook server nicht erreichen. Die Ursache hierfür könnten Probleme mit der Netzwerkkonnektivität, Firewalls, die die Anfrage blockieren (über den Standard-Port 443), die Auflösung der falschen IP-Adresse für den Controller oder andere Gründe sein.
