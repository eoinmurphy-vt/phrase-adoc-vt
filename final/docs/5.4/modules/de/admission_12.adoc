= Zugangssteuerungen
:revdate: 2025-06-25
:page-revdate: {revdate}
:page-opendocs-origin: /05.policy/03.admission/03.admission.md
:page-opendocs-slug:  /richtlinie/zugang

== Steuerung von Bildern / Container-Bereitstellungen

Mit der Integration der Zugangssteuerung in Orchestrierungsplattformen wie Kubernetes und OpenShift spielt {product-name} eine wichtige Rolle innerhalb der Bereitstellungspipeline der Orchestrierungsplattform. Wann immer eine Cluster-Ressource wie Deployment erstellt wird, wird die Anfrage vom Cluster-APIServer an einen der {product-name} Controller weitergeleitet, um zu bestimmen, ob sie basierend auf den benutzerdefinierten Regeln der Zugangssteuerung erlaubt oder abgelehnt werden sollte, bevor die Cluster-Ressource erstellt wird. Die politische Entscheidung, die {product-name} trifft, wird an den Cluster-APIServer zur Durchsetzung zurückgegeben.

Dieses Feature wird in Kubernetes 1.9+ und Openshift 3.9+ unterstützt. Bevor Sie die Funktion der Zugangssteuerung in {product-name} verwenden, während es möglich ist, die Zugangssteuerung über das `--admission-control` Argument, das an den Cluster-APIServer übergeben wird, einzurichten, wird empfohlen, die dynamische Zugangssteuerung zu verwenden. Bitte sehen Sie sich die Abschnitte zu Kubernetes und Openshift unten für die Konfiguration an.

=== Kubernetes

Die ValidatingAdmissionWebhook- und MutatingAdmissionWebhook-Plugins sind standardmäßig aktiviert.

Überprüfen Sie, ob admissionregistration.kubernetes.io/v1beta1 aktiviert ist

[,bash]
----
kubectl api-versions | grep admissionregistration
admissionregistration.k8s.io/v1beta1
----

=== Openshift

Die ValidatingAdmissionWebhook- und MutatingAdmissionWebhook-Plugins sind standardmäßig NICHT aktiviert. Bitte sehen Sie sich die Beispiele in den OpenShift-Bereitstellungsabschnitten für Anweisungen an, wie Sie diese aktivieren können. Ein Neustart der OpenShift-API- und Controller-Dienste ist erforderlich.

Überprüfen Sie, ob admissionregistration.kubernetes.io/v1beta1 aktiviert ist

[,bash]
----
oc api-versions | grep admissionregistration
admissionregistration.k8s.io/v1beta1
----

== Aktivierung der Zugangssteuerung (Webhook) in {product-name}

Die Funktion der Zugangssteuerung ist standardmäßig deaktiviert. Bitte gehen Sie zur Richtlinie -> Zugangssteuerungsseite, um sie in der {product-name} Konsole zu aktivieren.

image:ac_enable.png[Aktivieren]

Sobald die Funktion zur Zulassungssteuerung erfolgreich aktiviert ist, wird die folgende ValidatingWebhookConfiguration-Ressource automatisch erstellt. Um dies zu überprüfen:

[,shell]
----
kubectl get ValidatingWebhookConfiguration neuvector-validating-admission-webhook
----

Beispielausgabe:

[,shell]
----
NAME                                     CREATED AT
neuvector-validating-admission-webhook   2019-03-28T00:05:09Z
----

Die wichtigsten Informationen in der ValidatingWebhookConfiguration-Ressource für {product-name} sind Clusterressourcen. Derzeit wird, sobald eine Clusterressource wie Deployment {product-name} registriert ist, die Anfrage vom Orchestrierungsplattform-ApiServer an einen der {product-name} Controller gesendet, um zu bestimmen, ob sie basierend auf den benutzerdefinierten Regeln in der {product-name} Richtlinie -> Zulassungssteuerungsseite erlaubt oder abgelehnt werden soll.

Wenn die Bereitstellung der Ressource abgelehnt wird, wird ein Ereignis in den Benachrichtigungen protokolliert.

Um die Kubernetes-Verbindung für den Clientmodus-Zugriff zu testen, gehen Sie zu den erweiterten Einstellungen.

image:ac_advanced.png[Erweitert]

In speziellen Fällen kann die URL-Zugriffsmethode unter Verwendung des NodePort-Dienstes erforderlich sein.

== Zulassungssteuerungsereignisse/Benachrichtigungen

Alle Zulassungssteuerungsereignisse für erlaubte und abgelehnte Ereignisse finden Sie im Menü Benachrichtigungen -> Sicherheitsrisiken.

== Kriterien für die Zulassungssteuerung

{product-name} unterstützt viele Kriterien zur Erstellung einer Zulassungssteuerungsregel. Diese umfassen CVE-Hochzählungen, CVE-Namen, Bildetiketten, imageScanned, Namespace, Benutzer, runAsRoot usw. Es gibt zwei mögliche Quellen für die Kriterienbewertung: Bildscans und Bereitstellungs-Yaml-Dateiscans. Wenn ein Kriterium einen Bildscan erfordert, werden die Scanergebnisse aus der Registry-Überprüfung verwendet. Wenn das Bild nicht gescannt wurde, wird die Zulassungssteuerungsregel nicht angewendet. Wenn ein Kriterium das Scannen des Bereitstellungs-Yaml erfordert, wird es aus der Kubernetes-Bereitstellung bewertet. Einige Kriterien verwenden die Ergebnisse entweder aus einem Bildscan ODER einem Bereitstellungs-Yaml-Scan.

* CVE-Punktzahl ist ein Beispiel für ein Kriterium, das einen Bildscan erfordert.
* Umgebungsvariablen mit Geheimnissen sind ein Beispiel für ein Kriterium, das den Deployment-YAML-Scan verwendet.
* Labels und Umgebungsvariablen sind Beispiele für Kriterien, die sowohl die Ergebnisse des Bild- als auch des Deployment-YAML-Scans (logisches ODER) verwenden, um Übereinstimmungen zu bestimmen.

image:adm_control_criteria.png[Criteria]

Nachdem das Kriterium ausgewählt wurde, werden die möglichen Operatoren angezeigt. Klicken Sie auf die '`+`'-Schaltfläche, um jedes Kriterium hinzuzufügen.

*Verwendung mehrerer Kriterien in einer einzelnen Regel*
Die Übereinstimmungslogik für mehrere Kriterien in einer Zulassungssteuerungsregel lautet:

* Für verschiedene Kriterienarten innerhalb einer einzelnen Regel 'und' anwenden
* Für mehrere Kriterien desselben Typs (z. B. mehrere Namespaces, Registries, Bilder),
** Wenden Sie 'und' für alle negativen Übereinstimmungen ("enthält nicht", "ist nicht eines von") an, bis die erste positive Übereinstimmung gefunden wird;
** Nach der ersten positiven Übereinstimmung 'oder' anwenden

=== Beispiel mit Übereinstimmung eines Pod-Labels

[,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: iperfserver
  namespace: neuvector-1
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: iperfserver
----

Die Regel zur Übereinstimmung wäre:

image:ac_label.png[Zulassung]

=== Beispiel mit Übereinstimmung von Umgebungsvariablen mit Geheimnissen

[,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: iperfserver
  namespace: neuvector-1
  labels:
    name: iperfserver
spec:
  selector:
    matchLabels:
      name: iperfserver
  replicas: 1
  template:
    metadata:
      labels:
        name: iperfserver
    spec:
      containers:
        - name: iperfserver
          image: nvlab/iperf
          env:
            - name: env1
              value: AIDAJQABLZS4A3QDU576
            - name: env2
              valueFrom:
                fieldRef:
                  fieldPath: status.podIP
            - name: env5
              value: AIDAJQABLZS4A3QDU57E
          command:
            - iperf
            - -s
            - -p
            - "6068"
      nodeSelector:
        nvallinone: "true"
      restartPolicy: Always
----

Die Übereinstimmungsregel wäre:

image:ac_environment.png[Zulassung]

=== Kriterien im Zusammenhang mit Scan-Ergebnissen

Die folgenden Kriterien stehen im Zusammenhang mit den Ergebnissen in {product-name} Assets > Registry-Scan-Seite:

Bild, imageScanned, cveHighCount, cveMediumCount, Verstöße gegen die Bildkonformität, cveNames und andere.

Bevor {product-name} die Übereinstimmung mit den Zulassungssteuerungsregeln durchführt, ruft {product-name} die Bildinformationen (zum Beispiel 10.1.127.3:5000/neuvector/toolbox/iperf:latest) vom Cluster-APIServer ab
(Bitte beachten Sie den Abschnitt "Anfrage vom APIServer" unten). Das Bild setzt sich aus dem Registry-Server (`https://10.1.127.3:5000`), dem Repository (neuvector/toolbox/iperf) und dem Tag (latest) zusammen.

{product-name} verwendet diese Informationen, um die Ergebnisse auf der Seite {product-name} Assets -> Registry-Scan zuzuordnen und sammelt die entsprechenden Informationen wie cve-Name, cve hohe oder mittlere Anzahl usw. Bildkonformitätsverletzungen werden als jedes Bild betrachtet, das Geheimnisse oder setuid/setgid-Verletzungen aufweist.
Wenn Benutzer das Bild aus dem Docker-Registry verwenden, um eine Cluster-Ressource zu erstellen, sind normalerweise die Informationen des Registry-Servers leer oder docker.io, und derzeit verwendet {product-name} die folgenden fest codierten Registry-Server, um das Ergebnis des Registry-Scans anstelle des leeren oder docker.io-Strings abzugleichen. Natürlich kann {product-name} die Ergebnisse des Registry-Scans nicht erfolgreich abrufen, wenn es mehr als die folgenden unterstützten Docker-Registry-Server gibt, die auf der Seite des Registry-Scans definiert sind.

Wenn Benutzer das integrierte Bild wie Alpine oder Ubuntu aus dem Docker-Registry verwenden, gibt es einen versteckten Organisationsnamen namens Bibliothek. Wenn Sie sich die Ergebnisse für das integrierte Docker-Bild auf der Seite {product-name} Assets > Registry-Scan ansehen, wird der Repository-Name library/alpine oder library/ubuntu sein. Derzeit geht {product-name} davon aus, dass es nur einen versteckten Bibliotheksorganisationsnamen im Docker-Registry gibt. Wenn es mehr als einen gibt, kann {product-name} die Ergebnisse des Registry-Scans ebenfalls nicht erfolgreich abrufen.
Die oben genannte Einschränkung könnte auch auf andere Arten von Docker-Registry-Servern zutreffen, falls vorhanden.

=== Benutzerdefinierte Kriterienregeln erstellen

Benutzer können ein angepasstes Kriterium erstellen, das verwendet wird, um Bereitstellungen basierend auf gemeinsamen Objekten im Bild-YAML (bei der Bereitstellung gescannt) zuzulassen oder zu blockieren. Wählen Sie das zu verwendende Objekt aus, z. B. imagePullSecrets und den übereinstimmenden Wert, z. B. exists. Es wird auch empfohlen, zusätzliche Kriterien zu verwenden, um die Regel weiter zu zielen, wie z. B. Namespace, PSP/PSA, CVE-Bedingungen usw.

image:custom_admission.png[admission]

==== Kriterienerklärungen

Kriterien mit einem Festplattensymbol erfordern, dass das Bild gescannt wird (siehe Registry-Scanning), und Kriterien mit einem Dateisymbol scannen das Bereitstellungs-YAML. Wenn beide Symbole aufgeführt sind, erfolgt die Übereinstimmung für entweder (ODER). Wenn ein Kriterium einen Bildscan erfordert, das Bild jedoch NICHT gescannt wird, wird dieser Teil der Regel ignoriert (d. h. die Regel wird umgangen, oder wenn das Bereitstellungs-YAML ebenfalls aufgeführt ist, wird nur das Bereitstellungs-YAML verwendet, um Übereinstimmungen zu erzielen). Um zu verhindern, dass nicht gescannte Bilder Regeln umgehen, siehe das untenstehende Kriterium "Bild gescannt". 

* Benutzerdefiniertes Kriterium hinzufügen. Wählen Sie das Objekt aus dem Dropdown-Menü aus. Alle benutzerdefinierten Kriterien unterstützen die Operatoren existiert und existiert nicht. Für diejenigen, die Werte zulassen, können zusätzliche Operatoren und der Wert eingegeben werden. Werte können statisch, durch Kommas getrennt und Wildcards enthalten. 
* Erlauben Sie Privilegieneskalation. Wenn der Container Privilegieneskalationen zulässt, kann dies durch Festlegen von Verweigern als Aktion blockiert werden. 
* Anzahl der hochgradigen CVEs. Dies nimmt die Ergebnisse eines Bild- (Registry-) Scans und vergleicht sie mit der Anzahl der hochgradigen (CVSS-Werte von 7 oder höher). Zusätzliche Operatoren können hinzugefügt werden, um auf CVEs zu beschränken, die eine bestimmte Anzahl von Tagen zuvor gemeldet wurden, um Zeit für die Behebung neuer CVEs zu geben. 
* Anzahl der hochgradigen CVEs mit Fix. Dies nimmt die Ergebnisse eines Bild- (Registry-) Scans und vergleicht sie mit hochgradigen (CVSS-Werten von 7 oder höher), UND wenn ein Fix für die CVE verfügbar ist. Wählen Sie dies aus, wenn Sie nur planen, die Bereitstellung von hochgradigen CVEs zu blockieren, wenn ein Fix hätte angewendet werden sollen. Zusätzliche Operatoren können hinzugefügt werden, um auf CVEs zu beschränken, die eine bestimmte Anzahl von Tagen zuvor gemeldet wurden, um Zeit für die Behebung neuer CVEs zu geben. 
* Anzahl der mittelgradigen CVEs. Dies nimmt die Ergebnisse eines Bild- (Registry-) Scans und vergleicht sie mit der Anzahl der mittelgradigen (CVSS-Werte zwischen 4 und 6). Zusätzliche Operatoren können hinzugefügt werden, um auf CVEs zu beschränken, die eine bestimmte Anzahl von Tagen zuvor gemeldet wurden, um Zeit für die Behebung neuer CVEs zu geben. 
* CVE-Namen. Dies vergleicht spezifische CVE-Namen (z. B. CVE-2023-23914, 2023-23914, 23914 oder einzigartiger Text), wobei mehrere durch Kommas getrennt sind. 
* CVE-Score. Konfigurieren Sie sowohl den Mindestwert als auch die Anzahl der CVEs, die den Mindest-CVSS-Wert erreichen oder überschreiten. 
* Umgebungsvariablen mit Geheimnissen. Wenn die Bereitstellungs-YAML oder das Ergebnis des Bildscans Umgebungsvariablen mit Geheimnissen enthält (oder nicht enthält). Siehe die Kriterien für übereinstimmende Geheimnisse unten. 
* Umgebungsvariablen. Verwenden Sie dies, um bestimmte Umgebungsvariablen in der Bereitstellungs-YAML oder im Bildscan zu verlangen oder auszuschließen. 
* Bild. Übereinstimmung mit bestimmten Bildnamen, typischerweise kombiniert mit anderen Kriterien für die Regel. 
* Verstöße gegen die Bildkonformität. Übereinstimmungen, wenn der Bild- (Registry-)Scan zu irgendwelchen Konformitätsverstößen führt. Siehe xref:compliance.adoc#_managing_compliance_and_cis_benchmarks[Compliance] für Details zu den Konformitätsprüfungen. 
* Bild ohne OS-Informationen. Übereinstimmungen, wenn der Bild- (Registry-)Scan zu der Unfähigkeit führt, OS-Informationen abzurufen. 
* Bild-Registry. Übereinstimmungen mit bestimmten Bild-Registry-Namen. Typischerweise verwendet, um Bereitstellungen von bestimmten Registries einzuschränken oder Bereitstellungen nur von bestimmten genehmigten Registries zu verlangen. Oft zusammen mit anderen Kriterien wie Namespaces verwendet. 
* Bild gescannt. Verlangen, dass ein Bild gescannt wird. Oft verwendet, um sicherzustellen, dass alle Bilder gescannt werden, um sicherzustellen, dass scanbasierte Kriterien wie hohe CVEs auf Bereitstellungen angewendet werden können. 
* Bild signiert. Verlangen, dass ein Bild durch die Integration von Sigstore/Cosign signiert wird. Dieses Kriterium überprüft einfach, ob es einen Verifier im Scan-Ergebnis gibt.
* Bild Sigstore Prüfer. Erfordert, dass ein Bild von einem bestimmten Sigstore Root-of-Trust-Namen signiert wird, wie in Assets -> Sigstore Prüfer konfiguriert. Überprüft, ob die Prüfer im Scan-Ergebnis mit den Prüfern in der Regelkonfiguration übereinstimmen.
* Labels. Erfordert, dass ein oder mehrere Labels in der Bereitstellungs-YAML oder den Ergebnissen des Bildscans vorhanden sind. 
* Module. Erfordert oder schließt bestimmte Module (Pakete, Bibliotheken) aus, die im Bild als Ergebnis des Bild- (Registry-) Scans vorhanden sein sollen. 
* Volumes einhängen. Typischerweise verwendet, um zu verhindern, dass bestimmte Volumes eingehängt werden. 
* Namespace. Erlaubt oder schränkt Bereitstellungen für bestimmte Namespace(s) ein. Wird unabhängig verwendet, aber oft mit anderen Kriterien kombiniert, um das Regel-Matching auf den Namespace zu beschränken. 
* PSP Best Practice. Entsprechende Regeln für PSP (Hinweis: PSP wurde in Kubernetes 1.25+ vollständig entfernt, jedoch kann dieses {product-name} Äquivalent weiterhin in 1.25+ verwendet werden). Beinhaltet Ausführen als privilegiert, Ausführen als Root, Teilen der PID-Namespaces des Hosts, Teilen der IPC-Namespaces des Hosts, Teilen des Netzwerks des Hosts, Erlauben von Privilegieneskalation. 
* Ressourcenlimit-Konfiguration (RLC). Erfordert, dass Ressourcenlimits für CPU-Limit/Anforderung, Speicherlimit/Anforderung konfiguriert werden, und kann erfordern, dass der Betreiber > oder \<= einem konfigurierten Ressourcenwert ist. 
* Als privilegiert ausführen. Typischerweise verwendet, um Bereitstellungen von privilegierten Containern zu begrenzen oder zu blockieren. 
* Als Root ausführen. Typischerweise verwendet, um Bereitstellungen von Containern, die als Root ausgeführt werden, zu begrenzen oder zu blockieren. 
* Servicekonto gebundene Hochrisiko-Rolle. Kann auf mehrere Kriterien übereinstimmen, die eine hochriskante Servicekonto-Rolle darstellen könnten, einschließlich des Auflistens von Geheimnissen, der Durchführung von Operationen an Workloads, der Modifikation von RBAC-Ressourcen, der Erstellung von Workload-Ressourcen und der Erlaubnis, in einen Container zu exec. 
* IPC-Namensräume des Hosts teilen. Stimmt mit IPC-Namensräumen überein. 
* Netzwerk des Hosts teilen. Erlauben oder verbieten Sie Bereitstellungen, das Netzwerk des Hosts zu teilen. 
* {blank}
** PID-Namensräume des Hosts teilen. Stimmt mit PID-Namensräumen überein. 
* Benutzer. Erlauben oder verbieten Sie definierte https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-subjects[Benutzer, die durch Kubernetes gebunden sind] zur Laufzeit, sichtbar im userInfo-Feld. Hinweis: Die YAML (Upload)-Auditierungsfunktion kann dies nicht überprüfen, da sie zur Laufzeit gebunden ist. 
* Benutzergruppen. Erlauben oder verbieten Sie definierte https://kubernetes.io/docs/reference/access-authn-authz/rbac/#referring-to-subjects[Benutzergruppen, die durch Kubernetes gebunden sind] zur Laufzeit, sichtbar im userInfo-Feld.  Hinweis: Die YAML (Upload)-Auditierungsfunktion kann dies nicht überprüfen, da sie zur Laufzeit gebunden ist. 
* Verstößt gegen die PSA-Richtlinie. Stimmt zu, wenn die Bereitstellung entweder eine eingeschränkte oder grundlegende PSA https://kubernetes.io/docs/concepts/security/pod-security-standards/[Pod-Sicherheitsstandard] verletzt (entspricht den PSA-Definitionen in Kubernetes 1.25+). 

=== Geheimnisdetektion

Erkennung von Geheimnissen, zum Beispiel in Umgebungsvariablen, wird mit dem folgenden Regex übereingestimmt:

[,shell]
----
Rule{Description: "Password.in.YML", 
Expression: `(?i)(password|passwd|api_token)\S{0,32}\s*:\s*(?-i)([0-9a-zA-Z\/+]{16,40}\b)`, ExprFName: `.*\.ya?ml`, Tags: []string{share.SecretProgram, "yaml", "yml"}, 
Suggestion: msgReferVender}, 
----

Auf der **Risikoberichte** Seite wird, wenn Geheimnisse erkannt werden, das Alarmformat mit allgemeinen Ausgabedaten angezeigt, die als "${variable}=${value}" angezeigt werden. Als Beispiel im Bild unten kann dies mit der Variablen "env1=AIDAJQ..." gesehen werden.

image::https://github.com/user-attachments/assets/848533ed-70c1-494b-b7d5-6e9b60951f77[secret_detection]

Eine Liste der erkannten Geheimnistypen finden Sie xref:compliance.adoc#_secrets_auditing[hier]. 

== Zugangssteuerungsmodi

Es gibt zwei Modi, die {product-name} unterstützt - Überwachen und Schützen.

* Überwachen: Es gibt eine Alarmnachricht im Ereignisprotokoll, wenn eine Entscheidung abgelehnt wird. In diesem Fall darf der Cluster-Api-Server erfolgreich eine Ressource erstellen. Hinweis: Selbst wenn die Regelaktion Ablehnen ist, wird im Überwachungsmodus nur gewarnt.
* Schützen: Dies ist ein Inline-Schutzmodus. Sobald eine Entscheidung abgelehnt wird, kann die Clusterressource nicht erfolgreich erstellt werden, und ein Ereignis wird protokolliert.

== Zugangssteuerungsregeln

Regeln können Erlauben (Whitelist) oder Ablehnen (Blacklist) Regeln sein. Regeln werden in der angezeigten Reihenfolge von oben nach unten bewertet. Erlauben-Regeln werden zuerst bewertet und sind nützlich, um Ausnahmen (Teilmenge) zu Ablehnen-Regeln zu definieren. Wenn ein Ressourcenbereitstellung keine Regeln erfüllt, ist die Standardaktion, die Bereitstellung zu erlauben.

Es gibt zwei vorkonfigurierte Regeln, die erlaubt sein sollten, um Kubernetes-Systemcontainer und {product-name} Bereitstellungen zu aktivieren.

Zugangssteuerungsregeln gelten für alle Ressourcen, die Pods erstellen (z. B. Bereitstellungen, Daemonsets, Replicasets usw.).

Für Zugangssteuerungsregeln ist die Übereinstimmungsreihenfolge:

. Standarderlauben-Regeln (z. B. Systemnamespaces)
. Föderierte Erlauben-Regeln (falls diese existieren)
. Föderierte Verweigern-Regeln (falls diese existieren)
. CRD angewandte Erlauben-Regeln (falls diese existieren)
. CRD angewandte Verweigern-Regeln (falls diese existieren)
. Benutzerdefinierte Erlauben-Regeln
. Benutzerdefinierte Verweigern-Regeln
. Erlaube die Anfrage, wenn die Anfrage nicht mit den oben genannten Kriterien einer Regel übereinstimmt

In jeder der Übereinstimmungsphasen (1~7) spielt die Reihenfolge der Regeln keine Rolle. Solange die Anfrage mit den Kriterien einer Regel übereinstimmt, wird die Aktion (erlauben oder verweigern) ausgeführt und die Anfrage wird erlaubt oder verweigert.

== Föderierte Scan-Ergebnisse in Zulassungssteuerungsregeln

Der primäre (Master-)Cluster kann ein als föderiertes Registry bezeichnetes Registry/Repo scannen. Die Scan-Ergebnisse dieser Registries werden mit allen verwalteten (remote) Clustern synchronisiert. Dies ermöglicht die Anzeige der Scan-Ergebnisse in der Konsole des verwalteten Clusters sowie die Verwendung der Ergebnisse in den Zulassungssteuerungsregeln des verwalteten Clusters. Registries müssen nur einmal gescannt werden, anstatt von jedem Cluster, wodurch CPU-/Speicher- und Netzwerkbandbreitennutzung reduziert wird. Siehe den xref:multicluster.adoc[Multi-Cluster] Abschnitt für weitere Details.

== Konfiguration von Sigstore/Cosign-Überprüfern für die Anforderung von Bildsignierungen

Bitte siehe xref:sigstore.adoc[diesen Abschnitt] zur Konfiguration von Überprüfern.

== Fehlerbehebung

Wenn Fehler auftreten und Sie Zugriff auf den Master-Knoten haben, können Sie das kube-apiserver-Protokoll überprüfen, um nach Ereignissen des Zulassungs-Webhooks zu suchen. Beispiele:

[,shell]
----
W0406 13:16:49.012234 1 admission.go:236] Failed calling webhook, failing open neuvector- validating-admission-webhook.neuvector.svc: failed calling admission webhook "neuvector-validating- admission-webhook.neuvector.svc": Post https://neuvector-svc-admission- webhook.neuvector.svc:443/v1/validate/1554514310852084622-1554514310852085078?timeout=30s: dial tcp: lookup neuvector-svc-admission-webhook.neuvector.svc on 8.8.8.8:53: no such host
----

Das obige Protokoll zeigt an, dass der Cluster kube-apiserver die Anfrage an das {product-name} Webhook nicht erfolgreich senden kann, da er den Namen neuvector-svc-admission-webhook.neuvector.svc nicht auflösen kann.

[,shell]
----
W0405 23:43:01.901346 1 admission.go:236] Failed calling webhook, failing open neuvector- validating-admission-webhook.neuvector.svc: failed calling admission webhook "neuvector-validating- admission-webhook.neuvector.svc": Post https://neuvector-svc-admission-webhook.neuvector.svc:443/v1/validate/1554500399933067744-1554500399933068005?timeout=30s: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)
----

Das obige Protokoll zeigt an, dass der Cluster kube-apiserver die Anfrage an das {product-name} Webhook nicht erfolgreich senden kann, da er den Namen neuvector-svc-admission-webhook.neuvector.svc mit der falschen IP-Adresse auflöst. Es könnte auch auf ein Netzwerkverbindungs- oder Firewallproblem zwischen dem API-Server und den Controller-Knoten hinweisen.

[,shell]
----
W0406 01:14:48.200513 1 admission.go:236] Failed calling webhook, failing open neuvector- validating-admission-webhook.xyz.svc: failed calling admission webhook "neuvector-validating- admission-webhook.xyz.svc": Post https://neuvector-svc-admission- webhook.xyz.svc:443/v1/validate/1554500399933067744-1554500399933068005?timeout=30s: x509: certificate is valid for neuvector-svc-admission-webhook.neuvector.svc, not neuvector-svc-admission- webhook.xyz.svc
----

Das obige Protokoll zeigt an, dass der Cluster kube-apiserver die Anfrage an das {product-name} Webhook erfolgreich senden kann, aber das Zertifikat im caBundle falsch ist.

[,shell]
----
W0404 23:27:15.270619 1 admission.go:236] Failed calling webhook, failing open neuvector- validating-admission-webhook.neuvector.svc: failed calling admission webhook "neuvector-validating- admission-webhook.neuvector.svc": Post https://neuvector-svc-admission- webhook.neuvector.svc:443/v1/validate/1554384671766437200-1554384671766437404?timeout=30s: service "neuvector-svc-admission-webhook" not found
----

Das obige Protokoll zeigt an, dass der Cluster kube-apiserver die Anfrage an das {product-name} Webhook nicht erfolgreich senden kann, da der Dienst neuvector-svc-admission-webhook nicht gefunden wurde.

=== Überprüfen Sie die Konfigurationen der Zulassungskontrolle

Überprüfen Sie zunächst Ihre Kubernetes- oder OpenShift-Version. Die Zulassungskontrolle wird in Kubernetes 1.9+ und OpenShift 3.9+ unterstützt.
Für OpenShift stellen Sie sicher, dass Sie die master-config.yaml bearbeitet haben, um die MutatingAdmissionWebhook-Konfiguration hinzuzufügen, und die Master-API-Server neu gestartet haben.

==== Überprüfen Sie die Clusterrolle

[,shell]
----
kubectl get clusterrole neuvector-binding-admission -o json
----

Stellen Sie sicher, dass die Verben Folgendes enthalten:

[,json]
----
                "get",
                "list",
                "watch",
                "create",
                "update",
                "delete"
----

Überprüfen Sie dann:

[,shell]
----
kubectl get clusterrole neuvector-binding-app -o json
----

Stellen Sie sicher, dass die Verben Folgendes enthalten:

[,json]
----
   "get",
   "list",
   "watch",
   "update"
----

Wenn die obigen Verben nicht aufgeführt sind, schlägt die Testtaste fehl.

==== Überprüfen Sie die Clusterrollenbindung

[,shell]
----
kubectl get clusterrolebinding neuvector-binding-admission -o json
----

Stellen Sie sicher, dass das Servicekonto richtig eingestellt ist:

[,json]
----
"subjects": [
        {
            "kind": "ServiceAccount",
            "name": "default",
            "namespace": "neuvector"
----

==== Überprüfen Sie die Webhook-Konfiguration

[,shell]
----
kubectl get ValidatingWebhookConfiguration --as system:serviceaccount:neuvector:default -o yaml > nv_validation.txt
----

Die nv_validation.txt sollte einen ähnlichen Inhalt haben wie:

.Klicken Sie hier für Details
[%collapsible]
====
[,yaml]
----
apiVersion: v1
items:
- apiVersion: admissionregistration.k8s.io/v1beta1
  kind: ValidatingWebhookConfiguration
  metadata:
    creationTimestamp: "2019-09-11T00:51:08Z"
    generation: 1
    name: neuvector-validating-admission-webhook
    resourceVersion: "6859045"
    selfLink: /apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations/neuvector-validating-admission-webhook
    uid: 3e1793ed-d42e-11e9-ba43-000c290f9e12
  webhooks:
  - admissionReviewVersions:
    - v1beta1
    clientConfig:
      caBundle: {.........................}
      service:
        name: neuvector-svc-admission-webhook
        namespace: neuvector
        path: /v1/validate/{.........................}
    failurePolicy: Ignore
    name: neuvector-validating-admission-webhook.neuvector.svc
    namespaceSelector: {}
    rules:
    - apiGroups:
      - '*'
      apiVersions:
      - v1
      - v1beta1
      operations:
      - CREATE
      resources:
      - cronjobs
      - daemonsets
      - deployments
      - jobs
      - pods
      - replicasets
      - replicationcontrollers
      - services
      - statefulsets
      scope: '*'
    - apiGroups:
      - '*'
      apiVersions:
      - v1
      - v1beta1
      operations:
      - UPDATE
      resources:
      - daemonsets
      - deployments
      - replicationcontrollers
      - statefulsets
      - services
      scope: '*'
    - apiGroups:
      - '*'
      apiVersions:
      - v1
      - v1beta1
      operations:
      - DELETE
      resources:
      - daemonsets
      - deployments
      - services
      - statefulsets
      scope: '*'
    sideEffects: Unknown
    timeoutSeconds: 30
kind: List
metadata:
  resourceVersion: ""
  selfLink: ""
----
====

Wenn Sie Inhalte wie "Fehler vom Server ...." oder "... ist verboten" sehen, bedeutet dies, dass das NV-Controller-Servicekonto keine Zugriffsrechte für die ValidatingWebhookConfiguration-Ressource hat. In diesem Fall bedeutet es normalerweise, dass die neuvector-binding-admission Clusterrolle/Clusterrollenbindung ein Problem hat. Das Löschen und Neuerstellen der neuvector-binding-admission Clusterrolle/Clusterrollenbindung ist normalerweise die schnellste Lösung.

==== Testen Sie die Schaltfläche für die Verbindungssteuerung der Zulassung.

Gehen Sie in der {product-name} Konsole in der Richtlinie -> zur Zulassungssteuerung zu Mehr Operationen -> Erweiterte Einstellungen und klicken Sie auf die Schaltfläche "Test". {product-name} wird den Dienst neuvector-svc-admission-webhook ändern und sehen, ob unser Webhook-Server die Änderungsbenachrichtigung empfangen kann oder ob er fehlschlägt.

. Ausführen
+
--
[,shell]
----
kubectl get svc neuvector-svc-admission-webhook -n neuvector -o yaml
----

Die Ausgabe sollte folgendermaßen aussehen:

[,yaml]
----
apiVersion: v1
   kind: Service
   metadata:
     annotations:
       ...................
     creationTimestamp: "2019-09-10T22:53:03Z"
     labels:
       echo-neuvector-svc-admission-webhook: "1568163072"      //===> from last test. could be missing if it's a fresh NV deployment
       tag-neuvector-svc-admission-webhook: "1568163072"       //===> from last test. could be missing if it's a fresh NV deployment
     name: neuvector-svc-admission-webhook
     namespace: neuvector
     ...................
   spec:
     clusterIP: 10.107.143.177
     ports:
     - name: admission-webhook
       port: 443
       protocol: TCP
       targetPort: 20443
     selector:
       app: neuvector-controller-pod
     sessionAffinity: None
     type: ClusterIP
   status:
     loadBalancer: {}
----
--
. Klicken Sie jetzt auf die erweiterte Einstellung der Zulassungssteuerung -> Schaltfläche "Test". Warten Sie, bis Erfolg oder Misserfolg angezeigt wird.
{product-name} wird das Tag-Label tag-neuvector-svc-admission-webhook des Dienstes neuvector-svc-admission-webhook implizit ändern.
. Warten Sie auf die interne Operation des Controllers. Wenn der {product-name} Webhook-Server die Aktualisierungsanfrage vom kube-apiserver über diese Dienständerung erhält, wird {product-name} das Echo-Label echo-neuvector-svc-admission-webhook des Dienstes neuvector-svc-admission-webhook auf denselben Wert wie das Tag-Label tag-neuvector-svc-admission-webhook ändern.
. Ausführen
+
--
[,shell]
----
kubectl get svc neuvector-svc-admission-webhook -n neuvector -o yaml
----

Die Ausgabe sollte so aussehen

[,yaml]
----
   apiVersion: v1
   kind: Service
   metadata:
     annotations:
       .............
     creationTimestamp: "2019-09-10T22:53:03Z"
     labels:
       echo-neuvector-svc-admission-webhook: "1568225712"      //===> changed in step 3-3 after receiving request from kube-apiserver
       tag-neuvector-svc-admission-webhook: "1568225712"       //===> changed in step 3-2 because of UI operation
     name: neuvector-svc-admission-webhook
     namespace: neuvector
     .................
   spec:
     clusterIP: 10.107.143.177
     ports:
     - name: admission-webhook
       port: 443
       protocol: TCP
       targetPort: 20443
     selector:
       app: neuvector-controller-pod
     sessionAffinity: None
     type: ClusterIP
   status:
     loadBalancer: {}
----
--
. Nach dem Test, wenn der Wert des Labels tag-neuvector-svc-admission-webhook sich nicht ändert, bedeutet dies, dass der Controller-Dienst nicht in der Lage ist, den Dienst neuvector-svc-admission-webhook zu aktualisieren. Überprüfen Sie, ob die neuvector-binding-app Clusterrolle/Clusterrollenbindung korrekt konfiguriert sind.
. Nach dem Test, wenn der Wert des Labels tag-neuvector-svc-admission-webhook geändert wurde, aber nicht der Wert des Labels echo-neuvector-svc-admission-webhook, bedeutet dies, dass der Webhook-Server die Anfrage vom kube-apiserver nicht erhalten hat. Die Anfrage des kub-apiserver kann den {product-name} Webhook-Server nicht erreichen. Die Ursache dafür könnten Netzwerkverbindungsprobleme, Firewalls, die die Anfrage blockieren (am Standardport 443), die Auflösung der falschen IP für den Controller oder andere sein.
