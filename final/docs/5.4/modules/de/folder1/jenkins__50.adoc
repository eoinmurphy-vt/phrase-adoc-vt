= Jenkins Details
:revdate: 2025-05-05
:page-revdate: {revdate}
:page-opendocs-origin: /06.scanning/03.build/01.jenkins/01.jenkins.md
:page-opendocs-slug:  /scanning/build/jenkins

== Detaillierte Konfiguration für das Jenkins-Plugin

Container bieten eine einfache und effiziente Möglichkeit zur Bereitstellung von Anwendungen. Container-Images können jedoch Open-Source-Code enthalten, über den Sie keine vollständige Kontrolle haben. Viele Sicherheitslücken in Open-Source-Projekten wurden gemeldet, und Sie können entscheiden, ob Sie diese Bibliotheken mit Sicherheitslücken verwenden wollen oder nicht, nachdem Sie die Images gescannt und die Informationen zu den Sicherheitslücken geprüft haben.

Das {product-name} Vulnerability Scanner Jenkins-Plugin kann die Bilder scannen, nachdem Ihr Bild in Jenkins erstellt wurde. Der Quellcode des Plug-ins und die aktuelle Dokumentation sind https://github.com/jenkinsci/neuvector-vulnerability-scanner-plugin[unter] auf der GitHub-Seite {product-name} zu finden.

Das Plug-in unterstützt zwei Scan-Modi. Der erste ist der Modus "Controller & Scanner". Der zweite ist der eigenständige Scannermodus. Sie können den Scanmodus auf der Projektkonfigurationsseite auswählen. Standardmäßig wird der Modus "Controller & Scanner" verwendet.

Für den Modus "Controller & Scanner" müssen Sie den {product-name} Controller und den Scanner im Netzwerk einsetzen. Um das lokale Image (das Image auf dem Jenkins-Rechner) zu scannen, muss der "Controller & Scanner" auf demselben Knoten installiert werden, auf dem das Image existiert.

Für den Standalone-Scannermodus muss die Docker-Laufzeit auf demselben Host wie Jenkins installiert sein. Fügen Sie außerdem den Benutzer jenkins zur Docker-Gruppe hinzu.

[,bash]
----
sudo usermod -aG docker jenkins
----

=== Jenkins-Plugin-Installation

Rufen Sie zunächst Jenkins in Ihrem Browser auf und suchen Sie nach dem Plug-in {product-name}. Dies ist zu finden in:

-> Jenkins verwalten -> Plugins verwalten -> Verfügbar -> Filter -> Suche `{product-name} Vulnerability Scanner` ->

Wählen Sie es aus und klicken Sie auf `install without restart.`

Stellen Sie den {product-name} Controller- und Scanner-Container auf einem vom Jenkins-Server erreichbaren Host bereit, falls Sie dies noch nicht getan haben. Dies kann auf demselben Server wie Jenkins geschehen, falls gewünscht. Notieren Sie sich die IP-Adresse des Rechners, auf dem der Controller läuft. Anmerkung: Der Standard-REST-API-Port ist 10443. Dieser Port muss durch den Allinone oder Controller über einen Dienst in Kubernetes oder eine Port-Map (z. B. - 10443:10443) in der Docker-Run- oder Compose-Datei offengelegt werden.

Vergewissern Sie sich außerdem, dass ein {product-name} Scanner-Container eigenständig installiert und für die Verbindung mit dem Controller konfiguriert ist (falls der Controller verwendet wird).

Es gibt zwei Szenarien für das Scannen von Bildern: lokales Scannen und Scannen der Registrierung.

. *Lokaler Bildscan*. Wenn Sie das Plugin zum Scannen lokaler Abbilder verwenden (bevor Sie sie in eine Registrierung übertragen), können Sie auf demselben Host wie der Controller/Scanner scannen oder den Scanner so konfigurieren, dass er auf die Docker-Engine auf einem entfernten Host zugreift.
. *Registry Image Scan*. Wenn Sie das Plugin zum Scannen von Registry-Images verwenden (nach dem Pushen in beliebige Registrys, aber als Teil des Jenkins-Build-Prozesses), kann der {product-name} Scanner auf jedem Knoten im Netzwerk installiert werden, der eine Verbindung zwischen der Registry, {product-name} Scanner und Jenkins hat.

=== Globale Konfiguration in Jenkins

Nach der Installation des Plugins finden Sie den Abschnitt '`{product-name} Vulnerability Scanner`' auf der globalen Konfigurationsseite (Jenkins '`Configure System`'). Geben Sie Werte für die {product-name} Controller-IP, den Port, den Benutzernamen und das Passwort ein. Sie können auf die Schaltfläche '`Test Connection`' klicken, um die Werte zu bestätigen. Es wird '`Connection Success`' oder eine Fehlermeldung angezeigt.

Der Wert timeout minutes beendet den Build-Schritt innerhalb der eingegebenen Zeit. Der Standardwert von 0 bedeutet, dass keine Zeitüberschreitung auftritt.

Klicken Sie auf '`Add Registry`', um Werte für die Registrierung einzugeben, die Sie in Ihrem Projekt verwenden werden. Wenn Sie nur lokale Bilder scannen wollen, müssen Sie hier keine Registrierung hinzufügen.

Szenario 1: Beispiel für eine globale Konfiguration für die lokale Bildsuche

image:jenkins1a.png[global-image]

Szenario 2: Beispiel für eine globale Konfiguration zur Überprüfung des Registrierungsabbilds

Für die globale Registrierungskonfiguration befolgen Sie die obigen Anweisungen für die lokale Konfiguration und fügen dann die Registrierungsdetails wie unten beschrieben hinzu.

image:registry_console.png[global-registry]

==== Eigenständiger Scanner

Die Ausführung des Jenkins-Scans im Standalone-Modus ist eine leichtgewichtige Methode zum Scannen von Bildschwachstellen in der Pipeline. Der Scanner wird dynamisch aufgerufen und es ist keine Installation eines Controllers erforderlich. Dies ist besonders nützlich, wenn ein Bild gescannt wird, bevor es in eine Registrierung übertragen wird. Es gibt auch keine Begrenzung, wie viele Scan-Aufgaben gleichzeitig laufen können.

Um einen Schwachstellen-Scan im Standalone-Modus auszuführen, muss das Jenkins-Plugin das Scanner-Image auf den Host ziehen, auf dem der Agent ausgeführt wird. Daher müssen Sie auf der Plugin-Konfigurationsseite {product-name} die Registrierungs-URL {product-name} Scanner, das Image-Repository und ggf. die Anmeldeinformationen eingeben.

Das Scan-Ergebnis kann auch an das Kontrollzentrum übermittelt und für die Zulassungskontrolle verwendet werden. In diesem Fall müssen Sie einen Controller einrichten und auf der Plugin-Konfigurationsseite {product-name} angeben, wie Sie sich mit dem Controller verbinden.

=== Lokale Konfiguration zum Scannen eines entfernten Docker-Hosts

==== Voraussetzungen für den lokalen Scan auf einem entfernten Docker-Host

So aktivieren Sie {product-name}, um ein Bild zu scannen, das sich nicht auf demselben Host wie der Controller/Allinone befindet:

* Vergewissern Sie sich, dass der Socket für die Docker-Laufzeit-Api über TCP zugänglich ist.
* Fügen Sie die folgende Umgebungsvariable zu controller/allinone hinzu: SCANNER_DOCKER_URL=tcp://192.168.1.10:2376

=== Projekt-Konfiguration

Wählen Sie in Ihrem Projekt das Plugin '{product-name} Vulnerability Scanner' aus dem Dropdown-Menü im 'Add build step'. Aktivieren Sie das Kontrollkästchen "Mit eigenständigem Scanner scannen", wenn Sie den Scan im eigenständigen Scannermodus durchführen möchten. Standardmäßig wird der "Controller & Scanner"-Modus für den Scanvorgang verwendet.

Wählen Sie Lokal oder einen Registrierungsnamen, der dem in der globalen Konfiguration eingegebenen Spitznamen entspricht. Geben Sie das Repository und den Namen des zu scannenden Bildtags ein. Sie können Jenkins Standard-Umgebungsvariablen für das Repository oder den Tag wählen, z. B. $JOB_NAME, $BUILD_TAG, $BUILD_NUMBER. Geben Sie die Werte für die Anzahl von hoch oder mittel und für einen beliebigen Namen der vorhandenen Schwachstellen ein, damit der Build fehlschlägt.

Nach Abschluss des Builds wird ein {product-name} Bericht erstellt. Es werden die Scan-Details und eventuelle Fehler angezeigt.

Szenario 1: Beispiel für eine lokale Konfiguration

image:jenkins_local.png[local-image]

Szenario 2: Beispiel für die Konfiguration der Registry

image:jenkins_registry.png[lokales-register]

=== Jenkins Pipeline

Für das Jenkins-Pipeline-Projekt können Sie direkt Ihr eigenes Pipeline-Skript schreiben oder auf '`pipeline syntax`' klicken, um das Skript zu generieren, wenn Sie neu in der Pipeline-Stilaufgabe sind.

image:jenkins5a.png[pipeline]

Wählen Sie den {product-name} Vulnerability Scanner aus der Dropdown-Liste aus, konfigurieren Sie ihn, und generieren Sie das Skript.

image:jenkins6a.png[Skript]

Kopieren Sie das Skript in Ihr Jenkins-Aufgabenskript.

Szenario 1: Einfaches Beispiel für ein lokales Pipeline-Skript (zum Einfügen in Ihr Pipeline-Skript):

[,shell]
----
...
  stage('Scan local image') \{
    neuvector registrySelection: 'Local', repository: 'your_username/your_image'
  \}
...
----

Szenario 2: Einfaches Beispiel für ein Pipeline-Skript für die Registrierung (zum Einfügen in Ihr Pipeline-Skript):

[,shell]
----
...
  stage('Scan local image') \{
    neuvector registrySelection: 'your_registry', repository: 'your_username/your_image'
  \}
...
----

=== Zusätzliche Etappen

Fügen Sie Ihre eigenen Phasen vor und nach dem Bildscan hinzu, z. B. in der Pipeline-Stufenansicht unten.

image:jenkins7a.png[Stufen]

Sie sind nun bereit, Ihre Jenkins-Builds zu starten und den {product-name} Vulnerability Scanner auszulösen, um alle Schwachstellen zu melden!

=== Einrichten der Pipeline zum Erstellen von parallelen Scans in großem Maßstab

Ab NeuVector v5.4.3 unterstützt das NeuVector Vulnerability Scanner Jenkins Plugin v2.5 und höher das parallele Scannen von bis zu 2000 gleichzeitigen Scans bei Verwendung des API-Key-Modus. Bei früheren Versionen von NeuVector ist die maximale Anzahl gleichzeitiger Scans bei Verwendung des Token-Modus auf 32 begrenzt. Klicken Sie auf "Erweitern" und sehen Sie sich die unten stehenden Beispiele für Rohrleitungskonfigurationen an.

.Verwendung des Token-Modus Beispielkonfiguration (Plugin v2.4 und niedriger oder v2.5 und höher) 
[%collapsible]
====
[,groovy]
----
pipeline {
    agent any
    environment {
        REPO_NAME = 'your repo'
        REGISTRY_SELECTION = 'your registry'
        CONTROLLER = 'your controller'
        MAX_CONCURRENT_SCANS = 32
    }
    stages {
        stage('Parallel Vulnerability Scanning') {
            steps {
                script {
                    // There is a limit of 250 tags per list (by Jenkins) 
                    TAGS_LIST_PART1 = ["your tags"...]
                    TAGS_LIST_PART2 = ["your tags"...]
                    TAGS_LIST_PART3 = ["your tags"...]
                    TAGS_LIST_PART4 = ["your tags"...]
                    TAGS_LIST_PART5 = ["your tags"...]...
                    def allTags = TAGS_LIST_PART1 + TAGS_LIST_PART2 + TAGS_LIST_PART3 + TAGS_LIST_PART4 + TAGS_LIST_PART5
                    def batches = allTags.collate(MAX_CONCURRENT_SCANS.toInteger()) // Ensure MAX_CONCURRENT_SCANS is an integer
                    def batchCounter = 1                    for (batch in batches) {
                        stage("Batch ${batchCounter}") {
                            def scans = [:]
                            batch.each { tag ->
                                def currentTag = tag
                                scans["Scan ${currentTag}"] = {
                                    stage("Scan ${currentTag}") {
                                        neuvector(
                                            controllerEndpointUrlSelection: CONTROLLER,
                                            registrySelection: REGISTRY_SELECTION,
                                            repository: REPO_NAME,
                                            scanTimeout: 20,
                                            tag: "${currentTag}"
                                        )
                                        echo "Scan for tag ${currentTag} complete"
                                    }
                                }
                            }
                            parallel scans
                        }
                        batchCounter++
                    }
                }
            }
        }
    }
}
----
====

.Verwendung des API-Schlüsselmodus (Plugin v2.5 und später)
[%collapsible]
====
[,groovy]
----
pipeline {
    agent any
    environment {
        REPO_NAME = 'your repo'
        REGISTRY_SELECTION = 'your registry'
        CONTROLLER = 'your controller'
    }
    stages {
        stage('Parallel Vulnerability Scanning') {
            steps {
                script {
                    // There is a limit of 250 tags per list (by Jenkins) 
                    TAGS_LIST_PART1 = ["your tags"...]
                    TAGS_LIST_PART2 = ["your tags"...]
                    TAGS_LIST_PART3 = ["your tags"...]
                    TAGS_LIST_PART4 = ["your tags"...]
                    TAGS_LIST_PART5 = ["your tags"...]...
                    def allTags = TAGS_LIST_PART1 + TAGS_LIST_PART2 + TAGS_LIST_PART3 + TAGS_LIST_PART4 + TAGS_LIST_PART5
                    def scans = [:]

                    allTags.each { tag ->
                        def currentTag = tag
                        scans["Scan ${currentTag}"] = {
                            stage("Scan ${currentTag}") {
                                neuvector(
                                    controllerEndpointUrlSelection: CONTROLLER,
                                    registrySelection: REGISTRY_SELECTION,
                                    repository: REPO_NAME,
                                    scanTimeout: 20,
                                    tag: "${currentTag}"
                                )
                                echo "Scan for tag ${currentTag} complete"
                            }
                        }
                    }
                    parallel scans
                }
            }
        }
    }
}
----
====

== OpenShift Route und Registry Token Beispiel

Um das Plug-in mit einer OpenShift-Route für den Ingress zum Controller zu konfigurieren, fügen Sie die Route in das Feld Controller-IP ein.

image:rhos_jenkins_route.png[openshift]

Um eine Token-basierte Authentifizierung für die OpenShift-Registry zu verwenden, verwenden Sie NONAME als Benutzer und geben Sie das Token in das Passwort ein.

== Spezieller Anwendungsfall für Jenkins im gleichen Kubernetes-Cluster

Um die Build-Phase zu scannen, wenn die Jenkins-Software im selben Kubernetes-Cluster wie der Scanner ausgeführt wird, stellen Sie sicher, dass der Scanner und Jenkins auf demselben Knoten ausgeführt werden. Der Knoten muss so beschriftet werden, dass die Jenkins- und Scanner-Container auf demselben Knoten laufen, da der Scanner Zugriff auf die docker.sock des lokalen Knotens benötigt, um auf das Image zuzugreifen.
