= API REST et automatisation
:revdate: 2025-05-08
:page-revdate: {revdate}
:page-opendocs-origin: /11.automation/02.automation/02.automation.md
:page-opendocs-slug:  /automatisation/automatisation

== {product-name} Automatisation

Il existe de nombreuses fonctionnalités d'automatisation dans {product-name} pour prendre en charge l'ensemble du flux de travail CI/CD, y compris :

* Plug-in Jenkins pour le scan automatisé pendant la construction
* Scan de registre pour automatiser la surveillance des dépôts
* Politiques de contrôle d'admission pour autoriser/refuser les déploiements non autorisés
* Les benchmarks CIS s'exécutent automatiquement sur les hôtes
* Chart Helm sur GitHub pour le déploiement automatisé sur Kubernetes
* Règles de réponse pour automatiser les réponses aux événements de sécurité
* API REST pour construire l'automatisation de toute fonction {product-name}

=== API REST

La solution {product-name} peut être gérée à l'aide de l'API REST. Voici des exemples courants d'automatisation utilisant l'API REST. Le document yaml de l'API REST est mieux visualisé dans le visualiseur Swagger 2.0. La documentation de l'API REST est ci-dessous dans un fichier yaml qui est mieux visualisé dans un lecteur tel que swagger.io.

La dernière mise à jour peut être trouvée https://raw.githubusercontent.com/neuvector/neuvector/main/controller/api/apis.yaml[ici]. Aussi dans le code source GitHub {product-name} https://github.com/neuvector/neuvector/blob/main/controller/api/apis.yaml[repo].  Le apis.yaml du camion principal peut inclure des fonctionnalités non publiées.  Il est recommandé de télécharger le code source de la version publiée appropriée et d'extraire le apis.yaml du dossier controller/api.

[IMPORTANT]
====
Si vous effectuez des appels d'API REST avec un nom d'utilisateur/mot de passe, veuillez vous assurer de faire un appel DELETE contre /v1/auth lorsque vous avez terminé. Il y a un maximum de 32 sessions simultanées pour chaque utilisateur. Si cela est dépassé, un échec d'authentification se produira.
====

{product-name} prend également en charge les règles de réponse pour automatiser les réponses courantes aux événements de sécurité ou aux vulnérabilités détectées. Veuillez consulter la section Politique de sécurité -> Règles de réponse pour plus de détails.

=== Exposer l'API REST dans Kubernetes

Pour exposer l'API REST pour un accès depuis l'extérieur du cluster Kubernetes, activez le port 10443.

[,yaml]
----
apiVersion: v1
kind: Service
metadata:
  name: neuvector-svc-controller-api
  namespace: neuvector
spec:
  ports:
    - port: 10443
      name: controller-api
      protocol: TCP
  type: LoadBalancer
  selector:
    app: neuvector-controller-pod
----

[NOTE]
====
`type: NodePort` peut également être utilisé à la place de LoadBalancer.
====

[NOTE]
====
Si vous utilisez le type LoadBalancer, définissez le _controllerIP_ dans les exemples ci-dessous sur l'IP externe ou l'URL du loadbalancer.
====

=== Authentification pour l'API REST

L'API REST prend en charge deux types d'authentification : nom d'utilisateur/mot de passe et jeton. Les deux peuvent être configurés dans Paramètres -> Utilisateurs, Clés API et Rôles, et être associés à des rôles par défaut ou personnalisés pour limiter les privilèges d'accès. Les exemples ci-dessous montrent une authentification basée sur le nom d'utilisateur/mot de passe où un jeton est créé d'abord, puis utilisé dans les appels d'API REST suivants. Si vous utilisez un jeton, il peut être utilisé directement dans chaque appel d'API REST. Remarque : les connexions basées sur le nom d'utilisateur ont un nombre limité de sessions simultanées, il est donc important de supprimer le jeton du nom d'utilisateur comme indiqué ci-dessous une fois terminé. L'authentification basée sur un jeton n'a pas de limite, mais expire selon la limite de temps sélectionnée lors de sa création.

Pour l'authentification basée sur un jeton, voir les captures d'écran suivantes et l'appel d'exemple. Assurez-vous de copier le secret et le jeton une fois créés, car il n'y a aucun moyen de les récupérer après la fermeture de l'écran.

image:5_2_api_key.png[token]

image:5_2_api_created.png[token]

image:5_2_api_key_header.png[token]

=== Déclencher une analyse de vulnérabilité à partir d'un script

{product-name} peut être déclenché automatiquement pour analyser une image à la recherche de vulnérabilités. Cela peut être fait en configurant un registre/dépôt à surveiller, en utilisant le plug-in {product-name} Jenkins, ou en utilisant l'API REST. Veuillez consulter la section sur l'analyse et la conformité pour plus de détails.

Le script d'exemple ci-dessous montre comment tirer le conteneur à distance, l'exécuter et l'analyser. Il peut être déclenché à partir d'une tâche Jenkins (shell distant) ou de tout outil CI/CD. Un outil de parsing JSON (jq) est également utilisé.

Assurez-vous d'entrer l'adresse IP du contrôleur dans le script et de changer le nom de l'image du conteneur par celui que vous souhaitez analyser. De plus, mettez à jour les champs nom d'utilisateur/mot de passe.

.Cliquez ici pour plus de détails
[%collapsible]
====
[,bash]
----
_curCase_=`echo $0 | awk -F"." '{print $(NF-1)}' | awk -F"/" '{print $NF}'`
_DESC_="able to scan ubuntu:16.04 image"
_ERRCODE_=0
_ERRTYPE_=1
_RESULT_="pass"

# please remember to specify the controller ip address here
_controllerIP_="<your_controller_ip>"
_controllerRESTAPIPort_="10443"
_neuvectorUsername_="admin"
_neuvectorPassword_="admin"
_registryURL_=""
_registryUsername_=""
_registryPassword_=""
_repository_="alpine"
_tag_="latest"

curl -k -H "Content-Type: application/json" -d '{"password": {"username": "'$_neuvectorUsername_'", "password": "'$_neuvectorPassword_'"}}' "https://$_controllerIP_:$_controllerRESTAPIPort_/v1/auth" > /dev/null 2>&1 > token.json
_TOKEN_=`cat token.json | jq -r '.token.token'`
echo `date +%Y%m%d_%H%M%S` scanning an image ...
curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" -d '{"request": {"registry": "'$_registryURL_'", "username": "'$_registryUsername_'", "password": "'$_registryPassword_'", "repository": "'$_repository_'", "tag": "'$_tag_'"}}' "https://$_controllerIP_:$_controllerRESTAPIPort_/v1/scan/repository" > /dev/null 2>&1 > scan_repository.json

while [ `wc -c < scan_repository.json` = "0" ]; do
    echo `date +%Y%m%d_%H%M%S` scanning is still in progress ...
    sleep 5
    curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" -d '{"request": {"registry": "'$_registryURL_'", "username": "'$_registryUsername_'", "password": "'$_registryPassword_'", "repository": "'$_repository_'", "tag": "'$_tag_'"}}' "https://$_controllerIP_:$_controllerRESTAPIPort_/v1/scan/repository" > /dev/null 2>&1 > scan_repository.json
done

echo `date +%Y%m%d_%H%M%S` log out
curl -k -X 'DELETE' -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" "https://$_controllerIP_:$_controllerRESTAPIPort_/v1/auth" > /dev/null 2>&1
cat scan_repository.json | jq .

rm *.json
echo `date +%Y%m%d_%H%M%S` [$_curCase_] $_DESC_: $_RESULT_-$_ERRCODE_
----
====

[NOTE]
====
Vous devrez peut-être installer jq

[,bash]
----
sudo zypper install jq
----
====

Pour les déploiements basés sur Kubernetes, vous pouvez définir l'IP du contrôleur comme suit :

[,bash]
----
_podNAME_=`kubectl get pod -n neuvector -o wide | grep "allinone\|controller" | head -n 1 | awk '{print $1}'`
_controllerIP_=`kubectl exec $_podNAME_ -n neuvector -- consul info | grep leader_addr | awk -F":| " '{print $3}'`
----

[NOTE]
====
Dans un déploiement avec plusieurs contrôleurs, les requêtes doivent être envoyées à une seule IP de contrôleur afin que plusieurs requêtes pour le statut des analyses d'images de longue durée aillent au contrôleur effectuant l'analyse.
====

Pour analyser localement au lieu que dans un registre :

[,shell]
----
curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" -d '{"request": {"tag": "3.4", "repository": "nvlab/alpine", "scan_layers": true}}' "https://$_controllerIP_:443/v1/scan/repository"
----

Sortie d'exemple :

.Cliquez ici pour plus de détails
[%collapsible]
====
[,json]
----
{
  "report": {
    "image_id": "c7fc7faf8c28d48044763609508ebeebd912ad6141a722386b89d044b62e4d45",
    "registry": "",
    "repository": "nvlab/alpine",
    "tag": "3.4",
    "digest": "sha256:2441496fb9f0d938e5f8b27aba5cc367b24078225ceed82a9a5e67f0d6738c80",
    "base_os": "alpine:3.4.6",
    "cvedb_version": "1.568",
    "vulnerabilities": [
      {
        "name": "CVE-2018-0732",
        "score": 5,
        "severity": "Medium",
        "vectors": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
        "description": "During key agreement in a TLS handshake using a DH(E) based ciphersuite a malicious server can send a very large prime value to the client. This will cause the client to spend an unreasonably long period of time generating a key for this prime resulting in a hang until the client has finished. This could be exploited in a Denial Of Service attack. Fixed in OpenSSL 1.1.0i-dev (Affected 1.1.0-1.1.0h). Fixed in OpenSSL 1.0.2p-dev (Affected 1.0.2-1.0.2o).",
        "package_name": "openssl",
        "package_version": "1.0.2n-r0",
        "fixed_version": "1.0.2o-r1",
        "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-0732",
        "score_v3": 7.5,
        "vectors_v3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
      },
                  ...
    ],
    "layers": [
      {
        "digest": "c68318b6ae6a2234d575c4b6b33844e3e937cf608c988a0263345c1abc236c14",
        "cmds": "/bin/sh",
        "vulnerabilities": [
          {
            "name": "CVE-2018-0732",
            "score": 5,
            "severity": "Medium",
            "vectors": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
            "description": "During key agreement in a TLS handshake using a DH(E) based ciphersuite a malicious server can send a very large prime value to the client. This will cause the client to spend an unreasonably long period of time generating a key for this prime resulting in a hang until the client has finished. This could be exploited in a Denial Of Service attack. Fixed in OpenSSL 1.1.0i-dev (Affected 1.1.0-1.1.0h). Fixed in OpenSSL 1.0.2p-dev (Affected 1.0.2-1.0.2o).",
            "package_name": "openssl",
            "package_version": "1.0.2n-r0",
            "fixed_version": "1.0.2o-r1",
            "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-0732",
            "score_v3": 7.5,
            "vectors_v3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
          },
                                  ...
        ],
        "size": 5060096
      }
    ]
  }
}
----
====

=== Créer des règles de stratégie automatiquement

Pour créer une nouvelle règle dans le contrôleur de stratégie {product-name}, les groupes pour les champs FROM et TO doivent d'abord exister. L'exemple suivant crée un nouveau groupe basé sur l'étiquette de conteneur nv-service-type=data, et un autre groupe pour l'étiquette nv-service-type=website. Une règle est ensuite créée pour permettre le trafic du conteneur wordpress au conteneur mysql en utilisant uniquement le protocole mysql.

Assurez-vous de mettre à jour le nom d'utilisateur et le mot de passe pour accéder au contrôleur.

[,bash]
----
#!/bin/sh
TOKEN_JSON=$(curl -k -H "Content-Type: application/json" -d '{"password": {"username": "admin", "password": "admin"}}' "https://`docker inspect neuvector.allinone | jq -r '.[0].NetworkSettings.IPAddress'`:10443/v1/auth")
_TOKEN_=`echo $TOKEN_JSON | jq -r '.token.token'`
curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" -d '{"config": {"name": "mydb", "criteria": [{"value": "data", "key": "nv.service.type", "op": "="}]}}' "https://`docker inspect neuvector.allinone | jq -r '.[0].NetworkSettings.IPAddress'`:10443/v1/group"
curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" -d '{"config": {"name": "mywp", "criteria": [{"value": "website", "key": "nv.service.type", "op": "="}]}}' "https://`docker inspect neuvector.allinone | jq -r '.[0].NetworkSettings.IPAddress'`:10443/v1/group"
curl -k -X "PATCH" -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" -d '{"insert": {"rules": [{"comment": "Custom WP Rule", "from": "mywp", "applications": ["MYSQL"], "ports": "any", "to": "mydb", "action": "allow", "id": 0}], "after": 0}}' "https://`docker inspect neuvector.allinone | jq -r '.[0].NetworkSettings.IPAddress'`:10443/v1/policy/rule"
curl -k -X "DELETE" -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" "https://`docker inspect neuvector.allinone | jq -r '.[0].NetworkSettings.IPAddress'`:10443/v1/auth"
----

Si les groupes existent déjà dans {product-name}, alors la nouvelle règle peut être créée, en sautant les étapes de création de groupe. Cet exemple supprime également le jeton d'authentification à la fin. Notez qu'un numéro d'identification de règle peut être spécifié et {product-name} exécute les règles dans l'ordre numérique du plus bas au plus élevé.

=== Fichier de configuration d'exportation/importation

Voici des exemples pour sauvegarder automatiquement le fichier de configuration {product-name}. Vous pouvez choisir d'exporter tous les paramètres de configuration (stratégie, utilisateurs, paramètres, etc.), ou seulement la stratégie.

[IMPORTANT]
====
Ces exemples sont fournis à titre d'exemple uniquement et ne sont pas officiellement pris en charge à moins qu'un accord de support d'entreprise spécifique n'ait été mis en place.
====

Pour exporter toute la configuration :

[,shell]
----
./config.py export -u admin -w admin -s $_controllerIP_ -p $_controllerPort_ -f $_FILENAME_ # exporting the configuration with all settings
----

Pour exporter uniquement la stratégie :

[,shell]
----
./config.py export -u admin -w admin -s $_controllerIP_ -p $_controllerPort_ -f $_FILENAME_ --section policy # exporting the configuration with policy only
----

Pour importer le fichier :

[,shell]
----
./config.py import -u admin -w admin -s $_controllerIP_ -p $_controllerPort_ -f $_FILENAME_ # importing the configuration
----

*Exemples de fichiers python* Contient config.py, client.py et multipart.py. Télécharger des fichiers d'exemple : xref:attachment$ImportExport.zip[ImportExport]. Veuillez mettre les trois fichiers dans un seul dossier pour exécuter les commandes ci-dessus. Vous devrez peut-être installer certains modules Python afin d'exécuter le script.

[,bash]
----
sudo pip install requests six
----

=== Définir ou changer le mot de passe de l'utilisateur

Utilisez les appels API REST pour la gestion des utilisateurs.

[,shell]
----
curl -s -k -H 'Content-Type: application/json' -H 'X-Auth-Token: c64125decb31e6d3125da45cba0f5025' https://127.0.0.1:10443/v1/user/admin -X PATCH -d '{"config":{"fullname":"admin","password":"admin","new_password":"NEWPASS"}}'
----

=== Démarrer la capture de paquets sur un conteneur

Lorsqu'un conteneur présente un comportement suspect, démarrez une capture de paquets.

[,bash]
----
#!/bin/sh
TOKEN_JSON=$(curl -k -H "Content-Type: application/json" -d '{"password": {"username": "admin", "password": "admin"}}' "https://`docker inspect neuvector.allinone | jq -r '.[0].NetworkSettings.IPAddress'`:10443/v1/auth")
_TOKEN_=`echo $TOKEN_JSON | jq -r '.token.token'`
curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" -d '{"sniffer":{"file_number":1,"filter":"port 1381"}}' "https://`docker inspect neuvector.allinone | jq -r '.[0].NetworkSettings.IPAddress'`:10443/v1/sniffer?f_workload=`docker inspect neuvector.allinone | jq -r .[0].Id`"
----

N'oubliez pas d'arrêter la session de capture après un certain temps pour qu'elle ne fonctionne pas indéfiniment. Le nombre de fichiers à faire tourner a une valeur maximale de 50.

=== Vérifiez et acceptez le contrat de licence utilisateur final (nouveaux déploiements)

Obtenez le TOKEN d'authentification comme ci-dessus. Remplacez également l'adresse IP du contrôleur par la vôtre si nécessaire.

[,shell]
----
curl -s -k -H 'Content-Type: application/json' -H 'X-Auth-Token: $_TOKEN_' https://127.0.0.1:10443/v1/eula | jq .
{
  "eula": {
    "accepted":false
  }
}
----

Accepter le contrat de licence utilisateur final (CLUF)

[,shell]
----
curl -s -k -H 'Content-Type: application/json' -H 'X-Auth-Token: $_TOKEN_' -d '{"eula":{"accepted":true}}' https://127.0.0.1:10443/v1/eula
----

Puis vérifiez à nouveau le CLUF.

=== Configurer la numérisation du registre

[,shell]
----
curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" -d '{"request": {"registry": "https://registry.connect.redhat.com", "username": "username", "password": "password", "tag": "latest", "repository": "neuvector/enforcer"}}' "https://controller:port/v1/scan/repository"
----

=== Activer la capture de paquets sur tous les pods dans un espace de noms

.Cliquez ici pour plus de détails
[%collapsible]
====
[,bash]
----
#!/bin/bash
#set -x

hash curl 2>/dev/null || { echo >&2 "Required curl but it's not installed.  Aborting."; exit 1; }
hash jq 2>/dev/null || { echo >&2 "Required jq but it's not installed.  Aborting."; exit 1;}

script="$0"
usage() {
    echo "Usage: $script -n [namespace] -d [pcap duration (seconds)] -l [https://nvserver:10443]" 1>&2;
    exit 1;
}

while getopts ":n:d:l:h" opt; do
    case $opt in
        n)
            NAMESPACE=$OPTARG
            ;;
        d)
            DURATION=$OPTARG
            ;;
        l)  URL="$OPTARG/v1"
            ;;
        h)
            usage
            ;;
        \?)
            echo "Invalid option, $OPTARG.  Try -h for help." 1>&2
            ;;
        :)
            echo "Invalid option: $OPTARG requires an argument" 1>&2
    esac
done

if [ ! "$NAMESPACE" ] || [ ! "$DURATION" ] || [ ! "$URL" ]
then
    usage
    exit 1
fi

count=0
for i in `kubectl -n $NAMESPACE get pods -o wide 2> /dev/null | tail -n +2 | awk '{print $1}' | sed 's|\(.*\)-.*|\1|' | uniq`;
do
    CHOICE1[count]=$i
    count=$count+1
done

if [ -z ${CHOICE1[0]} ]; then
    echo "No pods found in $NAMESPACE."
    exit 1
else
    for i in "${!CHOICE1[@]}"
    do
        echo "$i : ${CHOICE1[$i]}"
    done
    read -p "Packet capture on which pod group? " -r
    if [ -n $REPLY ]; then
        POD_STRING=${CHOICE1[$REPLY]}
        echo $POD_STRING " selected."
    else
        exit 1
    fi
fi

sniffer_start() {
    URI="/sniffer?f_workload=$1"
    sniff_id=$(curl -ks --location --request POST ${URL}${URI} "${curlHeaders[@]}" --data-raw '{ "sniffer": { "file_number": 1, "filter": "" }}' | jq .result.id)
    echo $sniff_id
}

sniffer_stop() {
    URI="/sniffer/stop/${1}"
    status_code=`curl -ks -w "%{http_code}" --location --request PATCH ${URL}${URI} "${curlHeaders[@]}"`
    echo $status_code
}

sniffer_pcap_get() {
    URI="/sniffer/${1}/pcap"
    status_code=`curl -ks -w "%{http_code}" --location --request GET ${URL}${URI} "${curlHeaders[@]}" -o $1.pcap`
    echo $status_code
}

sniffer_pcap_delete() {
    URI="/sniffer/${1}"
    status_code=`curl -ks -w "%{http_code}" --location --request DELETE ${URL}${URI} "${curlHeaders[@]}"`
    echo $status_code
}

show_menu() {
    count=0
    for i in "Exit script" "Start packet capture for $DURATION seconds" "Download packet capture from pods" "Delete packet capture from pods";
    do
        CHOICE2[count]=$i
        count=$count+1
    done
        echo
        echo "Selections:"
    for i in "${!CHOICE2[@]}"
    do
        echo "$i : ${CHOICE2[$i]}"
    done
}

get_token() {
read -p "Enter {product-name} Username: " USER
if [ -z $USER ]; then
    echo "Blank username, exiting..."
    exit 1
fi
read -s -p "Enter password: " PASS
if [ -z $PASS ]; then
    echo
    echo "Blank password, exiting..."
    exit 1
fi

TOKEN=`curl -ks --location --request POST ${URL}/auth \
--header "accept: application/json" \
--header "Content-Type: application/json" \
--data-raw '{"password": {"username": "'$USER'", "password": "'$PASS'"}}'|jq .token.token`
echo $TOKEN
}

TOKEN=$(get_token)
while [ "$TOKEN" = "null" ]; do
    echo
    echo "Authenticating failed, retry."
    TOKEN=$(get_token)
done

TOKEN=${TOKEN:1:${#TOKEN}-2}
echo
declare -a curlHeaders=('-H' "Content-Type: application/json" '-H' "X-Auth-Token: $TOKEN")
echo "Pulling worklods from $URL"
declare -a workloads="($(
    curl -ks --location --request GET ${URL}/workload "${curlHeaders[@]}" \
    | jq '.workloads[] | select(.display_name | startswith("'${POD_STRING}'"))| select(.domain=="'$NAMESPACE'" and .cap_sniff==true) | .display_name + "::" +.id' -r
))"

if [ ${#workloads[@]} -eq 0 ]; then
    echo
    echo "No pods is capable of packet capture.  Only ethernet IP part of Kubernetes CIDR can packet capture."
    exit 1
else
    echo
    echo "List of Pods to perform capture on."
    echo "Pod Name : ID"
    for pods in "${workloads[@]}" ; do
        POD_NAME="${pods%%::*}"
        POD_ID="${pods##*::}"
        echo "$POD_NAME : $POD_ID"
    done
fi

while :; do
    show_menu
    read -p "Choice? " -r
    if [ -n $REPLY ]; then
        case "$REPLY" in
            0)
                exit 0;
                ;;
            1)
                counter=0
                declare -a sniffs;
                for pods in "${workloads[@]}"; do
                    POD_ID="${pods##*::}"
                    sniff_id="$(sniffer_start $POD_ID)";
                    sniffs[$counter]=$sniff_id
                    counter=$((counter+1))
                done
                echo "Running pcap for ~$DURATION seconds.";
                sleep $DURATION;
                for sniff_id in "${sniffs[@]}"; do
                    sniff_id=${sniff_id:1:${#sniff_id}-2}
                    status="$(sniffer_stop $sniff_id)";
                done
                ;;
            2)
                for sniff_id in "${sniffs[@]}"; do
                    sniff_id=${sniff_id:1:${#sniff_id}-2}
                    status="$(sniffer_pcap_get $sniff_id)";
                done
                ;;
            3)
                for sniff_id in "${sniffs[@]}"; do
                    sniff_id=${sniff_id:1:${#sniff_id}-2}
                    status="$(sniffer_pcap_delete $sniff_id)";
                done
                ;;
        esac
    else
        exit 1
    fi
done
----
====

=== Activer/Désactiver la mise en quarantaine des conteneurs

L'appel API pour mettre en quarantaine se fait via PATCH à /v1/workload/:id avec le corps suivant. L'identifiant de la charge de travail est l'identifiant du conteneur/pod.

[,json]
----
--data-raw '{
    "config": {
        "quarantine": true,
        "wire": "default",
        "quarantine_reason": "violation"
    }
}'
----

=== Activer le mode de débogage pour le support {product-name}

Définir le jeton d'accès avec votre IP, utilisateur, mot de passe :

[,shell]
----
_controllerIP_="<your_controller_ip>"
_controllerRESTAPIPort_="10443"
_neuvectorUsername_="admin"
_neuvectorPassword_="admin"
----

Obtenez le jeton d'authentification

[,shell]
----
curl -k -H "Content-Type: application/json" -d '{"password": {"username": "'$_neuvectorUsername_'", "password": "'$_neuvectorPassword_'"}}' "https://$_controllerIP_:$_controllerRESTAPIPort_/v1/auth" > /dev/null 2>&1 > token.json
_TOKEN_=`cat token.json | jq -r '.token.token'`
----

Activer le mode débogage

[,shell]
----
curl -X PATCH -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" -d '{"config": {"controller_debug": ["cpath", "conn"]}}' "https://$_controllerIP_:$_controllerRESTAPIPort_/v1/system/config"  > /dev/null 2>&1   > set_debug.json
#debug options - cpath, conn, mutex, scan, cluster , all
----

Désactiver le débogage sur tous les contrôleurs dans un cluster

[,shell]
----
curl -X PATCH -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" -d '{"config": {"controller_debug": []}}' "https://$_controllerIP_:$_controllerRESTAPIPort_/v1/system/config"  > /dev/null 2>&1   > set_debug.json
----

Vérifiez l'état de débogage du contrôleur dans un cluster

[,shell]
----
curl  -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_"  "https://$_controllerIP_:$_controllerRESTAPIPort_/v1/system/config"  > /dev/null 2>&1   > system_setting.json

cat system_setting.json | jq .config.controller_debug
----

Déconnexion

----
echo `date +%Y%m%d_%H%M%S` log out
curl -k -X 'DELETE' -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" "https://$_controllerIP_:$_controllerRESTAPIPort_/v1/auth" > /dev/null 2>&1
----

=== Signalez si une vulnérabilité se trouve dans les couches de l'image de base

Pour identifier les CVE dans l'image de base lors de l'utilisation de l'API REST pour scanner les images, l'image de base doit être identifiée dans l'appel API, comme dans l'exemple ci-dessous.

[,shell]
----
curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" -d '{"request": {"registry": "https://registry.hub.docker.com/", "repository": "garricktam/debian", "tag": "latest", "scan_layers": false, "base_image": "2244...../nodejs:3.2......"}}' "https://$RESTURL/v1/scan/repository"
{noformat}
----

==== Limitations

Si l'image à scanner est une image distante, avec "registry" spécifié, l'image de base doit également être une image distante, et le nom doit commencer par http ou https.  Si l'image à scanner est une image locale, alors l'image de référence doit également être une image locale.

Par exemple,

[,json]
----
{"request": {"repository": "neuvector/manager", "tag": "4.0.2", "scan_layers": true, "base_image": "alpine:3.12.0"}}
{"request": {"registry": "https://10.1.127.12:5000/", "repository": "neuvector/manager", "tag": "4.0.0", "scan_layers": true, "base_image": "https://registry.hub.docker.com/alpine:3.12.0"}}
{"request": {"repository": "neuvector/manager", "tag": "4.0.2", "scan_layers": true, "base_image": "10.1.127.12:5000/neuvector/manager:4.0.2”}}
----

=== Obtenez la version et la date de la base de données CVE

[,shell]
----
curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" "https://127.0.0.1:10443/v1/scan/scanner"
----

Sortie :

[,json]
----
{
    "scanners": [
        {
            "cvedb_create_time": "2020-07-07T10:34:04Z",
            "cvedb_version": "1.950",
            "id": "0f043705948557828ac1831ee596588a0d050950113117ddd19ecd604982f4d9",
            "port": 18402,
            "server": "127.0.0.1"
        },
        {
            "cvedb_create_time": "2020-07-07T10:34:04Z",
            "cvedb_version": "1.950",
            "id": "9fa02c644d603f59331c95735158d137002d32a75ed1014326f5039f38d4d717",
            "port": 18402,
            "server": "192.168.9.95"
        }
    ]
}
----

=== Gérer la fédération pour les clusters principaux et distants (travailleurs)

En général, lister les membres de la fédération peut utiliser un GET vers le point de terminaison suivant (voir les exemples pour la syntaxe spécifique) :
`https://neuvector-svc-controller.neuvector:10443/v1/fed/member`

Pour des informations sur l'automatisation de la fédération via ConfigMap, consultez la documentation xref:configmap.adoc#_federated_configmap_examples_fedinitcfg_yaml[Exemples de ConfigMap fédérés].

API de gestion de fédération sélectionnées :

.Cliquez ici pour plus de détails
[%collapsible]
====
[,bash]
----
_masterClusterIP_=$1
_workerClusterIP_=$2
# this is used if one of clusters is going to be kicked by master cluster
_CLUSTER_name_=$3

echo `date +%Y%m%d_%H%M%S` [$_curCase_] login as default admin user
curl -k -H "Content-Type: application/json" -d '{"password": {"username": "admin", "password": "admin"}}' "https://$_masterClusterIP_:10443/v1/auth" > /dev/null 2>&1 > ./$_LOGFOLDER_/token.json
_TOKEN_M_=`cat ./$_LOGFOLDER_/token.json | jq -r '.token.token'`

echo `date +%Y%m%d_%H%M%S` [$_curCase_] promote to master cluster
curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_M_" -d '{"master_rest_info": {"port": 11443, "server": "'$_masterClusterIP_'"}, "name": "master"}' "https://$_masterClusterIP_:10443/v1/fed/promote" > /dev/null 2>&1
echo `date +%Y%m%d_%H%M%S` [$_curCase_] idle 6 seconds for logon session timeout
sleep 6

echo `date +%Y%m%d_%H%M%S` [$_curCase_] login as default admin user on master cluster
curl -k -H "Content-Type: application/json" -d '{"password": {"username": "admin", "password": "admin"}}' "https://$_masterClusterIP_:10443/v1/auth" > /dev/null 2>&1 > ./token.json
_TOKEN_M_=`cat ./token.json | jq -r '.token.token'`

echo `date +%Y%m%d_%H%M%S` [$_curCase_] checking fed join_token on master cluster
curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_M_" "https://$_masterClusterIP_:10443/v1/fed/join_token" > /dev/null 2>&1 > ./join_token.json
cat ./join_token.json | jq -c .
_JOIN_TOKEN_=`cat ./join_token.json | jq -r '.join_token'`

echo `date +%Y%m%d_%H%M%S` [$_curCase_] login as default admin user on worker cluster
curl -k -H "Content-Type: application/json" -d '{"password": {"username": "admin", "password": "admin"}}' "https://$_workerClusterIP_:10443/v1/auth" > /dev/null 2>&1 > ./token.json
_TOKEN_W_=`cat ./token.json | jq -r '.token.token'`

echo `date +%Y%m%d_%H%M%S` [$_curCase_] joining the cluster
curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_W_" -d '{"join_token": "'$_JOIN_TOKEN_'", "name": "worker", "joint_rest_info": {"port": 10443, "server": "'$_workerClusterIP_'"}}' "https://$_workerClusterIP_:10443/v1/fed/join" > /dev/null 2>&1
echo `date +%Y%m%d_%H%M%S` [$_curCase_] idle 9 seconds for events
sleep 9

########## whenever there is a change on cluster such as a cluster is kicked/left/joined, run this to check the status ############
echo `date +%Y%m%d_%H%M%S` [$_curCase_] checking fed member on master cluster
curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_M_" "https://$_masterClusterIP_:10443/v1/fed/member" > /dev/null 2>&1 > ./fedMember.json
cat ./fedMember.json | jq -c .

echo `date +%Y%m%d_%H%M%S` [$_curCase_] checking fed member on worker cluster
curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_W_" "https://$_workerClusterIP_:10443/v1/fed/member" > /dev/null 2>&1 > ./fedMember.json
cat ./fedMember.json | jq -c .
_CLUSTER_id_=`cat ./fedMember.json | jq -r --arg _CLUSTER_name_ "$_CLUSTER_name_" '.joint_clusters[] | select(.name == $_CLUSTER_name_).id'`
###################################################################################################################################

########## for ur information to leave or kick the cluster ############
echo `date +%Y%m%d_%H%M%S` [$_curCase_] requesting to leave on worker cluster
curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_W_" -d '{"force": false}' "https://$_workerClusterIP_:10443/v1/fed/leave" > /dev/null 2>&1
echo `date +%Y%m%d_%H%M%S` [$_curCase_] idle 9 seconds for events
sleep 9

echo `date +%Y%m%d_%H%M%S` [$_curCase_] requesting to kick on master cluster, $_CLUSTER_id_
curl -k -X "DELETE" -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_M_" "https://$_masterClusterIP_:10443/v1/fed/cluster/$_CLUSTER_id_" > /dev/null 2>&1
echo `date +%Y%m%d_%H%M%S` [$_curCase_] idle 9 seconds for events
sleep 9
#######################################################################
----
====
