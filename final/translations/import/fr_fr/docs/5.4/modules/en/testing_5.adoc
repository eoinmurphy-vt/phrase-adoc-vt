= Évaluation et test {product-name}
:revdate: 2025-05-08
:page-revdate: {revdate}
:page-opendocs-origin: /09.testing/01.testing/01.testing.md
:page-opendocs-slug:  /test/test

== Applications d'exemple

Après avoir déployé les composants {product-name}, vous pouvez les évaluer en utilisant les applications de test d'exemple que nous fournissons. Celles-ci se trouvent dans le dépôt `'nvbeta` sur docker hub.

Un environnement de test typique basé sur Kubernetes aurait un nœud maître et deux à trois nœuds de travail. Vous pouvez contrôler si les pods d'application et les conteneurs {product-name} sont déployés sur un nœud maître (désactivé par défaut).

== Plan de test Kubernetes

Pour déployer une application multi-niveaux utilisant Nginx, Nodejs et Redis, utilisez les exemples ci-dessous (dans l'ordre ci-dessous). Ceci peut nécessiter des modifications pour le déploiement sur OpenShift, Rancher et d'autres outils basés sur Kubernetes.

Créer un espace de noms de démonstration

[,shell]
----
kubectl create namespace demo
----

[NOTE]
====
L'exemple ci-dessous utilise apiVersion: apps/v1 requis par Kubernetes 1.16+.
====

Créer le service Redis et le déploiement en utilisant ce yaml :

[,yaml]
----
apiVersion: v1
kind: Service
metadata:
  name: redis
  namespace: demo
spec:
  ports:
  - port: 6379
    protocol: "TCP"
    name: "cluster-tcp-6379"
  clusterIP: None
  selector:
    app: redis-pod

---

apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis-pod
  namespace: demo
spec:
  selector:
    matchLabels:
      app: redis-pod
  template:
    metadata:
      labels:
        app: redis-pod
    spec:
      containers:
      - name: redis-pod
        image: redis
----

Créer le service Nodejs et le déploiement en utilisant ce yaml :

[,yaml]
----
apiVersion: v1
kind: Service
metadata:
  name: node
  namespace: demo
spec:
  ports:
  - port: 8888
    protocol: "TCP"
    name: "cluster-tcp-8888"
  clusterIP: None
  selector:
    app: node-pod

---

apiVersion: apps/v1
kind: Deployment
metadata:
  name: node-pod
  namespace: demo
spec:
  selector:
    matchLabels:
      app: node-pod
  replicas: 3
  template:
    metadata:
      labels:
        app: node-pod
    spec:
      containers:
      - name: node-pod
        image: nvbeta/node
----

Créer le service Nginx et le déploiement en utilisant ce yaml :

[,yaml]
----
apiVersion: v1
kind: Service
metadata:
  name: nginx-webui
  namespace: demo
spec:
  ports:
    - port: 80
      name: webui
      protocol: TCP
  type: NodePort
  selector:
    app: nginx-pod

---

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-pod
  namespace: demo
spec:
  selector:
    matchLabels:
      app: nginx-pod
  template:
    metadata:
      labels:
        app: nginx-pod
    spec:
      containers:
      - name: nginx-pod
        image: nvbeta/swarm_nginx
        ports:
        - containerPort: 80
          protocol: TCP
----

Pour accéder au service Nginx-webui de l'extérieur, trouvez le port aléatoire qui lui est attribué (mappé au port 80) par le NodePort :

[,shell]
----
kubectl get svc -n demo
----

Puis connectez-vous à l'adresse IP publique/port de l'un des nœuds Kubernetes, par exemple `http://(public_IP):(NodePort)`

Après avoir déployé {product-name}, vous pouvez exécuter un trafic de test à travers les applications de démonstration pour générer les règles de liste blanche, puis déplacer tous les services en mode Surveillance ou Protection pour voir les violations et les attaques.

=== Génération de violations réseau sur Kubernetes

Pour générer une violation à partir d'un pod nodejs, trouvez un pod :

[,shell]
----
kubectl get pod -n demo
----

Essayez ensuite quelques violations (remplacez node-pod-name) :

[,shell]
----
kubectl exec node-pod-name curl www.google.com -n demo
----

Ou trouvez l'adresse IP interne d'un autre pod de nœud, comme 172.30.2.21 dans l'exemple ci-dessous, pour vous connecter d'un nœud à un autre :

[,shell]
----
kubectl exec node-pod-name curl 172.30.2.21:8888 -n demo
----

==== Générer une menace/attaque

Pour simuler une attaque, connectez-vous à un conteneur, puis essayez une attaque par ping :

[,shell]
----
kubectl exec -it node-pod-name bash -n demo
----

Utilisez l'IP interne d'un autre pod de nœud :

[,shell]
----
ping 172.30.2.21 -s 40000
----

Pour tout ce qui précède, vous pouvez voir les événements de sécurité dans la carte d'activité réseau de la console {product-name}, ainsi que dans l'onglet Notifications.

=== Tests de protection des processus et des fichiers

Essayez diverses activités de processus et de fichiers en exécutant des commandes telles que apt-get update, ssh, scp ou d'autres dans un conteneur. Toute activité de processus ou accès à un fichier non autorisé générera des alertes dans Notifications.

=== Analyse de registre et contrôle d'admission

Un test populaire consiste à configurer l'analyse d'image d'un registre dans les registres d'actifs ->. Après la fin de l'analyse, configurez une règle de contrôle d'admission dans la politique. Assurez-vous d'activer les contrôles d'admission et de définir une règle pour refuser lorsqu'il y a de fortes vulnérabilités dans une image. Choisissez ensuite une image qui présente de fortes vulnérabilités et essayez de la déployer dans Kubernetes. Le déploiement sera bloqué en mode protection et vous verrez un événement dans les notifications -> Risques de sécurité.

Des tests de contrôle d'admission plus avancés peuvent être effectués en utilisant différents critères dans les règles, ou en combinant des critères.

==== Déployer une autre application

L'application de démon Kubernetes Guestbook peut également être déployée sur Kubernetes. Il est recommandé de la déployer dans son propre espace de noms afin que vous puissiez voir le filtrage basé sur l'espace de noms dans la console {product-name}.

== Plan de test natif Docker

Après avoir déployé les composants {product-name} et l'application d'exemple, vous pourrez découvrir, surveiller et protéger les conteneurs en cours d'exécution. Le plan de test ci-dessous fournit des suggestions pour générer des violations de comportement d'application autorisé en temps d'exécution et scanner les conteneurs pour des vulnérabilités.

xref:attachment$testplan.pdf[{product-name} Plan de Test]

Si le lien ci-dessus ne fonctionne pas, vous pouvez http://neuvector.com/sample-applications-test-plan/[le télécharger] depuis notre site web en utilisant le mot de passe nv1851blvd.

{product-name} peut également détecter des menaces pour vos conteneurs telles que des attaques DDOS. Si vous exécutez un outil pour générer de telles attaques sur vos conteneurs, ces résultats apparaîtront dans l'activité réseau et dans le tableau de bord.

Par exemple, une simple commande ping avec une charge utile élevée affichera l'attaque Ping.Death dans la console. Pour essayer cela, faites ce qui suit à l'adresse IP de l'un des conteneurs (IP interne du conteneur).

[,shell]
----
ping <container_ip> -s 40000
----

Dans Kubernetes, vous pouvez faire cela depuis n'importe quel nœud, y compris le maître. Dans d'autres environnements, vous devrez peut-être être connecté au nœud où le conteneur s'exécute.
