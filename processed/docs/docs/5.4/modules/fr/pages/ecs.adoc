= Amazon ECS
:revdate: 2024-09-27
:page-revdate: {revdate}
:page-opendocs-origin: /02.deploying/09.ecs/09.ecs.md
:page-opendocs-slug: /déployer/ecs

== Wichtig : Die Bereitstellung auf Amazon ECS wird nicht mehr unterstützt

La section de référence ci-dessous n'est pas maintenue. Er kann jedoch eine gewisse Unterstützung bieten, um zu verstehen, wie man das All-in-One auf ECS bereitstellt.

== Bereitstellung auf AWS mit ECS

Dies ist ein Beispiel dafür, wie man {product-name} mit ECS bereitstellt.

[NOTE]
====
Bitte konsultieren Sie die Kubernetes-Beispiele für EKS.
====

. Bereiten Sie mehrere Amazon ECS-Instanzen vor, die die Docker-Engine und die ECS-Agent-Container integriert haben. Wählen Sie einen Knoten für die Management-Konsole aus. Definieren Sie dann Sicherheitsgruppenregeln, die den eingehenden TCP-Port 8443 ({product-name} Standardport der Management-Konsole) für den Zugriff über Ihren Client-Browser zulassen.
. Définissez un groupe de sécurité qui permet les ports TCP et UDP sur 18300, 18301, 18400, 18401. Dies wird von den {product-name} Agenten verwendet, um mit den Controllern/All-in-One zu kommunizieren. Wenden Sie diese Sicherheitsgruppe auf alle ECS-Instanzen an, die die Agenten und Controller/All-in-One {product-name} bereitstellen werden.
. Definieren Sie ein Attribut für die Knoten, die Sie {product-name} All-in-One oder Controller-Container bereitstellen möchten. Wenn Sie beispielsweise {product-name} im HA-Controller-Modus ausführen möchten, wird empfohlen, mindestens 3 Knoten auszuwählen und das Attribut auf allen 3 Knoten hinzuzufügen.
+
--
So fügen Sie Attribute zu Ihren ECS-Instanzen hinzu:

Wählen Sie die Instanz aus und wählen Sie dann "\`+Attribute anzeigen/bearbeiten\+`" im Dropdown-Menü Aktionen.

image:1viewattributes.png[Attribute]

Fügen Sie dann ein neues Attribut hinzu. Zum Beispiel "\`+allinone-node\+`" mit dem Wert "\`+true\+`.

image:2addattribute.png[AddAttributes]
--
. Créez la définition de tâche Allinone. Erstellen Sie eine neue Aufgabendefinition für den Allinone-Container. Sie können die ECS-Oberfläche verwenden, um sie manuell zu erstellen oder die JSON-Beispieldatei einzufügen (siehe unten für Beispiele). Verweisen Sie auf den Abschnitt "\`+1. Bereitstellung von {product-name}\+`" in diesen Dokumenten, um zu erfahren, wie Sie das Allinone konfigurieren.
+
--
Geben Sie die Platzierungsbeschränkung ein. Wenn Sie beispielsweise das oben genannte Attribut-Tagging verwendet haben, geben Sie dies in die Einschränkung ein.

[,json]
----
attribute:allinone-node=~true
----

image:3taskdef.png[AllinoneTask]

[NOTE]
====
Wenn Sie die aktualisierte JSON-Datei jetzt überprüfen, sehen Sie die hinzugefügte Platzierungsbeschränkung.
====
--
. Erstellen Sie einen neuen Dienst für die Allinone-Aufgabe. Setzen Sie die "\`+Placement Templates\+`" auf "\`+One Task Per Host\+`", damit nur ein Allinone/Controller auf einem beliebigen Host ausgeführt werden kann. Sie werden auch sehen, dass die Einschränkung "`membreDe(attribut:allinone-node=~true)" verwendet wird, was erfordert, dass der Knoten dieses Attribut hat.
+
--
image:3taskplacement.png[AllinonePlace]
--
. Sie können jetzt den Allinone-Dienst bereitstellen. Setzen Sie die "\`+Number of tasks\+`" auf die gewünschte Anzahl von Allinone/Controllern. Jetzt werden die {product-name} Allinone- oder Controller-Container auf den ausgewählten Knoten ausgeführt. Nachdem das Allinone gestartet wurde, sollten Sie in der Lage sein, sich über HTTPS auf Port 8443 mit der Konsole {product-name} zu verbinden.
. Créez la définition de tâche Enforcer. Es ist ähnlich wie die Allinone-Aufgabe. Konfigurieren Sie manuell über die ECS-Konsole oder verwenden Sie das folgende JSON-Beispiel.
+
--
Für die Platzierungsbeschränkung des Enforcers müssen Sie sicherstellen, dass der Enforcer NICHT auf demselben Knoten wie das All-in-One ist.

[,json]
----
attribute:allinone-node!~true
----

image:4enforcertask.png[EnforcerTask]
--
. Erstellen Sie einen neuen Dienst für die Aufgabe des Enforcers. Setzen Sie erneut die Platzierung der Aufgabe auf "\`+One Task Per Host\+`", damit nur ein Enforcer auf jedem Host bereitgestellt wird. Beachten Sie auch, dass die zusätzliche Einschränkung zeigen muss, dass sie die Bereitstellung auf einem All-in-One-Knoten verhindert.
+
--
image:5taskplacement.png[EnforcerPlacement]

Stellen Sie diesen Dienst mit der gewünschten Anzahl von Enforcer-Knoten in "\`+Number of tasks\+`" bereit. Sehr bald werden alle Enforcer betriebsbereit sein. Von der Konsole {product-name} aus können Sie alle erkannten Knoten mit Enforcers sehen.
--

== Exemples de définitions de tâches ECS JSON

Sie können die folgenden Beispiele als Ausgangspunkt verwenden, um die Aufgabendefinitionen für die Container {product-name} zu konfigurieren.

Erstellen Sie eine neue Aufgabendefinition und klicken Sie dann unten auf "Über JSON konfigurieren". Bevor Sie das folgende JSON einfügen, ersetzen Sie die IP-Adresse und den Bildpfad (suchen Sie REPLACE in den Beispielen). Im Allgemeinen wäre die IP-Adresse die private IP-Adresse der AWS-Instanz, auf der das All-in-One ausgeführt wird. Sie können auch einen anderen Familiennamen als my-allinone/my-enforcer angeben (unten im JSON).

Beispiel für eine All-in-One JSON-Datei:

.Klicken Sie hier für weitere Details
[%collapsible]
====
[,json]
----
{
    "networkMode": "bridge",
    "taskRoleArn": null,
    "pidMode": "host",
    "containerDefinitions": [
        {
            "volumesFrom": [],
            "memory": null,
            "extraHosts": null,
            "dnsServers": null,
            "disableNetworking": null,
            "dnsSearchDomains": null,
            "portMappings": [
                {
                    "hostPort": 18300,
                    "containerPort": 18300,
                    "protocol": "tcp"
                },
                {
                    "hostPort": 18301,
                    "containerPort": 18301,
                    "protocol": "tcp"
                },
                {
                    "hostPort": 18400,
                    "containerPort": 18400,
                    "protocol": "tcp"
                },
                {
                    "hostPort": 18401,
                    "containerPort": 18401,
                    "protocol": "tcp"
                },
                {
                    "hostPort": 18301,
                    "containerPort": 18301,
                    "protocol": "udp"
                },
                {
                    "hostPort": 8443,
                    "containerPort": 8443,
                    "protocol": "tcp"
                },
                {
                    "hostPort": 1443,
                    "containerPort": 10443,
                    "protocol": "tcp"
                }
            ],
            "hostname": null,
            "essential": true,
            "entryPoint": null,
            "mountPoints": [
                {
                    "containerPath": "/lib/modules",
                    "sourceVolume": "modules",
                    "readOnly": null
                },
                {
                    "containerPath": "/var/run/docker.sock",
                    "sourceVolume": "dockersock",
                    "readOnly": null
                },
                {
                    "containerPath": "/host/proc",
                    "sourceVolume": "proc",
                    "readOnly": true
                },
                {
                    "containerPath": "/host/cgroup",
                    "sourceVolume": "cgroup",
                    "readOnly": true
                }
            ],
            "name": "allinone",
            "ulimits": null,
            "dockerSecurityOptions": null,
            "environment": [
                {
                    "name": "CLUSTER_JOIN_ADDR",
                    "value": "REPLACE: Private IP"
                }
            ],
            "links": null,
            "workingDirectory": null,
            "readonlyRootFilesystem": false,
            "image": "REPLACE: Image Path/Name",
            "command": null,
            "user": null,
            "dockerLabels": {
                "com.myself.name": "neuvector"
            },
            "logConfiguration": null,
            "cpu": 0,
            "privileged": true,
            "memoryReservation": 768
        }
    ],
    "volumes": [
        {
            "host": {
                "sourcePath": "/lib/modules"
            },
            "name": "modules"
        },
        {
            "host": {
                "sourcePath": "/var/run/docker.sock"
            },
            "name": "dockersock"
        },
        {
            "host": {
                "sourcePath": "/proc"
            },
            "name": "proc"
        },
        {
            "host": {
                "sourcePath": "/sys/fs/cgroup"
            },
            "name": "cgroup"
        }
    ],
    "family": "my-allinone",
    "placementConstraints": []
}
----
====

Beispiel für eine Enforcer JSON-Datei:

.Klicken Sie hier für weitere Details
[%collapsible]
====
[,json]
----
{
    "networkMode": "bridge",
    "taskRoleArn": null,
    "pidMode": "host",
    "containerDefinitions": [
        {
            "volumesFrom": [],
            "memory": null,
            "extraHosts": null,
            "dnsServers": null,
            "disableNetworking": null,
            "dnsSearchDomains": null,
            "portMappings": [
                {
                    "hostPort": 18301,
                    "containerPort": 18301,
                    "protocol": "tcp"
                },
                {
                    "hostPort": 18401,
                    "containerPort": 18401,
                    "protocol": "tcp"
                },
                {
                    "hostPort": 18301,
                    "containerPort": 18301,
                    "protocol": "udp"
                }
            ],
            "hostname": null,
            "essential": true,
            "entryPoint": null,
            "mountPoints": [
                {
                    "containerPath": "/lib/modules",
                    "sourceVolume": "modules",
                    "readOnly": null
                },
                {
                    "containerPath": "/var/run/docker.sock",
                    "sourceVolume": "dockersock",
                    "readOnly": null
                },
                {
                    "containerPath": "/host/proc",
                    "sourceVolume": "proc",
                    "readOnly": true
                },
                {
                    "containerPath": "/host/cgroup",
                    "sourceVolume": "cgroup",
                    "readOnly": true
                }
            ],
            "name": "enforcer",
            "ulimits": null,
            "dockerSecurityOptions": null,
            "environment": [
                {
                    "name": "CLUSTER_JOIN_ADDR",
                    "value": "REPLACE: Private IP"
                }
            ],
            "links": null,
            "workingDirectory": null,
            "readonlyRootFilesystem": false,
            "image": "REPLACE: Image Path/Name",
            "command": null,
            "user": null,
            "dockerLabels": {
                "com.myself.name": "neuvector"
            },
            "logConfiguration": null,
            "cpu": 0,
            "privileged": true,
            "memoryReservation": 512
        }
    ],
    "volumes": [
        {
            "host": {
                "sourcePath": "/lib/modules"
            },
            "name": "modules"
        },
        {
            "host": {
                "sourcePath": "/var/run/docker.sock"
            },
            "name": "dockersock"
        },
        {
            "host": {
                "sourcePath": "/proc"
            },
            "name": "proc"
        },
        {
            "host": {
                "sourcePath": "/sys/fs/cgroup"
            },
            "name": "cgroup"
        }
    ],
    "family": "my-enforcer",
    "placementConstraints": []
}
----
====

== Live-Update {product-name}

Sie können eine Live-Aktualisierung der {product-name} Container in ECS durchführen, ohne die Dienste zu unterbrechen. Die {product-name} Dienste können problemlos aktualisiert oder verbessert werden, ohne die laufenden Dienste zu unterbrechen. Um dies in Amazon ECS zu tun:

. Wenn Sie mehrere Controller oder Allinones als Cluster bereitgestellt haben, überspringen Sie diesen Schritt. Wenn nur ein All-in-One/Controller im System vorhanden ist, finden Sie eine neue ECS-Instanz und stellen Sie einen 2. All-in-One/Controller-Container darauf bereit (folgen Sie den Bereitstellungsschritten für ECS All-in-One/Controller {product-name}). Nach der Bereitstellung sehen Sie in der Management-Konsole {product-name} diesen neuen operativen Controller (unter Ressourcen > Controller). Dies ist notwendig, damit alle Statusdaten zwischen den Controllern repliziert werden.
. Setzen Sie in den ECS-Diensten den alten Allinone/Controller-Dienst zurück und löschen Sie ihn. Ziehen Sie manuell die aktualisierten {product-name} Images oder lösen Sie AWS ECS aus, um neue Versionen der All-in-One/Controller-Container von Dockerhub oder Ihrem privaten Repository zu ziehen.
. Erstellen Sie eine neue Revision der All-in-One/Controller-Aufgabe, aktualisieren Sie die "\`+CLUSTER_JOIN_ADDR\+`" auf die IP-Adresse des privaten Knotens des 2. All-in-One/Controllers.
. Erstellen Sie einen neuen Dienst, um diese neue Aufgabe bereitzustellen (folgen Sie denselben Schritten zur Bereitstellung auf ECS). Sobald dies abgeschlossen ist, sollte die neue Version des All-in-One/Controllers betriebsbereit sein. Von der Management-Konsole {product-name} sollten alle Protokolle und Richtlinien weiterhin vorhanden sein. Optional können Sie jetzt den 2. All-in-One/Controller-Container stoppen, da der All-in-One/Controller jetzt auf dem ursprünglichen Knoten gestartet sein sollte.
. Stoppen und aktualisieren Sie die Enforcers von den ECS-Diensten. Ziehen Sie manuell oder automatisch die neuen Enforcer-Images. Starten oder aktualisieren Sie dann den Enforcer auf allen Knoten neu. Von der Konsole {product-name} sehen Sie, dass alle Enforcers auf dem neuesten Stand sind.
. Wenn Sie den separaten Manager-Container anstelle des All-in-One verwenden (der bereits den Manager hat), stoppen und löschen Sie einfach den alten Manager-Container. Ziehen Sie dann die neue Version des Managers und stellen Sie sie bereit, indem Sie die CLUSTER_JOIN_ADDR auf die IP des Controllers zeigen.

Alle Container {product-name} sind jetzt live aktualisiert. Alle Richtlinien, Protokolle und Konfigurationen sind nicht betroffen. The view of the live diagram is automatically regenerated as soon as new live traffic flows between the containers.
