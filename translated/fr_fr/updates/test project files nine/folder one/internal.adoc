= Test_TwoRemplacement des certificats internes
:revdate: 2025-01-27
:page-revdate: {revdate}
:page-opendocs-origin: /02.deploying/01.production/04.internal/04.internal.md
:page-opendocs-slug: /déploiement/production/interne

[IMPORTANT]
====
Les versions de NeuVector 5.4.2 et ultérieures doivent avoir les utilisateurs générer/remplacer les certificats internes avant d'utiliser NeuVector.
Après mars 2025, les versions de NeuVector antérieures à 5.4.2 doivent avoir les utilisateurs générer/remplacer les certificats internes avant d'utiliser NeuVector.
====

== Test_TwoCommunication interne et certificats

{product-name} inclut des certificats auto-signés par défaut pour le chiffrement pour le Manager (accès console/UI), le Contrôleur (API REST, interne), l'Enforcer (interne) et le Scanner (interne).

Ces certificats peuvent être remplacés par les vôtres pour renforcer davantage la communication. Pour remplacer les certificats utilisés par l'accès externe à {product-name} (c'est-à-dire, navigateur vers le Manager, ou API REST vers le Contrôleur), veuillez consulter xref:replacecert.adoc[cette section]. Voir ci-dessous pour remplacer les certificats utilisés dans la communication interne entre les conteneurs {product-name}.

[WARNING]
====
Il est recommandé de remplacer les certificats uniquement lors du déploiement initial de {product-name}. Le remplacement sur un cluster en cours d'exécution (même avec une mise à niveau progressive) peut entraîner un état instable où les pods {product-name} ne peuvent pas communiquer entre eux en raison d'un décalage dans les certificats, et une PERTE DE DONNÉES peut se produire.
====

=== Test_TwoRemplacement des certificats utilisés dans les communications internes de {product-name}

Remplacez les fichiers de chiffrement internes `+ca.crt+`, `+tls.key+`, `+tls.crt+` comme suit :

* Créez un nouveau fichier `+ca.cfg+` avec votre éditeur préféré :

[,shell]
----
[req]
distinguished_name = Test_Tworeq_distinguished_name
x509_extensions = Test_Twov3_req
prompt = Test_Twono
[req_distinguished_name]
C = Test_TwoUS
ST = Test_TwoCalifornia
L = Test_TwoSan Jose
O = Test_Two{product-name} Inc.
OU = Test_TwoNeuvector
CN = Test_TwoNeuvector
[v3_req]
keyUsage = Test_TwodigitalSignature, keyEncipherment, dataEncipherment
extendedKeyUsage = Test_TwoserverAuth, clientAuth
subjectAltName = Test_Two@alt_names
[alt_names]
DNS.1 = Test_TwoNeuvector
----

[IMPORTANT]
====
Pour des informations supplémentaires sur `+ca.cfg+`, voir https://open-docs.neuvector.com/configuration/console/replacecert.
====

* Choisissez votre scénario parmi les options ci-dessous :

[tabs]
========
Nouveau certificat::
+
Si votre certificat est sur le point d'expirer et que vous devez en générer un nouveau, suivez les étapes ci-dessous :
+
* Supprimez l'ancien `+ca.crt+`, `+tls.key+`, `+tls.crt+`, secret kubernetes, et générez-en de nouveaux :
+
[source,bash]
----
kubectl delete secret internal-cert -n neuvector 
openssl genrsa -out ca.key 2048 
openssl req -x509 -sha256 -new -nodes -key ca.key -days 3650 -out ca.crt 
openssl genrsa -out tls.key 2048 
openssl req -new -key tls.key -sha256 -out cert.csr -config ca.cfg 
openssl req -in cert.csr -noout -text 
openssl x509 -req -sha256 -in cert.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out tls.crt -days 3650 -extensions 'v3_req' -extfile ca.cfg 
openssl x509 -in tls.crt -text 
kubectl create secret generic internal-cert -n neuvector --from-file=tls.key --from-file=tls.crt --from-file=ca.crt
----
+
* Puis modifiez les fichiers yamls de déploiement du Contrôleur, de l'Enforcer et du Scanner, en ajoutant :
+
[source,yaml]
----
      containers:
        - name: neuvector-controller/enforcer/scanner-pod
          volumeMounts:
            - mountPath: /etc/neuvector/certs/internal/cert.key
              name: internal-cert
              readOnly: true
              subPath: tls.key
            - mountPath: /etc/neuvector/certs/internal/cert.pem
              name: internal-cert
              readOnly: true
              subPath: tls.crt
            - mountPath: /etc/neuvector/certs/internal/ca.cert
              name: internal-cert
              readOnly: true
              subPath: ca.crt
      volumes:
        - name: internal-cert
          secret:
            defaultMode: 420
            secretName: internal-cert
----
+
Ensuite, procédez à déployer {product-name} comme auparavant. Vous pouvez également accéder à l'interpréteur de commandes dans les pods contrôleur/enforcer/scanner pour confirmer que les fichiers ca.crt, tls.key, tls.crt sont ceux personnalisés et que les communications {product-name} fonctionnent avec les nouveaux certificats.
+
Exemples de commandes de patch pour le contrôleur (changez l'espace de noms en cattle-neuvector-system si nécessaire, et modifiez pour une utilisation sur l'enforcer, le scanner)
+
[source,bash]
----
NAMESPACE=neuvector

kubectl patch deployment -n $\{NAMESPACE} neuvector-controller-pod --type='json' -p='[{"op": "add", "path": "/spec/template/spec/volumes/-", "value": {"name": "internal-cert", "secret": {"defaultMode": 420, "secretName": "internal-cert"}} } ]'

kubectl patch deployment -n $\{NAMESPACE} neuvector-controller-pod --type='json' -p='[{"op": "add", "path": "/spec/template/spec/containers/0/volumeMounts", "value": [{"mountPath": "/etc/neuvector/certs/internal/cert.key", "name": "internal-cert", "readOnly": true, "subPath": "cert.key"}, {"mountPath": "/etc/neuvector/certs/internal/cert.pem", "name": "internal-cert", "readOnly": true, "subPath": "cert.pem"}, {"mountPath": "/etc/neuvector/certs/internal/ca.cert", "name": "internal-cert", "readOnly": true, "subPath": "ca.cert"} ] } ]'
----

Mise à jour du certificat actuel avec des SANs::
+
Si vos fichiers de certificat ont été créés avant la version {product-name} 5.3, vous devez mettre à jour le certificat avec au moins un Nom Alternatif de Sujet, ou SAN pour faire court. Si vous avez encore les fichiers `+ca.key+` et `+ca.crt+` accessibles, exécutez les commandes comme suit :
+
[source,bash]
----
kubectl delete secret internal-cert -n neuvector 
openssl genrsa -out tls.key 2048 
openssl req -new -key tls.key -sha256 -out cert.csr -config ca-new.cfg 
openssl req -in cert.csr -noout -text 
openssl x509 -req -sha256 -in cert.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out tls.crt -days 3650 -extensions 'v3_req' -extfile ca-new.cfg 
openssl x509 -in tls.crt -text 
kubectl create secret generic internal-cert -n neuvector --from-file=tls.key --from-file=tls.crt --from-file=ca.crt
----
+
Une fois que les fichiers de certificat ont été mis à jour, redémarrez les déploiements afin d'utiliser le certificat mis à jour : 
+
[source,bash]
----
kubectl rollout restart deployment neuvector-controller-pod 
kubectl rollout restart deployment neuvector-scanner-pod 
kubectl rollout restart deployment neuvector-registry-adapter-pod 
kubectl rollout restart ds neuvector-enforcer-pod
----

Regénérez les fichiers de certificat et ajoutez des SANs::
+
Si vos fichiers de certificat ont été créés avant la version {product-name} 5.3, vous devez mettre à jour le certificat avec au moins un Nom Alternatif de Sujet, ou SAN pour faire court. Si vous n'avez plus les fichiers `+ca.key+` et `+ca.crt+`, suivez les étapes ci-dessous : 
+
* Sauvegardez votre certificat original 
+
[source,bash]
----
kubectl get secret internal-cert -o yaml > internal-cert.yaml
----
+
* Exportez le certificat interne existant
+
[source,bash]
----
kubectl get secret internal-cert -o json | jq -r '.data."ca.crt"' | base64 -d > old-ca.crt 
kubectl get secret internal-cert -o json | jq -r '.data."tls.crt"' | base64 -d > old-tls.crt 
kubectl get secret internal-cert -o json | jq -r '.data."tls.key"' | base64 -d > old-tls.key 
----
+
* Créez de nouveaux fichiers de certificat et des certificats internes 
+
[source,bash]
----
openssl genrsa -out ca.key 2048 
openssl req -x509 -sha256 -new -nodes -key ca.key -days 3650 -out ca.crt 
openssl genrsa -out tls.key 2048 
openssl req -new -key tls.key -sha256 -out cert.csr -config ca.cfg 
openssl req -in cert.csr -noout -text 
openssl x509 -req -sha256 -in cert.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out tls.crt -days 3650 -extensions 'v3_req' -extfile ca.cfg 
openssl x509 -in tls.crt -text 
----
+
* Fusionnez les anciens et nouveaux fichiers `+ca.crt+` 
+
[source,bash]
----
cat old-ca.crt > /tmp/ca.crt cat ca.crt >> /tmp/ca.crt 
----
+
* Mettez à jour le secret Kubernetes avec le `+ca.crt+` fusionné
+
[source,bash]
----
kubectl delete secret internal-cert -n neuvector 
kubectl create secret generic internal-cert -n neuvector --from-file=tls.key=old-tls.key --from-file=tls.crt=old-tls.crt --from-file=ca.crt=/tmp/ca.crt 
----
+
* Redémarrez les déploiements afin d'utiliser le certificat mis à jour 
+
[source,bash]
----
kubectl rollout restart deployment neuvector-controller-pod 
kubectl rollout restart deployment neuvector-scanner-pod 
kubectl rollout restart deployment neuvector-registry-adapter-pod 
kubectl rollout restart ds neuvector-enforcer-pod 
----
+
* Attendez que le redémarrage soit terminé 
+
[source,bash]
----
kubectl rollout status deployment neuvector-controller-pod 
kubectl rollout status deployment neuvector-scanner-pod 
kubectl rollout status deployment neuvector-registry-adapter-pod 
kubectl rollout status ds neuvector-enforcer-pod 
----
+
* Assurez-vous que la console est accessible et que tous les contrôleurs sont en ligne.* Mettez à jour le secret Kubernetes avec le nouveau `+tls.key+` 
+
[source,bash]
----
kubectl delete secret internal-cert -n neuvector 
kubectl create secret generic internal-cert -n neuvector --from-file=tls.key=tls.key --from-file=tls.crt=tls.crt --from-file=ca.crt=/tmp/ca.crt 
----
+
* Redémarrez les déploiements afin d'utiliser le certificat mis à jour 
+
[source,bash]
----
kubectl rollout restart deployment neuvector-controller-pod 
kubectl rollout restart deployment neuvector-scanner-pod 
kubectl rollout restart deployment neuvector-registry-adapter-pod 
kubectl rollout restart ds neuvector-enforcer-pod 
----
+
* Attendez que le redémarrage soit terminé 
+
[source,bash]
----
kubectl rollout status deployment neuvector-controller-pod
kubectl rollout status deployment neuvector-scanner-pod
kubectl rollout status deployment neuvector-registry-adapter-pod
kubectl rollout status ds neuvector-enforcer-pod 
----
+
* Assurez-vous que la console est accessible et que tous les contrôleurs sont en ligne.* Mettez à jour le secret Kubernetes avec le nouveau `+ca.crt+` 
+
[source,bash]
----
kubectl delete secret internal-cert -n neuvector
kubectl create secret generic internal-cert -n neuvector --from-file=tls.key=tls.key --from-file=tls.crt=tls.crt --from-file=ca.crt=ca.crt 
----
+
* Redémarrez les déploiements afin d'utiliser le certificat mis à jour 
+
[source,bash]
----
kubectl rollout restart deployment neuvector-controller-pod
kubectl rollout restart deployment neuvector-scanner-pod
kubectl rollout restart deployment neuvector-registry-adapter-pod
kubectl rollout restart ds neuvector-enforcer-pod 
----
+
* Attendez que le redémarrage soit terminé 
+
[source,bash]
----
kubectl rollout status deployment neuvector-controller-pod
kubectl rollout status deployment neuvector-scanner-pod
kubectl rollout status deployment neuvector-registry-adapter-pod
kubectl rollout status ds neuvector-enforcer-pod 
----
+
* Assurez-vous que la console est accessible et que tous les contrôleurs sont en ligne.

Regénérez le certificat lorsque le certificat intégré est utilisé::
+
Si vous n'avez pas remplacé le certificat interne auparavant et souhaitez migrer vers un nouvel ensemble de certificats, suivez les étapes ci-dessous :
+
* Vérifiez si vous avez déjà le certificat interne généré automatiquement.
+
[source,bash]
----
kubectl get secret internal-cert -o yaml
----
+
Si vous voyez `+tls.key+`, `+tls.crt+` et `+ca.crt+` là-bas, cela signifie que vous avez utilisé le certificat généré automatiquement et que vous pouvez ignorer cette section.
+
Si vous pouvez voir le secret, mais ne trouvez pas ces secrets, envisagez d'activer `+internal.autoRotateCert+` dans le remplacement des graphiques helm. Cette option générera et fera tourner votre certificat interne automatiquement.
+
Si vous n'utilisez pas le certificat interne généré automatiquement et que vous ne pouvez pas le faire, suivez les étapes ci-dessous :
+
* Suivez les étapes dans l'onglet `+New certificate+` pour utiliser un secret Kubernetes pour gérer le certificat interne. Au lieu de générer un nouveau certificat, utilisez le certificat, `+old-ca.crt+`, `+old-tls.crt+` et `+old-tls.key+`, récupéré ci-dessous :
+
[source,shell]
----
docker run -it --entrypoint=bash neuvector/scanner:3.654 -c "cat /etc/neuvector/certs/internal/ca.cert" > old-ca.crt
docker run -it --entrypoint=bash neuvector/scanner:3.654 -c "cat /etc/neuvector/certs/internal/cert.pem" > old-tls.crt
docker run -it --entrypoint=bash neuvector/scanner:3.654 -c "cat /etc/neuvector/certs/internal/cert.key" > old-tls.key
----
+
* Assurez-vous que tous les composants fonctionnent sans erreurs.
+
* Après cela, suivez les étapes dans l'onglet `+Regenerate certificate files and add SANs+` et migrez vers votre propre certificat.

========

=== Test_TwoMise à jour/Déploiement avec Helm

À partir du graphique Helm `+2.4.1+`, nous pouvons maintenant gérer l'installation du certificat interne. Le graphique https://github.com/neuvector/neuvector-helm/blob/master/charts/core/values.yaml[values.yaml] doit être examiné pour tous les paramètres. L'exemple ci-dessous utilise RKE2, Ingress standard et certificats d'installateur.

[,bash]
----
# add chart
helm repo add neuvector https://neuvector.github.io/neuvector-helm/

# update chart
helm repo update

# add domain for ingress
export domain=awesome.sauce

# run the helm
helm upgrade -i neuvector -n neuvector neuvector/core --create-namespace  --set imagePullSecrets=regsecret --set k3s.enabled=true --set k3s.runtimePath=/run/k3s/containerd/containerd.sock --set manager.ingress.enabled=true --set manager.ingress.host=neuvector.$domain --set manager.svc.type=ClusterIP --set controller.pvc.enabled=true --set controller.pvc.capacity=500Mi --set controller.internal.certificate.secret=internal-cert --set cve.scanner.internal.certificate.secret=internal-cert --set enforcer.internal.certificate.secret=internal-cert
----
