= Remplacer les certificats internes
:revdate: 2025-01-27
:page-revdate: {revdate}
:page-opendocs-origin: /02.deploying/01.production/04.internal/04.internal.md
:page-opendocs-slug: /déploiement/production/interne

[IMPORTANT]
====
Les versions NeuVector 5.4.2 et supérieures doivent amener les utilisateurs à générer/remplacer des certificats internes avant d'utiliser NeuVector.
Après mars 2025, les versions NeuVector antérieures à 5.4.2 doivent amener les utilisateurs à générer/remplacer des certificats internes avant d'utiliser NeuVector.
====

== Communication interne et certificats

{product-name} contient des certificats auto-signés par défaut pour le chiffrement pour le Manager (accès console/UI), le Controller (API REST, interne), l'Enforcer (interne) et le Scanner (interne) communications.

Ces certificats peuvent être remplacés par les vôtres pour sécuriser davantage la communication. Pour l'échange de certificats utilisés pour l'accès externe à {product-name} (c'est-à-dire Navigateur vers le Manager ou API REST vers le Controller), voir xref:replacecert.adoc[cette section]. Voir ci-dessous pour l'échange des certificats utilisés dans la communication interne entre les conteneurs {product-name}.

[WARNING]
====
Il est recommandé de remplacer les certificats uniquement lors du premier déploiement de {product-name}. Le remplacement dans un cluster en cours d'exécution (même avec une mise à niveau progressive) peut entraîner un état instable où les Pods {product-name} ne peuvent pas communiquer entre eux en raison d'un décalage de certificat, ce qui peut entraîner une PERTE DE DONNÉES.
====

=== Remplacement des certificats utilisés dans les communications internes de {product-name}

Remplacez les fichiers de chiffrement internes `+ca.crt+`, `+tls.key+`, `+tls.crt+` comme suit :

* Créez un nouveau fichier `+ca.cfg+` avec votre éditeur préféré :

[,shell]
----
[req]
distinguished_name = req_distinguished_name
x509_extensions = v3_req
prompt = no
[req_distinguished_name]
C = US
ST = California
L = San Jose
O = {product-name} Inc.
OU = Neuvector
CN = Neuvector
[v3_req]
keyUsage = digitalSignature, keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth, clientAuth
subjectAltName = @alt_names
[alt_names]
DNS.1 = Neuvector
----

[IMPORTANT]
====
Pour des informations supplémentaires sur `+ca.cfg+`, voir https://open-docs.neuvector.com/configuration/console/replacecert.
====

* Sélectionnez votre scénario parmi les options suivantes :

[tabs]
========
Nouveau certificat::
+
Si votre certificat est sur le point d'expirer et que vous devez en générer un nouveau, suivez les étapes suivantes :
+
* Supprimez l'ancien `+ca.crt+`, `+tls.key+`, `+tls.crt+`, secret Kubernetes et générez de nouveaux :
+
[source,bash]
----
kubectl delete secret internal-cert -n neuvector 
openssl genrsa -out ca.key 2048 
openssl req -x509 -sha256 -new -nodes -key ca.key -days 3650 -out ca.crt 
openssl genrsa -out tls.key 2048 
openssl req -new -key tls.key -sha256 -out cert.csr -config ca.cfg 
openssl req -in cert.csr -noout -text 
openssl x509 -req -sha256 -in cert.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out tls.crt -days 3650 -extensions 'v3_req' -extfile ca.cfg 
openssl x509 -in tls.crt -text 
kubectl create secret generic internal-cert -n neuvector --from-file=tls.key --from-file=tls.crt --from-file=ca.crt
----
+
* Modifiez ensuite les YAML de déploiement du contrôleur, de l'enforcer et du scanner et ajoutez :
+
[source,yaml]
----
      containers:
        - name: neuvector-controller/enforcer/scanner-pod
          volumeMounts:
            - mountPath: /etc/neuvector/certs/internal/cert.key
              name: internal-cert
              readOnly: true
              subPath: tls.key
            - mountPath: /etc/neuvector/certs/internal/cert.pem
              name: internal-cert
              readOnly: true
              subPath: tls.crt
            - mountPath: /etc/neuvector/certs/internal/ca.cert
              name: internal-cert
              readOnly: true
              subPath: ca.crt
      volumes:
        - name: internal-cert
          secret:
            defaultMode: 420
            secretName: internal-cert
----
+
Ensuite, continuez à {product-name} déployer comme précédemment. Vous pouvez également accéder aux pods du contrôleur/enforcer/scanner pour confirmer que les fichiers ca.crt, tls.key, tls.crt sont les personnalisés et que les communications {product-name} fonctionnent avec les nouveaux certificats.
+
Exemples de commandes de patch pour le contrôleur (changer l'espace de noms en cattle-neuvector-system si nécessaire et adapter pour une utilisation avec l'enforcer, le scanner)
+
[source,bash]
----
NAMESPACE=neuvector

kubectl patch deployment -n $\{NAMESPACE} neuvector-controller-pod --type='json' -p='[{"op": "add", "path": "/spec/template/spec/volumes/-", "value": {"name": "internal-cert", "secret": {"defaultMode": 420, "secretName": "internal-cert"}} } ]'

kubectl patch deployment -n $\{NAMESPACE} neuvector-controller-pod --type='json' -p='[{"op": "add", "path": "/spec/template/spec/containers/0/volumeMounts", "value": [{"mountPath": "/etc/neuvector/certs/internal/cert.key", "name": "internal-cert", "readOnly": true, "subPath": "cert.key"}, {"mountPath": "/etc/neuvector/certs/internal/cert.pem", "name": "internal-cert", "readOnly": true, "subPath": "cert.pem"}, {"mountPath": "/etc/neuvector/certs/internal/ca.cert", "name": "internal-cert", "readOnly": true, "subPath": "ca.cert"} ] } ]'
----

Mettez à jour le certificat actuel avec des SANs::
+
Si vos fichiers de certificat ont été créés avant la version {product-name} 5.3, vous devez mettre à jour le certificat avec au moins un Subject Alternative Name ou SAN. Si vous avez encore accès aux fichiers `+ca.key+` et `+ca.crt+`, exécutez les commandes comme suit :
+
[source,bash]
----
kubectl delete secret internal-cert -n neuvector 
openssl genrsa -out tls.key 2048 
openssl req -new -key tls.key -sha256 -out cert.csr -config ca-new.cfg 
openssl req -in cert.csr -noout -text 
openssl x509 -req -sha256 -in cert.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out tls.crt -days 3650 -extensions 'v3_req' -extfile ca-new.cfg 
openssl x509 -in tls.crt -text 
kubectl create secret generic internal-cert -n neuvector --from-file=tls.key --from-file=tls.crt --from-file=ca.crt
----
+
Une fois que les fichiers de certificat ont été mis à jour, redémarrez les déploiements pour utiliser le certificat mis à jour : 
+
[source,bash]
----
kubectl rollout restart deployment neuvector-controller-pod 
kubectl rollout restart deployment neuvector-scanner-pod 
kubectl rollout restart deployment neuvector-registry-adapter-pod 
kubectl rollout restart ds neuvector-enforcer-pod
----

Regénérez les fichiers de certificat et ajoutez des SANs::
+
Si vos fichiers de certificat ont été créés avant la version {product-name} 5.3, vous devez mettre à jour le certificat avec au moins un Subject Alternative Name ou SAN. Si vous n'avez plus les fichiers `+ca.key+` et `+ca.crt+`, suivez les étapes suivantes : 
+
* Sauvegardez votre certificat d'origine 
+
[source,bash]
----
kubectl get secret internal-cert -o yaml > internal-cert.yaml
----
+
* Exportez le certificat interne existant
+
[source,bash]
----
kubectl get secret internal-cert -o json | jq -r '.data."ca.crt"' | base64 -d > old-ca.crt 
kubectl get secret internal-cert -o json | jq -r '.data."tls.crt"' | base64 -d > old-tls.crt 
kubectl get secret internal-cert -o json | jq -r '.data."tls.key"' | base64 -d > old-tls.key 
----
+
* Créez de nouveaux fichiers de certificat et certificats internes 
+
[source,bash]
----
openssl genrsa -out ca.key 2048 
openssl req -x509 -sha256 -new -nodes -key ca.key -days 3650 -out ca.crt 
openssl genrsa -out tls.key 2048 
openssl req -new -key tls.key -sha256 -out cert.csr -config ca.cfg 
openssl req -in cert.csr -noout -text 
openssl x509 -req -sha256 -in cert.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out tls.crt -days 3650 -extensions 'v3_req' -extfile ca.cfg 
openssl x509 -in tls.crt -text 
----
+
* Combinez les anciens et nouveaux fichiers `+ca.crt+` 
+
[source,bash]
----
cat old-ca.crt > /tmp/ca.crt cat ca.crt >> /tmp/ca.crt 
----
+
* Mettez à jour le secret Kubernetes avec le `+ca.crt+` fusionné
+
[source,bash]
----
kubectl delete secret internal-cert -n neuvector 
kubectl create secret generic internal-cert -n neuvector --from-file=tls.key=old-tls.key --from-file=tls.crt=old-tls.crt --from-file=ca.crt=/tmp/ca.crt 
----
+
* Redémarrez les déploiements pour utiliser le certificat mis à jour 
+
[source,bash]
----
kubectl rollout restart deployment neuvector-controller-pod 
kubectl rollout restart deployment neuvector-scanner-pod 
kubectl rollout restart deployment neuvector-registry-adapter-pod 
kubectl rollout restart ds neuvector-enforcer-pod 
----
+
* Attendez que le redémarrage soit terminé 
+
[source,bash]
----
kubectl rollout status deployment neuvector-controller-pod 
kubectl rollout status deployment neuvector-scanner-pod 
kubectl rollout status deployment neuvector-registry-adapter-pod 
kubectl rollout status ds neuvector-enforcer-pod 
----
+
* Assurez-vous que la console est accessible et que tous les contrôleurs sont en ligne.* Mettez à jour le secret Kubernetes avec le nouveau `+tls.key+` 
+
[source,bash]
----
kubectl delete secret internal-cert -n neuvector 
kubectl create secret generic internal-cert -n neuvector --from-file=tls.key=tls.key --from-file=tls.crt=tls.crt --from-file=ca.crt=/tmp/ca.crt 
----
+
* Redémarrez les déploiements pour utiliser le certificat mis à jour 
+
[source,bash]
----
kubectl rollout restart deployment neuvector-controller-pod 
kubectl rollout restart deployment neuvector-scanner-pod 
kubectl rollout restart deployment neuvector-registry-adapter-pod 
kubectl rollout restart ds neuvector-enforcer-pod 
----
+
* Attendez que le redémarrage soit terminé 
+
[source,bash]
----
kubectl rollout status deployment neuvector-controller-pod
kubectl rollout status deployment neuvector-scanner-pod
kubectl rollout status deployment neuvector-registry-adapter-pod
kubectl rollout status ds neuvector-enforcer-pod 
----
+
* Assurez-vous que la console est accessible et que tous les contrôleurs sont en ligne.* Mettez à jour le secret Kubernetes avec le nouveau `+ca.crt+` 
+
[source,bash]
----
kubectl delete secret internal-cert -n neuvector
kubectl create secret generic internal-cert -n neuvector --from-file=tls.key=tls.key --from-file=tls.crt=tls.crt --from-file=ca.crt=ca.crt 
----
+
* Redémarrez les déploiements pour utiliser le certificat mis à jour 
+
[source,bash]
----
kubectl rollout restart deployment neuvector-controller-pod
kubectl rollout restart deployment neuvector-scanner-pod
kubectl rollout restart deployment neuvector-registry-adapter-pod
kubectl rollout restart ds neuvector-enforcer-pod 
----
+
* Attendez que le redémarrage soit terminé 
+
[source,bash]
----
kubectl rollout status deployment neuvector-controller-pod
kubectl rollout status deployment neuvector-scanner-pod
kubectl rollout status deployment neuvector-registry-adapter-pod
kubectl rollout status ds neuvector-enforcer-pod 
----
+
* Assurez-vous que la console est accessible et que tous les contrôleurs sont en ligne.

Regénérez le certificat si le certificat intégré est utilisé::
+
Si vous n'avez pas remplacé le certificat interne auparavant et que vous souhaitez migrer vers un nouvel ensemble de certificats, suivez les étapes suivantes :
+
* Vérifiez si vous avez déjà généré automatiquement le certificat interne.
+
[source,bash]
----
kubectl get secret internal-cert -o yaml
----
+
Si vous voyez `+tls.key+`, `+tls.crt+` et `+ca.crt+` là-bas, cela signifie que vous avez utilisé le certificat généré automatiquement et que vous pouvez sauter cette section.
+
Si vous pouvez voir le secret, mais que vous ne pouvez pas trouver ces secrets, envisagez d'activer `+internal.autoRotateCert+` dans les remplacements du diagramme Helm. Cette option génère et fait tourner automatiquement votre certificat interne.
+
Si vous n'utilisez pas le certificat interne généré automatiquement et que vous ne pouvez pas le faire, suivez les étapes suivantes :
+
* Suivez les étapes dans l'onglet `+New certificate+` pour utiliser un secret Kubernetes afin de gérer le certificat interne. Au lieu de générer un nouveau certificat, utilisez le certificat, `+old-ca.crt+`, `+old-tls.crt+` et `+old-tls.key+`, que vous avez récupéré ci-dessous :
+
[source,shell]
----
docker run -it --entrypoint=bash neuvector/scanner:3.654 -c "cat /etc/neuvector/certs/internal/ca.cert" > old-ca.crt
docker run -it --entrypoint=bash neuvector/scanner:3.654 -c "cat /etc/neuvector/certs/internal/cert.pem" > old-tls.crt
docker run -it --entrypoint=bash neuvector/scanner:3.654 -c "cat /etc/neuvector/certs/internal/cert.key" > old-tls.key
----
+
* Assurez-vous que tous les composants s'exécutent sans erreur.
+
* Ensuite, suivez les étapes dans l'onglet `+Regenerate certificate files and add SANs+` et migrez vers votre propre certificat.

========

=== Mettre à jour/Déployer avec Helm

Depuis le diagramme Helm `+2.4.1+`, nous pouvons maintenant gérer l'installation du certificat interne. Le diagramme https://github.com/neuvector/neuvector-helm/blob/master/charts/core/values.yaml[values.yaml] doit être vérifié pour tous les paramètres. L'exemple suivant utilise RKE2, Ingress par défaut et certificats d'installation.

[,bash]
----
# add chart
helm repo add neuvector https://neuvector.github.io/neuvector-helm/

# update chart
helm repo update

# add domain for ingress
export domain=awesome.sauce

# run the helm
helm upgrade -i neuvector -n neuvector neuvector/core --create-namespace  --set imagePullSecrets=regsecret --set k3s.enabled=true --set k3s.runtimePath=/run/k3s/containerd/containerd.sock --set manager.ingress.enabled=true --set manager.ingress.host=neuvector.$domain --set manager.svc.type=ClusterIP --set controller.pvc.enabled=true --set controller.pvc.capacity=500Mi --set controller.internal.certificate.secret=internal-cert --set cve.scanner.internal.certificate.secret=internal-cert --set enforcer.internal.certificate.secret=internal-cert
----
