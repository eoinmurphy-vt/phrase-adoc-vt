= API REST et automatisation
:revdate: 2025-05-08
:page-revdate: {revdate}
:page-opendocs-origin: /11.automation/02.automation/02.automation.md
:page-opendocs-slug:  /automation/automation

== {product-name} Automatisation

De nombreuses fonctions d'automatisation sont disponibles sur {product-name} pour prendre en charge l'ensemble du flux de travail CI/CD, notamment

* Plug-in Jenkins pour l'analyse automatisée lors de la construction
* Analyse du registre pour automatiser la surveillance du référentiel
* Politiques de contrôle d'admission pour autoriser/interdire les déploiements non autorisés
* Les tests CIS s'exécutent automatiquement sur les hôtes
* Charte Helm sur github pour un déploiement automatisé sur Kubernetes.
* Règles de réponse pour automatiser les réponses aux événements de sécurité
* API REST pour l'automatisation des bâtiments de n'importe quelle fonction {product-name} 

=== API REST

La solution {product-name} peut être gérée à l'aide de l'API REST. Vous trouverez ci-dessous des exemples courants d'automatisation à l'aide de l'API REST. La doc yaml de l'API REST est mieux visualisée dans la visionneuse Swagger 2.0. La documentation de l'API REST se trouve ci-dessous dans un fichier yaml qu'il est préférable de consulter dans un lecteur tel que swagger.io.

La dernière mise à jour est disponible à l https://raw.githubusercontent.com/neuvector/neuvector/main/controller/api/apis.yaml['adresse suivante :]. Également dans le code source {product-name} GitHub https://github.com/neuvector/neuvector/blob/main/controller/api/apis.yaml[repo].  Le fichier apis.yaml du camion principal peut contenir des fonctionnalités inédites.  Il est recommandé de télécharger le code source de la version publiée appropriée et d'extraire le fichier apis.yaml du dossier controller/api.

[IMPORTANT]
====
Si vous faites des appels à l'API REST avec le nom d'utilisateur/mot de passe, assurez-vous de faire un appel DELETE vers /v1/auth lorsque vous avez terminé. Il y a un maximum de 32 sessions simultanées pour chaque utilisateur. Si cette valeur est dépassée, l'authentification échoue.
====

{product-name} prennent également en charge les règles de réponse afin d'automatiser les réponses courantes aux événements de sécurité ou aux vulnérabilités détectées. Pour plus de détails, voir la section Politique de sécurité -> Règles de réponse.

=== Exposer l'API REST dans Kubernetes

Pour exposer l'API REST à l'accès depuis l'extérieur du cluster Kubernetes, activez le port 10443.

[,yaml]
----
apiVersion: v1
kind: Service
metadata:
  name: neuvector-svc-controller-api
  namespace: neuvector
spec:
  ports:
    - port: 10443
      name: controller-api
      protocol: TCP
  type: LoadBalancer
  selector:
    app: neuvector-controller-pod
----

[NOTE]
====
`+type: NodePort+` peut également être utilisé à la place de LoadBalancer.
====

[NOTE]
====
Si vous utilisez le type LoadBalancer, définissez _controllerIP_ dans les exemples ci-dessous avec l'IP ou l'URL externe du loadbalancer.
====

=== Authentification pour l'API REST

L'API REST prend en charge deux types d'authentification : nom d'utilisateur/mot de passe et jeton. Tous deux peuvent être configurés dans Settings -> Users, API Keys & Roles, et être associés à des rôles par défaut ou personnalisés afin de limiter les privilèges d'accès. Les exemples ci-dessous montrent une authentification basée sur le nom d'utilisateur et le mot de passe, où un jeton est d'abord créé, puis utilisé dans les appels ultérieurs à l'API REST. Si un jeton est utilisé, il peut être utilisé directement dans chaque appel à l'API REST. Note : les connexions basées sur le nom d'utilisateur ont un nombre limité de sessions simultanées, il est donc important de supprimer le jeton de nom d'utilisateur comme indiqué ci-dessous lorsque vous avez terminé. L'authentification par jeton n'a pas de limite, mais elle expire en fonction du délai sélectionné lors de la création.

Pour l'authentification par jeton, voir les captures d'écran et l'exemple d'appel suivants. Veillez à copier le secret et le jeton une fois créés, car il n'y a aucun moyen de les récupérer après la fermeture de l'écran.

image:5_2_api_key.png[jeton]

image:5_2_api_created.png[jeton]

image:5_2_api_key_header.png[jeton]

=== Déclencher l'analyse de vulnérabilité à partir d'un script

{product-name} peut être déclenché automatiquement pour analyser une image à la recherche de vulnérabilités. Cela peut se faire en configurant un registre/référentiel à surveiller, en utilisant le plug-in {product-name} Jenkins ou en utilisant l'API REST. Pour plus de détails, voir la section sur l'analyse et la conformité.

L'exemple de script ci-dessous montre comment extraire le conteneur à distance, l'exécuter et l'analyser. Il peut être déclenché à partir d'une tâche Jenkins (shell distant) ou de n'importe quel outil CI/CD. Un outil d'analyseur JSON (jq) est également utilisé.

Veillez à saisir l'adresse IP du contrôleur dans le script et à remplacer le nom de l'image du conteneur par celui que vous souhaitez numériser. Mettez également à jour les champs nom d'utilisateur/mot de passe.

.Cliquez ici pour plus d'informations
[%collapsible]
====
[,bash]
----
_curCase_=`+echo $0 | awk -F"." '{print $(NF-1)}' | awk -F"/" '{print $NF}'+`
_DESC_="able to scan ubuntu:16.04 image"
_ERRCODE_=0
_ERRTYPE_=1
_RESULT_="pass"

# please remember to specify the controller ip address here
_controllerIP_="<your_controller_ip>"
_controllerRESTAPIPort_="10443"
_neuvectorUsername_="admin"
_neuvectorPassword_="admin"
_registryURL_=""
_registryUsername_=""
_registryPassword_=""
_repository_="alpine"
_tag_="latest"

curl -k -H "Content-Type: application/json" -d '{"password": {"username": "'$_neuvectorUsername_'", "password": "'$_neuvectorPassword_'"}}' "https://$_controllerIP_:$_controllerRESTAPIPort_/v1/auth" > /dev/null 2>&1 > token.json
_TOKEN_=`+cat token.json | jq -r '.token.token'+`
echo `+date +%Y%m%d_%H%M%S+` scanning an image ...
curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" -d '{"request": {"registry": "'$_registryURL_'", "username": "'$_registryUsername_'", "password": "'$_registryPassword_'", "repository": "'$_repository_'", "tag": "'$_tag_'"}}' "https://$_controllerIP_:$_controllerRESTAPIPort_/v1/scan/repository" > /dev/null 2>&1 > scan_repository.json

while [ `+wc -c < scan_repository.json+` = "0" ]; do
    echo `+date +%Y%m%d_%H%M%S+` scanning is still in progress ...
    sleep 5
    curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" -d '{"request": {"registry": "'$_registryURL_'", "username": "'$_registryUsername_'", "password": "'$_registryPassword_'", "repository": "'$_repository_'", "tag": "'$_tag_'"}}' "https://$_controllerIP_:$_controllerRESTAPIPort_/v1/scan/repository" > /dev/null 2>&1 > scan_repository.json
done

echo `+date +%Y%m%d_%H%M%S+` log out
curl -k -X 'DELETE' -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" "https://$_controllerIP_:$_controllerRESTAPIPort_/v1/auth" > /dev/null 2>&1
cat scan_repository.json | jq .

rm *.json
echo `+date +%Y%m%d_%H%M%S+` [$_curCase_] $_DESC_: $_RESULT_-$_ERRCODE_
----
====

[NOTE]
====
Il se peut que vous deviez installer jq

[,bash]
----
sudo zypper install jq
----
====

Pour les déploiements basés sur Kubernetes, vous pouvez définir l'IP du contrôleur comme suit :

[,bash]
----
_podNAME_=`+kubectl get pod -n neuvector -o wide | grep "allinone\|controller" | head -n 1 | awk '{print $1}'+`
_controllerIP_=`+kubectl exec $_podNAME_ -n neuvector -- consul info | grep leader_addr | awk -F":| " '{print $3}'+`
----

[NOTE]
====
Dans un déploiement de plusieurs contrôleurs, les demandes doivent être envoyées à un seul contrôleur IP. Ainsi, les demandes multiples concernant l'état de balayages d'images de longue durée sont envoyées au contrôleur qui effectue le balayage.
====

Pour scanner localement au lieu de le faire dans un registre :

[,shell]
----
curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" -d '{"request": {"tag": "3.4", "repository": "nvlab/alpine", "scan_layers": true}}' "https://$_controllerIP_:443/v1/scan/repository"
----

Exemple de sortie :

.Cliquez ici pour plus d'informations
[%collapsible]
====
[,json]
----
{
  "report": {
    "image_id": "c7fc7faf8c28d48044763609508ebeebd912ad6141a722386b89d044b62e4d45",
    "registry": "",
    "repository": "nvlab/alpine",
    "tag": "3.4",
    "digest": "sha256:2441496fb9f0d938e5f8b27aba5cc367b24078225ceed82a9a5e67f0d6738c80",
    "base_os": "alpine:3.4.6",
    "cvedb_version": "1.568",
    "vulnerabilities": [
      {
        "name": "CVE-2018-0732",
        "score": 5,
        "severity": "Medium",
        "vectors": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
        "description": "During key agreement in a TLS handshake using a DH(E) based ciphersuite a malicious server can send a very large prime value to the client. This will cause the client to spend an unreasonably long period of time generating a key for this prime resulting in a hang until the client has finished. This could be exploited in a Denial Of Service attack. Fixed in OpenSSL 1.1.0i-dev (Affected 1.1.0-1.1.0h). Fixed in OpenSSL 1.0.2p-dev (Affected 1.0.2-1.0.2o).",
        "package_name": "openssl",
        "package_version": "1.0.2n-r0",
        "fixed_version": "1.0.2o-r1",
        "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-0732",
        "score_v3": 7.5,
        "vectors_v3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
      },
                  ...
    ],
    "layers": [
      {
        "digest": "c68318b6ae6a2234d575c4b6b33844e3e937cf608c988a0263345c1abc236c14",
        "cmds": "/bin/sh",
        "vulnerabilities": [
          {
            "name": "CVE-2018-0732",
            "score": 5,
            "severity": "Medium",
            "vectors": "AV:N/AC:L/Au:N/C:N/I:N/A:P",
            "description": "During key agreement in a TLS handshake using a DH(E) based ciphersuite a malicious server can send a very large prime value to the client. This will cause the client to spend an unreasonably long period of time generating a key for this prime resulting in a hang until the client has finished. This could be exploited in a Denial Of Service attack. Fixed in OpenSSL 1.1.0i-dev (Affected 1.1.0-1.1.0h). Fixed in OpenSSL 1.0.2p-dev (Affected 1.0.2-1.0.2o).",
            "package_name": "openssl",
            "package_version": "1.0.2n-r0",
            "fixed_version": "1.0.2o-r1",
            "link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-0732",
            "score_v3": 7.5,
            "vectors_v3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
          },
                                  ...
        ],
        "size": 5060096
      }
    ]
  }
}
----
====

=== Créer automatiquement des règles de politique générale

Pour créer une nouvelle règle dans le contrôleur de stratégie {product-name}, les groupes des champs FROM et TO doivent d'abord exister. L'exemple suivant crée un nouveau groupe basé sur l'étiquette du conteneur nv-service-type=data, et un autre groupe pour l'étiquette nv-service-type=website. Une règle est ensuite créée pour autoriser le trafic entre le conteneur wordpress et le conteneur mysql en utilisant uniquement le protocole mysql.

Veillez à mettre à jour le nom d'utilisateur et le mot de passe pour l'accès au contrôleur.

[,bash]
----
#!/bin/sh
TOKEN_JSON=$(curl -k -H "Content-Type: application/json" -d '{"password": {"username": "admin", "password": "admin"}}' "https://`+docker inspect neuvector.allinone | jq -r '.[0].NetworkSettings.IPAddress'+`:10443/v1/auth")
_TOKEN_=`+echo $TOKEN_JSON | jq -r '.token.token'+`
curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" -d '{"config": {"name": "mydb", "criteria": [{"value": "data", "key": "nv.service.type", "op": "="}]}}' "https://`+docker inspect neuvector.allinone | jq -r '.[0].NetworkSettings.IPAddress'+`:10443/v1/group"
curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" -d '{"config": {"name": "mywp", "criteria": [{"value": "website", "key": "nv.service.type", "op": "="}]}}' "https://`+docker inspect neuvector.allinone | jq -r '.[0].NetworkSettings.IPAddress'+`:10443/v1/group"
curl -k -X "PATCH" -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" -d '{"insert": {"rules": [{"comment": "Custom WP Rule", "from": "mywp", "applications": ["MYSQL"], "ports": "any", "to": "mydb", "action": "allow", "id": 0}], "after": 0}}' "https://`+docker inspect neuvector.allinone | jq -r '.[0].NetworkSettings.IPAddress'+`:10443/v1/policy/rule"
curl -k -X "DELETE" -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" "https://`+docker inspect neuvector.allinone | jq -r '.[0].NetworkSettings.IPAddress'+`:10443/v1/auth"
----

Si les groupes existent déjà dans {product-name}, la nouvelle règle peut être créée, sans passer par les étapes de création du groupe. Cet exemple supprime également le jeton d'authentification à la fin. Notez qu'un numéro d'identification de la règle peut être spécifié et que {product-name} exécute les règles dans l'ordre numérique, de la plus basse à la plus haute.

=== Exporter/Importer le fichier de configuration

Voici des exemples de sauvegarde automatique du fichier de configuration de {product-name}. Vous pouvez choisir d'exporter tous les paramètres de configuration (politique, utilisateurs, paramètres, etc.) ou uniquement la politique.

[IMPORTANT]
====
Ces échantillons sont fournis à titre d'exemple uniquement et ne sont pas officiellement pris en charge, à moins qu'un accord de soutien spécifique à l'entreprise n'ait été mis en place.
====

Pour exporter toute la configuration :

[,shell]
----
./config.py export -u admin -w admin -s $_controllerIP_ -p $_controllerPort_ -f $_FILENAME_ # exporting the configuration with all settings
----

Pour exporter la politique uniquement :

[,shell]
----
./config.py export -u admin -w admin -s $_controllerIP_ -p $_controllerPort_ -f $_FILENAME_ --section policy # exporting the configuration with policy only
----

Pour importer le fichier :

[,shell]
----
./config.py import -u admin -w admin -s $_controllerIP_ -p $_controllerPort_ -f $_FILENAME_ # importing the configuration
----

*Exemples de fichiers python* Contient config.py, client.py, et multipart.py. Télécharger les fichiers d'exemple : xref:attachment$ImportExport.zip[ImportExport]. Veuillez placer les trois fichiers dans un seul dossier pour exécuter les commandes ci-dessus. Il se peut que vous deviez installer certains modules Python pour pouvoir exécuter le script.

[,bash]
----
sudo pip install requests six
----

=== Définition ou modification du mot de passe de l'utilisateur

Utiliser les appels de l'API restante pour la gestion des utilisateurs.

[,shell]
----
curl -s -k -H 'Content-Type: application/json' -H 'X-Auth-Token: c64125decb31e6d3125da45cba0f5025' https://127.0.0.1:10443/v1/user/admin -X PATCH -d '{"config":{"fullname":"admin","password":"admin","new_password":"NEWPASS"}}'
----

=== Démarrer la capture de paquets sur un conteneur

Lorsqu'un conteneur présente un comportement suspect, lancez une capture de paquets.

[,bash]
----
#!/bin/sh
TOKEN_JSON=$(curl -k -H "Content-Type: application/json" -d '{"password": {"username": "admin", "password": "admin"}}' "https://`+docker inspect neuvector.allinone | jq -r '.[0].NetworkSettings.IPAddress'+`:10443/v1/auth")
_TOKEN_=`+echo $TOKEN_JSON | jq -r '.token.token'+`
curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" -d '{"sniffer":{"file_number":1,"filter":"port 1381"}}' "https://`+docker inspect neuvector.allinone | jq -r '.[0].NetworkSettings.IPAddress'+`:10443/v1/sniffer?f_workload=`+docker inspect neuvector.allinone | jq -r .[0].Id+`"
----

N'oubliez pas d'arrêter la session de reniflage au bout d'un certain temps afin qu'elle ne s'exécute pas indéfiniment. Le nombre de fichiers à faire pivoter a une valeur maximale de 50.

=== Vérifier et accepter le CLUF (nouveaux déploiements)

Obtenir le TOKEN d'authentification comme indiqué ci-dessus. Remplacez également l'adresse IP du contrôleur par la vôtre, le cas échéant.

[,shell]
----
curl -s -k -H 'Content-Type: application/json' -H 'X-Auth-Token: $_TOKEN_' https://127.0.0.1:10443/v1/eula | jq .
{
  "eula": {
    "accepted":false
  }
}
----

Accepter le CLUF

[,shell]
----
curl -s -k -H 'Content-Type: application/json' -H 'X-Auth-Token: $_TOKEN_' -d '{"eula":{"accepted":true}}' https://127.0.0.1:10443/v1/eula
----

Ensuite, vérifiez à nouveau le CLUF.

=== Configurer l'analyse du registre

[,shell]
----
curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" -d '{"request": {"registry": "https://registry.connect.redhat.com", "username": "username", "password": "password", "tag": "latest", "repository": "neuvector/enforcer"}}' "https://controller:port/v1/scan/repository"
----

=== Activer la capture de paquets sur tous les pods d'un espace de noms

.Cliquez ici pour plus d'informations
[%collapsible]
====
[,bash]
----
#!/bin/bash
#set -x

hash curl 2>/dev/null || { echo >&2 "Required curl but it's not installed.  Aborting."; exit 1; }
hash jq 2>/dev/null || { echo >&2 "Required jq but it's not installed.  Aborting."; exit 1;}

script="$0"
usage() {
    echo "Usage: $script -n [namespace] -d [pcap duration (seconds)] -l [https://nvserver:10443]" 1>&2;
    exit 1;
}

while getopts ":n:d:l:h" opt; do
    case $opt in
        n)
            NAMESPACE=$OPTARG
            ;;
        d)
            DURATION=$OPTARG
            ;;
        l)  URL="$OPTARG/v1"
            ;;
        h)
            usage
            ;;
        \?)
            echo "Invalid option, $OPTARG.  Try -h for help." 1>&2
            ;;
        :)
            echo "Invalid option: $OPTARG requires an argument" 1>&2
    esac
done

if [ ! "$NAMESPACE" ] || [ ! "$DURATION" ] || [ ! "$URL" ]
then
    usage
    exit 1
fi

count=0
for i in `+kubectl -n $NAMESPACE get pods -o wide 2> /dev/null | tail -n +2 | awk '{print $1}' | sed 's|\(.*\)-.*|\1|' | uniq+`;
do
    CHOICE1[count]=$i
    count=$count+1
done

if [ -z ${CHOICE1[0]} ]; then
    echo "No pods found in $NAMESPACE."
    exit 1
else
    for i in "${!CHOICE1[@]}"
    do
        echo "$i : ${CHOICE1[$i]}"
    done
    read -p "Packet capture on which pod group? " -r
    if [ -n $REPLY ]; then
        POD_STRING=${CHOICE1[$REPLY]}
        echo $POD_STRING " selected."
    else
        exit 1
    fi
fi

sniffer_start() {
    URI="/sniffer?f_workload=$1"
    sniff_id=$(curl -ks --location --request POST ${URL}${URI} "${curlHeaders[@]}" --data-raw '{ "sniffer": { "file_number": 1, "filter": "" }}' | jq .result.id)
    echo $sniff_id
}

sniffer_stop() {
    URI="/sniffer/stop/${1}"
    status_code=`+curl -ks -w "%{http_code}" --location --request PATCH ${URL}${URI} "${curlHeaders[@]}"+`
    echo $status_code
}

sniffer_pcap_get() {
    URI="/sniffer/${1}/pcap"
    status_code=`+curl -ks -w "%{http_code}" --location --request GET ${URL}${URI} "${curlHeaders[@]}" -o $1.pcap+`
    echo $status_code
}

sniffer_pcap_delete() {
    URI="/sniffer/${1}"
    status_code=`+curl -ks -w "%{http_code}" --location --request DELETE ${URL}${URI} "${curlHeaders[@]}"+`
    echo $status_code
}

show_menu() {
    count=0
    for i in "Exit script" "Start packet capture for $DURATION seconds" "Download packet capture from pods" "Delete packet capture from pods";
    do
        CHOICE2[count]=$i
        count=$count+1
    done
        echo
        echo "Selections:"
    for i in "${!CHOICE2[@]}"
    do
        echo "$i : ${CHOICE2[$i]}"
    done
}

get_token() {
read -p "Enter {product-name} Username: " USER
if [ -z $USER ]; then
    echo "Blank username, exiting..."
    exit 1
fi
read -s -p "Enter password: " PASS
if [ -z $PASS ]; then
    echo
    echo "Blank password, exiting..."
    exit 1
fi

TOKEN=`curl -ks --location --request POST ${URL}/auth \
--header "accept: application/json" \
--header "Content-Type: application/json" \
--data-raw '{"password": {"username": "'$USER'", "password": "'$PASS'"}}'|jq .token.token`
echo $TOKEN
}

TOKEN=$(get_token)
while [ "$TOKEN" = "null" ]; do
    echo
    echo "Authenticating failed, retry."
    TOKEN=$(get_token)
done

TOKEN=${TOKEN:1:${#TOKEN}-2}
echo
declare -a curlHeaders=('-H' "Content-Type: application/json" '-H' "X-Auth-Token: $TOKEN")
echo "Pulling worklods from $URL"
declare -a workloads="($(
    curl -ks --location --request GET ${URL}/workload "${curlHeaders[@]}" \
    | jq '.workloads[] | select(.display_name | startswith("'${POD_STRING}'"))| select(.domain=="'$NAMESPACE'" and .cap_sniff==true) | .display_name + "::" +.id' -r
))"

if [ ${#workloads[@]} -eq 0 ]; then
    echo
    echo "No pods is capable of packet capture.  Only ethernet IP part of Kubernetes CIDR can packet capture."
    exit 1
else
    echo
    echo "List of Pods to perform capture on."
    echo "Pod Name : ID"
    for pods in "${workloads[@]}" ; do
        POD_NAME="${pods%%::*}"
        POD_ID="${pods##*::}"
        echo "$POD_NAME : $POD_ID"
    done
fi

while :; do
    show_menu
    read -p "Choice? " -r
    if [ -n $REPLY ]; then
        case "$REPLY" in
            0)
                exit 0;
                ;;
            1)
                counter=0
                declare -a sniffs;
                for pods in "${workloads[@]}"; do
                    POD_ID="${pods##*::}"
                    sniff_id="$(sniffer_start $POD_ID)";
                    sniffs[$counter]=$sniff_id
                    counter=$((counter+1))
                done
                echo "Running pcap for ~$DURATION seconds.";
                sleep $DURATION;
                for sniff_id in "${sniffs[@]}"; do
                    sniff_id=${sniff_id:1:${#sniff_id}-2}
                    status="$(sniffer_stop $sniff_id)";
                done
                ;;
            2)
                for sniff_id in "${sniffs[@]}"; do
                    sniff_id=${sniff_id:1:${#sniff_id}-2}
                    status="$(sniffer_pcap_get $sniff_id)";
                done
                ;;
            3)
                for sniff_id in "${sniffs[@]}"; do
                    sniff_id=${sniff_id:1:${#sniff_id}-2}
                    status="$(sniffer_pcap_delete $sniff_id)";
                done
                ;;
        esac
    else
        exit 1
    fi
done
----
====

=== Activer Désactiver la quarantaine de conteneurs

L'appel de l'API à la quarantaine se fait par PATCH à /v1/workload/:id avec le corps suivant. L'identifiant de la charge de travail est l'identifiant du conteneur/pod.

[,json]
----
--data-raw '{
    "config": {
        "quarantine": true,
        "wire": "default",
        "quarantine_reason": "violation"
    }
}'
----

=== Activer le mode de débogage pour le support {product-name} 

Définissez un jeton d'accès avec votre IP, votre utilisateur et votre mot de passe :

[,shell]
----
_controllerIP_="<your_controller_ip>"
_controllerRESTAPIPort_="10443"
_neuvectorUsername_="admin"
_neuvectorPassword_="admin"
----

Obtenir le jeton d'authentification

[,shell]
----
curl -k -H "Content-Type: application/json" -d '{"password": {"username": "'$_neuvectorUsername_'", "password": "'$_neuvectorPassword_'"}}' "https://$_controllerIP_:$_controllerRESTAPIPort_/v1/auth" > /dev/null 2>&1 > token.json
_TOKEN_=`+cat token.json | jq -r '.token.token'+`
----

Activer le mode débogage

[,shell]
----
curl -X PATCH -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" -d '{"config": {"controller_debug": ["cpath", "conn"]}}' "https://$_controllerIP_:$_controllerRESTAPIPort_/v1/system/config"  > /dev/null 2>&1   > set_debug.json
#debug options - cpath, conn, mutex, scan, cluster , all
----

Désactiver le débogage sur tous les contrôleurs d'un cluster

[,shell]
----
curl -X PATCH -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" -d '{"config": {"controller_debug": []}}' "https://$_controllerIP_:$_controllerRESTAPIPort_/v1/system/config"  > /dev/null 2>&1   > set_debug.json
----

Vérifier l'état de débogage du contrôleur dans un cluster

[,shell]
----
curl  -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_"  "https://$_controllerIP_:$_controllerRESTAPIPort_/v1/system/config"  > /dev/null 2>&1   > system_setting.json

cat system_setting.json | jq .config.controller_debug
----

Déconnexion

----
echo `+date +%Y%m%d_%H%M%S+` log out
curl -k -X 'DELETE' -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" "https://$_controllerIP_:$_controllerRESTAPIPort_/v1/auth" > /dev/null 2>&1
----

=== Signaler la présence d'une vulnérabilité dans les couches de l'image de base

Pour identifier les CVE dans l'image de base lors de l'utilisation de l'API REST pour scanner des images, l'image de base doit être identifiée dans l'appel API, comme dans l'exemple ci-dessous.

[,shell]
----
curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" -d '{"request": {"registry": "https://registry.hub.docker.com/", "repository": "garricktam/debian", "tag": "latest", "scan_layers": false, "base_image": "2244...../nodejs:3.2......"}}' "https://$RESTURL/v1/scan/repository"
{noformat}
----

==== Limitations

Si l'image à numériser est une image distante, avec "registry" spécifié, l'image de base doit également être une image distante, et le nom doit commencer par http ou https.  Si l'image à numériser est une image locale, l'image de base doit également être une image locale.

Par exemple,

[,json]
----
{"request": {"repository": "neuvector/manager", "tag": "4.0.2", "scan_layers": true, "base_image": "alpine:3.12.0"}}
{"request": {"registry": "https://10.1.127.12:5000/", "repository": "neuvector/manager", "tag": "4.0.0", "scan_layers": true, "base_image": "https://registry.hub.docker.com/alpine:3.12.0"}}
{"request": {"repository": "neuvector/manager", "tag": "4.0.2", "scan_layers": true, "base_image": "10.1.127.12:5000/neuvector/manager:4.0.2”}}
----

=== Obtenir la version et la date de la base de données CVE

[,shell]
----
curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_" "https://127.0.0.1:10443/v1/scan/scanner"
----

Sortie :

[,json]
----
{
    "scanners": [
        {
            "cvedb_create_time": "2020-07-07T10:34:04Z",
            "cvedb_version": "1.950",
            "id": "0f043705948557828ac1831ee596588a0d050950113117ddd19ecd604982f4d9",
            "port": 18402,
            "server": "127.0.0.1"
        },
        {
            "cvedb_create_time": "2020-07-07T10:34:04Z",
            "cvedb_version": "1.950",
            "id": "9fa02c644d603f59331c95735158d137002d32a75ed1014326f5039f38d4d717",
            "port": 18402,
            "server": "192.168.9.95"
        }
    ]
}
----

=== Gérer la fédération pour les clusters maîtres et distants (Worker)

En règle générale, l'établissement de la liste des membres de la Fédération peut se faire au moyen d'un GET vers le point de terminaison suivant (voir les exemples pour la syntaxe spécifique) :
`+https://neuvector-svc-controller.neuvector:10443/v1/fed/member+`

Pour plus d'informations sur l'automatisation de la fédération via ConfigMap, consultez la documentation xref:configmap.adoc#_federated_configmap_examples_fedinitcfg_yaml[Federated ConfigMap Examples.] 

Sélection d'API de gestion de la fédération :

.Cliquez ici pour plus d'informations
[%collapsible]
====
[,bash]
----
_masterClusterIP_=$1
_workerClusterIP_=$2
# this is used if one of clusters is going to be kicked by master cluster
_CLUSTER_name_=$3

echo `+date +%Y%m%d_%H%M%S+` [$_curCase_] login as default admin user
curl -k -H "Content-Type: application/json" -d '{"password": {"username": "admin", "password": "admin"}}' "https://$_masterClusterIP_:10443/v1/auth" > /dev/null 2>&1 > ./$_LOGFOLDER_/token.json
_TOKEN_M_=`+cat ./$_LOGFOLDER_/token.json | jq -r '.token.token'+`

echo `+date +%Y%m%d_%H%M%S+` [$_curCase_] promote to master cluster
curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_M_" -d '{"master_rest_info": {"port": 11443, "server": "'$_masterClusterIP_'"}, "name": "master"}' "https://$_masterClusterIP_:10443/v1/fed/promote" > /dev/null 2>&1
echo `+date +%Y%m%d_%H%M%S+` [$_curCase_] idle 6 seconds for logon session timeout
sleep 6

echo `+date +%Y%m%d_%H%M%S+` [$_curCase_] login as default admin user on master cluster
curl -k -H "Content-Type: application/json" -d '{"password": {"username": "admin", "password": "admin"}}' "https://$_masterClusterIP_:10443/v1/auth" > /dev/null 2>&1 > ./token.json
_TOKEN_M_=`+cat ./token.json | jq -r '.token.token'+`

echo `+date +%Y%m%d_%H%M%S+` [$_curCase_] checking fed join_token on master cluster
curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_M_" "https://$_masterClusterIP_:10443/v1/fed/join_token" > /dev/null 2>&1 > ./join_token.json
cat ./join_token.json | jq -c .
_JOIN_TOKEN_=`+cat ./join_token.json | jq -r '.join_token'+`

echo `+date +%Y%m%d_%H%M%S+` [$_curCase_] login as default admin user on worker cluster
curl -k -H "Content-Type: application/json" -d '{"password": {"username": "admin", "password": "admin"}}' "https://$_workerClusterIP_:10443/v1/auth" > /dev/null 2>&1 > ./token.json
_TOKEN_W_=`+cat ./token.json | jq -r '.token.token'+`

echo `+date +%Y%m%d_%H%M%S+` [$_curCase_] joining the cluster
curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_W_" -d '{"join_token": "'$_JOIN_TOKEN_'", "name": "worker", "joint_rest_info": {"port": 10443, "server": "'$_workerClusterIP_'"}}' "https://$_workerClusterIP_:10443/v1/fed/join" > /dev/null 2>&1
echo `+date +%Y%m%d_%H%M%S+` [$_curCase_] idle 9 seconds for events
sleep 9

########## whenever there is a change on cluster such as a cluster is kicked/left/joined, run this to check the status ############
echo `+date +%Y%m%d_%H%M%S+` [$_curCase_] checking fed member on master cluster
curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_M_" "https://$_masterClusterIP_:10443/v1/fed/member" > /dev/null 2>&1 > ./fedMember.json
cat ./fedMember.json | jq -c .

echo `+date +%Y%m%d_%H%M%S+` [$_curCase_] checking fed member on worker cluster
curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_W_" "https://$_workerClusterIP_:10443/v1/fed/member" > /dev/null 2>&1 > ./fedMember.json
cat ./fedMember.json | jq -c .
_CLUSTER_id_=`+cat ./fedMember.json | jq -r --arg _CLUSTER_name_ "$_CLUSTER_name_" '.joint_clusters[] | select(.name == $_CLUSTER_name_).id'+`
###################################################################################################################################

########## for ur information to leave or kick the cluster ############
echo `+date +%Y%m%d_%H%M%S+` [$_curCase_] requesting to leave on worker cluster
curl -k -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_W_" -d '{"force": false}' "https://$_workerClusterIP_:10443/v1/fed/leave" > /dev/null 2>&1
echo `+date +%Y%m%d_%H%M%S+` [$_curCase_] idle 9 seconds for events
sleep 9

echo `+date +%Y%m%d_%H%M%S+` [$_curCase_] requesting to kick on master cluster, $_CLUSTER_id_
curl -k -X "DELETE" -H "Content-Type: application/json" -H "X-Auth-Token: $_TOKEN_M_" "https://$_masterClusterIP_:10443/v1/fed/cluster/$_CLUSTER_id_" > /dev/null 2>&1
echo `+date +%Y%m%d_%H%M%S+` [$_curCase_] idle 9 seconds for events
sleep 9
#######################################################################
----
====
