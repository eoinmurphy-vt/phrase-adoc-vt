= Remplacement des certificats internes
:revdate: 2025-01-27
:page-revdate: {revdate}
:page-opendocs-origin: /02.deploying/01.production/04.internal/04.internal.md
:page-opendocs-slug: /déploiement/production/interne

[IMPORTANT]
====
Les versions 5.4.2 et ultérieures de NeuVector doivent permettre aux utilisateurs de générer/remplacer des certificats internes avant d'utiliser NeuVector.
Après mars 2025, les versions de NeuVector antérieures à 5.4.2 devront faire générer/remplacer les certificats internes par les utilisateurs avant d'utiliser NeuVector.
====

== Communication interne et certificats

{product-name} inclut des certificats auto-signés par défaut pour le cryptage des communications du gestionnaire (accès console/UI), du contrôleur (API REST, interne), de l'Enforcer (interne) et du Scanner (interne).

Ces certificats peuvent être remplacés par les vôtres pour renforcer la communication. Pour remplacer les certificats utilisés pour l'accès externe à {product-name} (c'est-à-dire le navigateur vers le gestionnaire ou l'API REST vers le contrôleur), veuillez consulter xref:replacecert.adoc[cette section.] Voir ci-dessous pour le remplacement des certificats utilisés dans la communication interne entre les conteneurs {product-name}.

[WARNING]
====
Il est recommandé de ne remplacer les certificats que lors du déploiement initial de {product-name}. Le remplacement sur un cluster en fonctionnement (même avec une mise à jour continue) peut entraîner un état instable dans lequel les pods {product-name} ne peuvent pas communiquer entre eux en raison d'une incompatibilité des certificats, et une perte de données peut se produire.
====

=== Remplacement des certificats utilisés dans les communications internes de l'Union européenne {product-name}

Remplacez les fichiers de cryptage interne `+ca.crt+`, `+tls.key+`, `+tls.crt+` comme suit :

* Créez un nouveau fichier `+ca.cfg+` avec votre éditeur préféré :

[,shell]
----
[req]
distinguished_name = req_distinguished_name
x509_extensions = v3_req
prompt = no
[req_distinguished_name]
C = US
ST = California
L = San Jose
O = {product-name} Inc.
OU = Neuvector
CN = Neuvector
[v3_req]
keyUsage = digitalSignature, keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth, clientAuth
subjectAltName = @alt_names
[alt_names]
DNS.1 = Neuvector
----

[IMPORTANT]
====
Pour plus d'informations sur `+ca.cfg+`, voir https://open-docs.neuvector.com/configuration/console/replacecert.
====

* Choisissez votre scénario parmi les options ci-dessous :

[tabs]
========
Nouveau certificat::
+
Si votre certificat est sur le point d'expirer et que vous devez en générer un nouveau, suivez les étapes ci-dessous :
+
* Supprimez les anciens `+ca.crt+`, `+tls.key+`, `+tls.crt+`, kubernetes secret, et générez-en de nouveaux :
+
[source,bash]
----
kubectl delete secret internal-cert -n neuvector 
openssl genrsa -out ca.key 2048 
openssl req -x509 -sha256 -new -nodes -key ca.key -days 3650 -out ca.crt 
openssl genrsa -out tls.key 2048 
openssl req -new -key tls.key -sha256 -out cert.csr -config ca.cfg 
openssl req -in cert.csr -noout -text 
openssl x509 -req -sha256 -in cert.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out tls.crt -days 3650 -extensions 'v3_req' -extfile ca.cfg 
openssl x509 -in tls.crt -text 
kubectl create secret generic internal-cert -n neuvector --from-file=tls.key --from-file=tls.crt --from-file=ca.crt
----
+
* Modifiez ensuite les yamls de déploiement du Contrôleur, de l'Enforcer et du Scanner, en ajoutant :
+
[source,yaml]
----
      containers:
        - name: neuvector-controller/enforcer/scanner-pod
          volumeMounts:
            - mountPath: /etc/neuvector/certs/internal/cert.key
              name: internal-cert
              readOnly: true
              subPath: tls.key
            - mountPath: /etc/neuvector/certs/internal/cert.pem
              name: internal-cert
              readOnly: true
              subPath: tls.crt
            - mountPath: /etc/neuvector/certs/internal/ca.cert
              name: internal-cert
              readOnly: true
              subPath: ca.crt
      volumes:
        - name: internal-cert
          secret:
            defaultMode: 420
            secretName: internal-cert
----
+
Procédez ensuite au déploiement de {product-name} comme précédemment. Vous pouvez également vous connecter aux pods controller/enforcer/scanner pour confirmer que les fichiers ca.crt, tls.key, tls.crt sont les fichiers personnalisés et que les communications {product-name} fonctionnent à l'aide des nouveaux certificats.
+
Exemple de commandes de correction pour le contrôleur (changer l'espace de noms en cattle-neuvector-system si nécessaire, et modifier pour l'utiliser sur enforcer, scanner)
+
[source,bash]
----
NAMESPACE=neuvector

kubectl patch deployment -n $\{NAMESPACE} neuvector-controller-pod --type='json' -p='[{"op": "add", "path": "/spec/template/spec/volumes/-", "value": {"name": "internal-cert", "secret": {"defaultMode": 420, "secretName": "internal-cert"}} } ]'

kubectl patch deployment -n $\{NAMESPACE} neuvector-controller-pod --type='json' -p='[{"op": "add", "path": "/spec/template/spec/containers/0/volumeMounts", "value": [{"mountPath": "/etc/neuvector/certs/internal/cert.key", "name": "internal-cert", "readOnly": true, "subPath": "cert.key"}, {"mountPath": "/etc/neuvector/certs/internal/cert.pem", "name": "internal-cert", "readOnly": true, "subPath": "cert.pem"}, {"mountPath": "/etc/neuvector/certs/internal/ca.cert", "name": "internal-cert", "readOnly": true, "subPath": "ca.cert"} ] } ]'
----

Mise à jour du certificat actuel avec les SAN::
+
Si vos fichiers de certificats ont été créés avant la version 5.3 de {product-name}, vous devez mettre à jour le certificat avec au moins un Subject Alternative Name (SAN). Si les fichiers `+ca.key+` et `+ca.crt+` sont toujours accessibles, exécutez les commandes suivantes :
+
[source,bash]
----
kubectl delete secret internal-cert -n neuvector 
openssl genrsa -out tls.key 2048 
openssl req -new -key tls.key -sha256 -out cert.csr -config ca-new.cfg 
openssl req -in cert.csr -noout -text 
openssl x509 -req -sha256 -in cert.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out tls.crt -days 3650 -extensions 'v3_req' -extfile ca-new.cfg 
openssl x509 -in tls.crt -text 
kubectl create secret generic internal-cert -n neuvector --from-file=tls.key --from-file=tls.crt --from-file=ca.crt
----
+
Une fois les fichiers de certificat mis à jour, redémarrez les déploiements afin d'utiliser le certificat mis à jour : 
+
[source,bash]
----
kubectl rollout restart deployment neuvector-controller-pod 
kubectl rollout restart deployment neuvector-scanner-pod 
kubectl rollout restart deployment neuvector-registry-adapter-pod 
kubectl rollout restart ds neuvector-enforcer-pod
----

Régénérer les fichiers de certificats et ajouter des SAN::
+
Si vos fichiers de certificats ont été créés avant la version 5.3 de {product-name}, vous devez mettre à jour le certificat avec au moins un Subject Alternative Name (SAN). Si vous n'avez plus les fichiers `+ca.key+` et `+ca.crt+`, suivez les étapes ci-dessous : 
+
* Sauvegarde du certificat original 
+
[source,bash]
----
kubectl get secret internal-cert -o yaml > internal-cert.yaml
----
+
* Exporter le certificat interne existant
+
[source,bash]
----
kubectl get secret internal-cert -o json | jq -r '.data."ca.crt"' | base64 -d > old-ca.crt 
kubectl get secret internal-cert -o json | jq -r '.data."tls.crt"' | base64 -d > old-tls.crt 
kubectl get secret internal-cert -o json | jq -r '.data."tls.key"' | base64 -d > old-tls.key 
----
+
* Créer de nouveaux fichiers de certificats et des certificats internes 
+
[source,bash]
----
openssl genrsa -out ca.key 2048 
openssl req -x509 -sha256 -new -nodes -key ca.key -days 3650 -out ca.crt 
openssl genrsa -out tls.key 2048 
openssl req -new -key tls.key -sha256 -out cert.csr -config ca.cfg 
openssl req -in cert.csr -noout -text 
openssl x509 -req -sha256 -in cert.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out tls.crt -days 3650 -extensions 'v3_req' -extfile ca.cfg 
openssl x509 -in tls.crt -text 
----
+
* Fusionner l'ancien et le nouveau fichier `+ca.crt+`  
+
[source,bash]
----
cat old-ca.crt > /tmp/ca.crt cat ca.crt >> /tmp/ca.crt 
----
+
* Mettre à jour le secret Kubernetes avec la version fusionnée de `+ca.crt+`
+
[source,bash]
----
kubectl delete secret internal-cert -n neuvector 
kubectl create secret generic internal-cert -n neuvector --from-file=tls.key=old-tls.key --from-file=tls.crt=old-tls.crt --from-file=ca.crt=/tmp/ca.crt 
----
+
* Redémarrer les déploiements afin d'utiliser le certificat mis à jour 
+
[source,bash]
----
kubectl rollout restart deployment neuvector-controller-pod 
kubectl rollout restart deployment neuvector-scanner-pod 
kubectl rollout restart deployment neuvector-registry-adapter-pod 
kubectl rollout restart ds neuvector-enforcer-pod 
----
+
* Attendre la fin du redémarrage 
+
[source,bash]
----
kubectl rollout status deployment neuvector-controller-pod 
kubectl rollout status deployment neuvector-scanner-pod 
kubectl rollout status deployment neuvector-registry-adapter-pod 
kubectl rollout status ds neuvector-enforcer-pod 
----
+
* Assurez-vous que la console est accessible et que les contrôleurs sont tous en ligne.* Mettez à jour le secret Kubernetes avec le nouveau `+tls.key+` 
+
[source,bash]
----
kubectl delete secret internal-cert -n neuvector 
kubectl create secret generic internal-cert -n neuvector --from-file=tls.key=tls.key --from-file=tls.crt=tls.crt --from-file=ca.crt=/tmp/ca.crt 
----
+
* Redémarrer les déploiements afin d'utiliser le certificat mis à jour 
+
[source,bash]
----
kubectl rollout restart deployment neuvector-controller-pod 
kubectl rollout restart deployment neuvector-scanner-pod 
kubectl rollout restart deployment neuvector-registry-adapter-pod 
kubectl rollout restart ds neuvector-enforcer-pod 
----
+
* Attendre la fin du redémarrage 
+
[source,bash]
----
kubectl rollout status deployment neuvector-controller-pod
kubectl rollout status deployment neuvector-scanner-pod
kubectl rollout status deployment neuvector-registry-adapter-pod
kubectl rollout status ds neuvector-enforcer-pod 
----
+
* Assurez-vous que la console est accessible et que les contrôleurs sont tous en ligne.* Mettez à jour le secret Kubernetes avec le nouveau `+ca.crt+` 
+
[source,bash]
----
kubectl delete secret internal-cert -n neuvector
kubectl create secret generic internal-cert -n neuvector --from-file=tls.key=tls.key --from-file=tls.crt=tls.crt --from-file=ca.crt=ca.crt 
----
+
* Redémarrer les déploiements afin d'utiliser le certificat mis à jour 
+
[source,bash]
----
kubectl rollout restart deployment neuvector-controller-pod
kubectl rollout restart deployment neuvector-scanner-pod
kubectl rollout restart deployment neuvector-registry-adapter-pod
kubectl rollout restart ds neuvector-enforcer-pod 
----
+
* Attendre la fin du redémarrage 
+
[source,bash]
----
kubectl rollout status deployment neuvector-controller-pod
kubectl rollout status deployment neuvector-scanner-pod
kubectl rollout status deployment neuvector-registry-adapter-pod
kubectl rollout status ds neuvector-enforcer-pod 
----
+
* Assurez-vous que la console est accessible et que les contrôleurs sont tous en ligne.

Régénérer le certificat lorsque le certificat intégré est utilisé::
+
Si vous n'avez pas remplacé le certificat interne auparavant et que vous souhaitez migrer vers un nouveau jeu de certificats, suivez les étapes ci-dessous :
+
* Vérifiez si le certificat interne est déjà généré automatiquement.
+
[source,bash]
----
kubectl get secret internal-cert -o yaml
----
+
Si vous voyez `+tls.key+`, `+tls.crt+` et `+ca.crt+`, cela signifie que vous avez utilisé le certificat généré automatiquement et que vous pouvez sauter cette section.
+
Si vous pouvez voir le secret, mais que vous ne pouvez pas trouver ces secrets, envisagez d'activer `+internal.autoRotateCert+` dans la commande des cartes de pilotage. Cette option permet de générer et de faire pivoter automatiquement votre certificat interne.
+
Si vous n'utilisez pas le certificat interne généré automatiquement et que vous ne pouvez pas le faire, suivez les étapes ci-dessous :
+
* Suivez les étapes de l'onglet `+New certificate+` pour utiliser un secret Kubernetes afin de gérer le certificat interne. Au lieu de générer un nouveau certificat, utilisez les certificats `+old-ca.crt+`, `+old-tls.crt+` et `+old-tls.key+`, récupérés ci-dessous :
+
[source,shell]
----
docker run -it --entrypoint=bash neuvector/scanner:3.654 -c "cat /etc/neuvector/certs/internal/ca.cert" > old-ca.crt
docker run -it --entrypoint=bash neuvector/scanner:3.654 -c "cat /etc/neuvector/certs/internal/cert.pem" > old-tls.crt
docker run -it --entrypoint=bash neuvector/scanner:3.654 -c "cat /etc/neuvector/certs/internal/cert.key" > old-tls.key
----
+
* Assurez-vous que tous les composants fonctionnent sans erreur.
+
* Ensuite, suivez les étapes de l'onglet `+Regenerate certificate files and add SANs+` et migrez vers votre propre certificat.

========

=== Mise à jour/déploiement avec Helm

Depuis la charte Helm `+2.4.1+`, nous pouvons désormais gérer l'installation des certificats internes. Le graphique https://github.com/neuvector/neuvector-helm/blob/master/charts/core/values.yaml[values.yaml] doit être revu pour tous les paramètres. L'exemple ci-dessous utilise des certificats RKE2, Ingress standard et d'installateur.

[,bash]
----
# add chart
helm repo add neuvector https://neuvector.github.io/neuvector-helm/

# update chart
helm repo update

# add domain for ingress
export domain=awesome.sauce

# run the helm
helm upgrade -i neuvector -n neuvector neuvector/core --create-namespace  --set imagePullSecrets=regsecret --set k3s.enabled=true --set k3s.runtimePath=/run/k3s/containerd/containerd.sock --set manager.ingress.enabled=true --set manager.ingress.host=neuvector.$domain --set manager.svc.type=ClusterIP --set controller.pvc.enabled=true --set controller.pvc.capacity=500Mi --set controller.internal.certificate.secret=internal-cert --set cve.scanner.internal.certificate.secret=internal-cert --set enforcer.internal.certificate.secret=internal-cert
----
