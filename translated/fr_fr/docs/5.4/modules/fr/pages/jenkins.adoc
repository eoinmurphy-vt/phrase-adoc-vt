= Détails de Jenkins
:revdate: 2025-05-05
:page-revdate: {revdate}
:page-opendocs-origin: /06.scanning/03.build/01.jenkins/01.jenkins.md
:page-opendocs-slug:  /scanning/build/jenkins

== Configuration détaillée pour le plugin Jenkins

Les conteneurs offrent un moyen simple et efficace de déployer des applications. Mais les images de conteneurs peuvent contenir du code open-source sur lequel vous n'avez pas un contrôle total. De nombreuses vulnérabilités dans des projets open-source ont été signalées, et vous pouvez décider si vous souhaitez utiliser ces bibliothèques avec des vulnérabilités ou non, après avoir analysé les images et vérifié les informations sur les vulnérabilités.

Le plugin {product-name} Jenkins Vulnerability Scanner peut analyser les images après que votre image a été créée dans Jenkins. Le code source du plugin et la documentation la plus récente se trouvent https://github.com/jenkinsci/neuvector-vulnerability-scanner-plugin[ici] sur la page GitHub {product-name}.

Le plugin prend en charge deux modes d'analyse. Le premier est le mode "Contrôleur & Scanner". Le second est le mode scanner autonome. Vous pouvez sélectionner le mode d'analyse sur la page de configuration du projet. Par défaut, il utilise le mode "Contrôleur & Scanner".

Pour le mode "Contrôleur & Scanner", vous devez déployer le contrôleur et le scanner {product-name} sur le réseau. Pour analyser l'image locale (l'image sur la machine Jenkins), le "Contrôleur & Scanner" doit être installé sur le même nœud où l'image existe.

Pour le mode scanner autonome, le runtime Docker doit être installé sur le même hôte que Jenkins. De plus, ajoutez l'utilisateur jenkins au groupe Docker.

[,bash]
----
sudo usermod -aG docker jenkins
----

=== Installation du plugin Jenkins

Tout d'abord, allez dans votre navigateur à Jenkins pour rechercher le plugin {product-name}. Cela peut être trouvé dans:

-> Gérer Jenkins -> Gérer les plugins -> Disponible -> Filtrer -> Rechercher `+{product-name} Vulnerability Scanner+` ->

Sélectionnez-le et cliquez sur `+install without restart.+`

Déployez le {product-name} conteneur de contrôleur et de scanner, si vous ne l'avez pas encore fait sur un hôte accessible par le serveur Jenkins. Cela peut se faire sur le même serveur que Jenkins, si désiré. Notez l'adresse IP de l'hôte sur lequel le contrôleur fonctionne. Remarque : Le port API REST par défaut est 10443. Ce port doit être exposé via l'All-in-One ou le contrôleur par un service dans Kubernetes ou un transfert de port (par exemple, - 10443:10443) dans le fichier Docker Run ou Compose. Assurez-vous également qu'un  conteneur de scanner en mode autonome est déployé et configuré pour se connecter au contrôleur (si le contrôleur est utilisé).

Il existe deux scénarios pour le scan d'images : le scan local et le scan des registries.

Scanner d'image local.

. Si vous utilisez le plugin pour scanner des images locales (avant de les pousser dans les registries), vous pouvez scanner sur le même hôte que le contrôleur/scanner ou configurer le scanner pour accéder à l'engine Docker sur un hôte distant. Scanner d'image de registry.
. Si vous utilisez le plugin pour scanner des images des registries (après les avoir poussées dans les registries, mais dans le cadre du processus de construction Jenkins), le  scanner peut être installé sur n'importe quel nœud du réseau qui a une connexion entre la registry, le  scanner et Jenkins. Configuration globale dans Jenkins

=== Après avoir installé le plugin, vous trouverez la section '\`+ Scanner de vulnérabilités\+ sur la page de configuration globale (Jenkins '\+Configurer le système\+).

Entrez les valeurs pour l'IP du  contrôleur, le port, le nom d'utilisateur et le mot de passe. Vous pouvez cliquer sur le bouton '\+Tester la connexion\+ pour valider les valeurs. Sie können auf die Schaltfläche '\`+Verbindung testen\+`' klicken, um die Werte zu validieren. 

La valeur du temps d'attente terminera la phase de construction au moment saisi. La valeur par défaut de 0 signifie qu'aucun temps d'attente ne se produit.

Cliquez sur '\`+Ajouter un registre\+`'', pour entrer les valeurs pour le registre que vous utiliserez dans votre projet. Si vous ne scannez que des images locales, vous n'avez pas besoin d'ajouter un registre ici.

Scénario 1 : Exemple de configuration globale pour scanner des images locales.

image:jenkins1a.png[global-image]

Scénario 2 : Exemple de configuration globale pour scanner des images de registre.

Pour la configuration globale du registre, suivez les instructions ci-dessus pour local et ajoutez ensuite les détails d'enregistrement comme ci-dessous.

image:registry_console.png[registre-global]

==== Eigenständiger Scanner.

Exécuter le scan Jenkins en mode autonome est un moyen simple de scanner les vulnérabilités des images dans le pipeline. Le scanner est appelé dynamiquement et aucune installation ou configuration du contrôleur n'est requise. C'est particulièrement utile lorsque vous scannez une image avant qu'elle ne soit poussée dans un registre. Il n'y a également aucune limite au nombre de tâches de scan pouvant être exécutées simultanément.

Pour exécuter un scan de vulnérabilités en mode autonome, le plugin Jenkins doit tirer l'image du scanner sur l'hôte sur lequel l'agent s'exécute. Vous devez donc entrer l'URL du registre {product-name} Scanner, le dépôt d'images et les informations d'identification, si nécessaire, sur la page de configuration du plugin {product-name}.

Le résultat du scan peut également être transmis au contrôleur et utilisé dans la fonction de contrôle d'admission. Dans ce cas, vous aurez besoin d'une configuration de contrôleur et devrez spécifier comment vous vous connectez au contrôleur sur la page de configuration du plugin {product-name}.

=== Configuration locale pour scanner un hôte Docker distant.

==== Conditions préalables pour un scan local sur un hôte Docker distant.

Pour {product-name} permettre de scanner une image qui n'est pas sur le même hôte que le contrôleur/allinone :

* Assurez-vous que le socket de l'API Docker Runtime est exposé via TCP.
* Ajoutez la variable d'environnement suivante au contrôleur/allinone : SCANNER_DOCKER_URL=tcp://192.168.1.10:2376

=== Projektkonfiguration

Dans votre projet, sélectionnez le plugin '{product-name} Scanner de vulnérabilités' dans le menu déroulant 'Ajouter une étape de construction'. Cochez la case "Scanner avec le scanner autonome" si vous souhaitez effectuer le scan en mode scanner autonome. Par défaut, il utilise le mode "Contrôleur & Scanner" pour effectuer le scan.

Sélectionnez Local ou un nom d'enregistrement qui est le surnom que vous avez saisi dans la configuration globale. Entrez le dépôt et le nom de la balise d'image à scanner. Vous pouvez sélectionner les variables d'environnement par défaut de Jenkins pour le dépôt ou la balise, par exemple : $JOB_NAME, $BUILD_TAG, $BUILD_NUMBER. Entrez les valeurs pour le nombre de vulnérabilités élevées ou moyennes et pour tous les noms des vulnérabilités existantes afin d'échouer la construction.

Après la fin de la construction, un rapport {product-name} sera généré. Il affichera les détails du scan et les erreurs s'il y en a.

Scénario 1 : Exemple de configuration locale

image:jenkins_local.png[local-image]

Scénario 2 : Exemple de configuration d'enregistrement

image:jenkins_registry.png[registre-local]

=== Jenkins-Pipeline

Pour le projet Jenkins Pipeline, vous pouvez écrire votre propre script de pipeline directement ou cliquer sur '\`+Syntaxe de pipeline\+`' pour générer le script si vous êtes nouveau dans la tâche de style pipeline.

image:jenkins5a.png[pipeline]

Sélectionnez le {product-name} scanner de vulnérabilités dans le menu déroulant, configurez-le et générez le script.

image:jenkins6a.png[skript]

Copiez le script dans votre script de tâche Jenkins.

Scénario 1 : Exemple d'un script de pipeline local simple (à insérer dans votre script de pipeline) :

[,shell]
----
...
  stage('Scan local image') \{
    neuvector registrySelection: 'Local', repository: 'your_username/your_image'
  \}
...
----

Scénario 2 : Exemple d'un script de pipeline d'enregistrement simple (à insérer dans votre script de pipeline) :

[,shell]
----
...
  stage('Scan local image') \{
    neuvector registrySelection: 'your_registry', repository: 'your_username/your_image'
  \}
...
----

=== Zusätzliche Schritte

Ajoutez vos propres étapes de scan d'image avant et après, par exemple dans l'exemple suivant pour la vue des étapes de pipeline.

image:jenkins7a.png[étapes]

Vous êtes maintenant prêt à démarrer vos constructions Jenkins et à déclencher le {product-name} scanner de vulnérabilités pour signaler toutes les vulnérabilités !

=== Configuration du pipeline pour construire des scans parallèles à grande échelle

Disponible avec NeuVector v5.4.3 et supérieur, le plugin Jenkins NeuVector Vulnerability Scanner v2.5 et supérieur prend en charge le scan parallèle de jusqu'à 2000 scans simultanés en mode clé API. Pour les versions antérieures de NeuVector, le nombre maximum de scans simultanés est limité à 32 en mode token. Cliquez pour développer et afficher les exemples ci-dessous pour les configurations de pipeline d'exemple.

.Utilisation de la configuration d'exemple en mode token (plugin v2.4 et inférieur, ou v2.5 et supérieur) 
[%collapsible]
====
[,groovy]
----
pipeline {
    agent any
    environment {
        REPO_NAME = 'your repo'
        REGISTRY_SELECTION = 'your registry'
        CONTROLLER = 'your controller'
        MAX_CONCURRENT_SCANS = 32
    }
    stages {
        stage('Parallel Vulnerability Scanning') {
            steps {
                script {
                    // There is a limit of 250 tags per list (by Jenkins) 
                    TAGS_LIST_PART1 = ["your tags"...]
                    TAGS_LIST_PART2 = ["your tags"...]
                    TAGS_LIST_PART3 = ["your tags"...]
                    TAGS_LIST_PART4 = ["your tags"...]
                    TAGS_LIST_PART5 = ["your tags"...]...
                    def allTags = TAGS_LIST_PART1 + TAGS_LIST_PART2 + TAGS_LIST_PART3 + TAGS_LIST_PART4 + TAGS_LIST_PART5
                    def batches = allTags.collate(MAX_CONCURRENT_SCANS.toInteger()) // Ensure MAX_CONCURRENT_SCANS is an integer
                    def batchCounter = 1                    for (batch in batches) {
                        stage("Batch ${batchCounter}") {
                            def scans = [:]
                            batch.each { tag ->
                                def currentTag = tag
                                scans["Scan ${currentTag}"] = {
                                    stage("Scan ${currentTag}") {
                                        neuvector(
                                            controllerEndpointUrlSelection: CONTROLLER,
                                            registrySelection: REGISTRY_SELECTION,
                                            repository: REPO_NAME,
                                            scanTimeout: 20,
                                            tag: "${currentTag}"
                                        )
                                        echo "Scan for tag ${currentTag} complete"
                                    }
                                }
                            }
                            parallel scans
                        }
                        batchCounter++
                    }
                }
            }
        }
    }
}
----
====

.Utilisation du mode clé API (plug-in v2.5 et ultérieur)
[%collapsible]
====
[,groovy]
----
pipeline {
    agent any
    environment {
        REPO_NAME = 'your repo'
        REGISTRY_SELECTION = 'your registry'
        CONTROLLER = 'your controller'
    }
    stages {
        stage('Parallel Vulnerability Scanning') {
            steps {
                script {
                    // There is a limit of 250 tags per list (by Jenkins) 
                    TAGS_LIST_PART1 = ["your tags"...]
                    TAGS_LIST_PART2 = ["your tags"...]
                    TAGS_LIST_PART3 = ["your tags"...]
                    TAGS_LIST_PART4 = ["your tags"...]
                    TAGS_LIST_PART5 = ["your tags"...]...
                    def allTags = TAGS_LIST_PART1 + TAGS_LIST_PART2 + TAGS_LIST_PART3 + TAGS_LIST_PART4 + TAGS_LIST_PART5
                    def scans = [:]

                    allTags.each { tag ->
                        def currentTag = tag
                        scans["Scan ${currentTag}"] = {
                            stage("Scan ${currentTag}") {
                                neuvector(
                                    controllerEndpointUrlSelection: CONTROLLER,
                                    registrySelection: REGISTRY_SELECTION,
                                    repository: REPO_NAME,
                                    scanTimeout: 20,
                                    tag: "${currentTag}"
                                )
                                echo "Scan for tag ${currentTag} complete"
                            }
                        }
                    }
                    parallel scans
                }
            }
        }
    }
}
----
====

== Exemple de routes OpenShift et de token d'enregistrement

Pour configurer le plugin avec une route OpenShift pour accéder au contrôleur, ajoutez la route dans le champ IP du contrôleur.

image:rhos_jenkins_route.png[openshift]

Pour utiliser l'authentification basée sur des jetons pour le registre OpenShift, utilisez NONAME comme utilisateur et entrez le jeton dans le champ du mot de passe.

== Cas d'utilisation spécial pour Jenkins dans le même cluster Kubernetes

Pour effectuer un scan pendant la phase de construction, où le logiciel Jenkins s'exécute dans le même cluster Kubernetes que le scanner, assurez-vous que le scanner et Jenkins sont configurés pour s'exécuter sur le même nœud. Le nœud doit être étiqueté de manière à ce que les conteneurs Jenkins et Scanner s'exécutent sur le même nœud, car le scanner a besoin d'accéder au docker.sock du nœud local pour accéder à l'image.
