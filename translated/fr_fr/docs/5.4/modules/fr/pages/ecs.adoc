= Amazon ECS
:revdate: 2024-09-27
:page-revdate: {revdate}
:page-opendocs-origin: /02.deploying/09.ecs/09.ecs.md
:page-opendocs-slug: /déployer/ecs

== Important : Le déploiement sur Amazon ECS n'est plus pris en charge

La section de référence ci-dessous n'est pas maintenue. Cependant, il peut offrir un certain soutien pour comprendre comment déployer l'All-in-One sur ECS.

== Déploiement sur AWS avec ECS

Voici un exemple de la façon de déployer {product-name} avec ECS.

[NOTE]
====
Veuillez consulter les exemples Kubernetes pour EKS.
====

. Préparez plusieurs instances Amazon ECS qui intègrent le moteur Docker et les conteneurs ECS-Agent. Sélectionnez un nœud pour la console de gestion. Définissez ensuite des règles de groupe de sécurité qui autorisent le port TCP entrant 8443 ({product-name} port standard de la console de gestion) pour l'accès via votre navigateur client.
. Définissez un groupe de sécurité qui permet les ports TCP et UDP sur 18300, 18301, 18400, 18401. Ceci est utilisé par les {product-name} agents pour communiquer avec les contrôleurs/All-in-One. Appliquez ce groupe de sécurité à toutes les instances ECS qui déploieront les agents et les contrôleurs/All-in-One {product-name}.
. Définissez un attribut pour les nœuds sur lesquels vous souhaitez déployer {product-name} All-in-One ou le conteneur de contrôleur. Par exemple, si vous souhaitez exécuter {product-name} en mode HA-Controller, il est recommandé de sélectionner au moins 3 nœuds et d'ajouter l'attribut sur les 3 nœuds.
+
--
Voici comment ajouter des attributs à vos instances ECS :

Sélectionnez l'instance, puis choisissez "\`+Afficher/Modifier les attributs\+`" dans le menu déroulant Actions.

image:1viewattributes.png[Attributs]

Ajoutez ensuite un nouvel attribut. Par exemple "\`+allinone-node\+`" avec la valeur "\`+true\+`.

image:2addattribute.png[AddAttributes]
--
. Créez la définition de tâche Allinone. Créez une nouvelle définition de tâche pour le conteneur Allinone. Vous pouvez utiliser l'interface ECS pour le créer manuellement ou insérer le fichier JSON d'exemple (voir ci-dessous pour des exemples). Référez-vous à la section "\`+1. Fournir {product-name}\+`" dans ces documents pour savoir comment configurer l'All-in-One.
+
--
Geben Sie die Platzierungsbeschränkung ein. Si vous avez utilisé le balisage d'attributs mentionné ci-dessus, entrez-le dans la contrainte.

[,json]
----
attribute:allinone-node=~true
----

image:3taskdef.png[AllinoneTask]

[NOTE]
====
Si vous vérifiez maintenant le fichier JSON mis à jour, vous verrez la contrainte de placement ajoutée.
====
--
. Créez un nouveau service pour la tâche Allinone. Définissez les "\`+modèles de placement\+`" sur "\`+Une tâche par hôte\+`", afin qu'un seul All-in-One/Contrôleur puisse s'exécuter sur n'importe quel hôte. Vous verrez également que la contrainte "`membreDe(attribut:allinone-node=~true)" est utilisée, ce qui exige que le nœud ait cet attribut.
+
--
image:3taskplacement.png[AllinonePlace]
--
. Vous pouvez maintenant déployer le service Allinone. Définissez le "\`+nombre de tâches\+`" sur le nombre souhaité d'All-in-One/Contrôleurs. Maintenant, les {product-name} conteneurs Allinone ou Contrôleur s'exécutent sur les nœuds sélectionnés. Une fois que l'All-in-One commence à fonctionner, vous devriez être en mesure de vous connecter à la console {product-name} via HTTPS sur le port 8443.
. Créez la définition de tâche Enforcer. C'est similaire à la tâche All-in-One. Configurez manuellement via la console ECS ou utilisez l'exemple JSON suivant.
+
--
Pour la restriction de placement de l'Enforcer, vous devez vous assurer que l'Enforcer n'est PAS sur le même nœud que l'All-in-One.

[,json]
----
attribute:allinone-node!~true
----

image:4enforcertask.png[EnforcerTask]
--
. Créez un nouveau service pour la tâche de l'Enforcer. Réinitialisez le placement de la tâche sur "\`+One Task Per Host\+`" afin qu'un seul Enforcer soit déployé sur chaque hôte. Notez également que la contrainte supplémentaire doit montrer qu'elle empêche le déploiement sur un nœud All-in-One.
+
--
image:5taskplacement.png[EnforcerPlacement]

Déployez ce service avec le nombre souhaité de nœuds Enforcer dans "\`+Number of tasks\+`". Très bientôt, tous les Enforcers seront opérationnels. Depuis la console {product-name}, vous pouvez voir tous les nœuds détectés avec des Enforcers.
--

== Exemples de définitions de tâches ECS JSON

Vous pouvez utiliser les exemples suivants comme point de départ pour configurer les définitions de tâches pour les conteneurs {product-name}.

Créez une nouvelle définition de tâche, puis cliquez en bas sur "Configurer via JSON". Avant d'insérer le JSON suivant, remplacez l'adresse IP et le chemin de l'image (cherchez REPLACE dans les exemples). En général, l'adresse IP serait l'adresse IP privée de l'instance AWS sur laquelle l'All-in-One est exécuté. Vous pouvez également spécifier un autre nom de famille que my-allinone/my-enforcer (en bas dans le JSON).

Exemple de fichier JSON All-in-One :

.Cliquez ici pour plus de détails
[%collapsible]
====
[,json]
----
{
    "networkMode": "bridge",
    "taskRoleArn": null,
    "pidMode": "host",
    "containerDefinitions": [
        {
            "volumesFrom": [],
            "memory": null,
            "extraHosts": null,
            "dnsServers": null,
            "disableNetworking": null,
            "dnsSearchDomains": null,
            "portMappings": [
                {
                    "hostPort": 18300,
                    "containerPort": 18300,
                    "protocol": "tcp"
                },
                {
                    "hostPort": 18301,
                    "containerPort": 18301,
                    "protocol": "tcp"
                },
                {
                    "hostPort": 18400,
                    "containerPort": 18400,
                    "protocol": "tcp"
                },
                {
                    "hostPort": 18401,
                    "containerPort": 18401,
                    "protocol": "tcp"
                },
                {
                    "hostPort": 18301,
                    "containerPort": 18301,
                    "protocol": "udp"
                },
                {
                    "hostPort": 8443,
                    "containerPort": 8443,
                    "protocol": "tcp"
                },
                {
                    "hostPort": 1443,
                    "containerPort": 10443,
                    "protocol": "tcp"
                }
            ],
            "hostname": null,
            "essential": true,
            "entryPoint": null,
            "mountPoints": [
                {
                    "containerPath": "/lib/modules",
                    "sourceVolume": "modules",
                    "readOnly": null
                },
                {
                    "containerPath": "/var/run/docker.sock",
                    "sourceVolume": "dockersock",
                    "readOnly": null
                },
                {
                    "containerPath": "/host/proc",
                    "sourceVolume": "proc",
                    "readOnly": true
                },
                {
                    "containerPath": "/host/cgroup",
                    "sourceVolume": "cgroup",
                    "readOnly": true
                }
            ],
            "name": "allinone",
            "ulimits": null,
            "dockerSecurityOptions": null,
            "environment": [
                {
                    "name": "CLUSTER_JOIN_ADDR",
                    "value": "REPLACE: Private IP"
                }
            ],
            "links": null,
            "workingDirectory": null,
            "readonlyRootFilesystem": false,
            "image": "REPLACE: Image Path/Name",
            "command": null,
            "user": null,
            "dockerLabels": {
                "com.myself.name": "neuvector"
            },
            "logConfiguration": null,
            "cpu": 0,
            "privileged": true,
            "memoryReservation": 768
        }
    ],
    "volumes": [
        {
            "host": {
                "sourcePath": "/lib/modules"
            },
            "name": "modules"
        },
        {
            "host": {
                "sourcePath": "/var/run/docker.sock"
            },
            "name": "dockersock"
        },
        {
            "host": {
                "sourcePath": "/proc"
            },
            "name": "proc"
        },
        {
            "host": {
                "sourcePath": "/sys/fs/cgroup"
            },
            "name": "cgroup"
        }
    ],
    "family": "my-allinone",
    "placementConstraints": []
}
----
====

Exemple de fichier JSON Enforcer :

.Cliquez ici pour plus de détails
[%collapsible]
====
[,json]
----
{
    "networkMode": "bridge",
    "taskRoleArn": null,
    "pidMode": "host",
    "containerDefinitions": [
        {
            "volumesFrom": [],
            "memory": null,
            "extraHosts": null,
            "dnsServers": null,
            "disableNetworking": null,
            "dnsSearchDomains": null,
            "portMappings": [
                {
                    "hostPort": 18301,
                    "containerPort": 18301,
                    "protocol": "tcp"
                },
                {
                    "hostPort": 18401,
                    "containerPort": 18401,
                    "protocol": "tcp"
                },
                {
                    "hostPort": 18301,
                    "containerPort": 18301,
                    "protocol": "udp"
                }
            ],
            "hostname": null,
            "essential": true,
            "entryPoint": null,
            "mountPoints": [
                {
                    "containerPath": "/lib/modules",
                    "sourceVolume": "modules",
                    "readOnly": null
                },
                {
                    "containerPath": "/var/run/docker.sock",
                    "sourceVolume": "dockersock",
                    "readOnly": null
                },
                {
                    "containerPath": "/host/proc",
                    "sourceVolume": "proc",
                    "readOnly": true
                },
                {
                    "containerPath": "/host/cgroup",
                    "sourceVolume": "cgroup",
                    "readOnly": true
                }
            ],
            "name": "enforcer",
            "ulimits": null,
            "dockerSecurityOptions": null,
            "environment": [
                {
                    "name": "CLUSTER_JOIN_ADDR",
                    "value": "REPLACE: Private IP"
                }
            ],
            "links": null,
            "workingDirectory": null,
            "readonlyRootFilesystem": false,
            "image": "REPLACE: Image Path/Name",
            "command": null,
            "user": null,
            "dockerLabels": {
                "com.myself.name": "neuvector"
            },
            "logConfiguration": null,
            "cpu": 0,
            "privileged": true,
            "memoryReservation": 512
        }
    ],
    "volumes": [
        {
            "host": {
                "sourcePath": "/lib/modules"
            },
            "name": "modules"
        },
        {
            "host": {
                "sourcePath": "/var/run/docker.sock"
            },
            "name": "dockersock"
        },
        {
            "host": {
                "sourcePath": "/proc"
            },
            "name": "proc"
        },
        {
            "host": {
                "sourcePath": "/sys/fs/cgroup"
            },
            "name": "cgroup"
        }
    ],
    "family": "my-enforcer",
    "placementConstraints": []
}
----
====

== Mise à jour en direct {product-name}

Vous pouvez effectuer une mise à jour en direct des {product-name} conteneurs dans ECS sans interrompre les services. Les {product-name} services peuvent être mis à jour ou améliorés sans interrompre les services en cours. Pour ce faire dans Amazon ECS :

. Si vous avez déployé plusieurs contrôleurs ou All-in-One en tant que cluster, passez cette étape. S'il n'y a qu'un seul All-in-One/Contrôleur dans le système, trouvez une nouvelle instance ECS et déployez un 2. Conteneur All-in-One/Contrôleur dessus (suivez les étapes de déploiement pour ECS All-in-One/Contrôleur {product-name}). Après le déploiement, vous verrez dans la console de gestion {product-name} ce nouveau contrôleur opérationnel (sous Ressources > Contrôleur). C'est nécessaire pour que toutes les données d'état soient répliquées entre les contrôleurs.
. Réinitialisez et supprimez l'ancien service All-in-One/Contrôleur dans les services ECS. Tirez manuellement les images {product-name} mises à jour ou déclenchez AWS ECS pour tirer de nouvelles versions des conteneurs All-in-One/Contrôleur depuis Dockerhub ou votre dépôt privé.
. Créez une nouvelle révision de la tâche All-in-One/Contrôleur, mettez à jour le "\`+CLUSTER_JOIN_ADDR\+`" avec l'adresse IP du nœud privé du 2. All-in-One/Contrôleurs.
. Créez un nouveau service pour déployer cette nouvelle tâche (suivez les mêmes étapes de déploiement sur ECS). Une fois cela terminé, la nouvelle version de l'All-in-One/Contrôleur devrait être opérationnelle. Depuis la console de gestion {product-name}, tous les journaux et politiques devraient toujours être présents. Optionnellement, vous pouvez maintenant arrêter le 2. Conteneur All-in-One/Contrôleur, car l'All-in-One/Contrôleur devrait maintenant être démarré sur le nœud d'origine.
. Arrêtez et mettez à jour les Enforcers des services ECS. Tirez manuellement ou automatiquement les nouvelles images des Enforcers. Redémarrez ou mettez ensuite à jour l'Enforcer sur tous les nœuds. Depuis la console {product-name}, vous pouvez voir que tous les Enforcers sont à jour.
. Si vous utilisez le conteneur de gestion séparé au lieu de l'All-in-One (qui a déjà le gestionnaire), arrêtez et supprimez simplement l'ancien conteneur de gestion. Ensuite, tirez la nouvelle version du gestionnaire et déployez-la en pointant CLUSTER_JOIN_ADDR vers l'IP du contrôleur.

Tous les conteneurs {product-name} sont maintenant mis à jour en direct. Toutes les politiques, journaux et configurations ne sont pas affectés. La vue du diagramme en direct est automatiquement régénérée dès que de nouveaux flux de trafic en direct circulent entre les conteneurs.
