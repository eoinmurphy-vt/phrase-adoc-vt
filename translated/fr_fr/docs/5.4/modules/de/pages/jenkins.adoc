= Détails de Jenkins
:revdate: 2025-05-05
:page-revdate: {revdate}
:page-opendocs-origin: /06.scanning/03.build/01.jenkins/01.jenkins.md
:page-opendocs-slug:  /scanning/build/jenkins

== Configuration détaillée pour le plugin Jenkins

Les conteneurs offrent un moyen simple et efficace de déployer des applications. Mais les images de conteneurs peuvent contenir du code open-source sur lequel vous n'avez pas un contrôle total. De nombreuses vulnérabilités dans les projets open-source ont été signalées, et vous pouvez décider si vous souhaitez utiliser ces bibliothèques avec des vulnérabilités ou non, après avoir scanné les images et vérifié les informations sur les vulnérabilités pour celles-ci.

Le plugin Jenkins {product-name} Vulnerability Scanner peut scanner les images après que votre image a été créée dans Jenkins. Le code source du plugin et la documentation la plus récente peuvent être trouvés https://github.com/jenkinsci/neuvector-vulnerability-scanner-plugin[ici] sur la page {product-name} GitHub.

Le plugin prend en charge deux modes de scan. Le premier est le mode "Contrôleur & Scanner". Le second est le mode Scanner autonome. Vous pouvez sélectionner le mode de scan sur la page de configuration du projet. Par défaut, il utilise le mode "Contrôleur & Scanner".

Pour le mode "Contrôleur & Scanner", vous devez déployer le {product-name} Contrôleur et Scanner sur le réseau. Pour scanner l'image locale (l'image sur la machine Jenkins), le "Contrôleur & Scanner" doit être installé sur le même nœud où l'image existe.

Pour le mode Scanner autonome, le runtime Docker doit être installé sur le même hôte que Jenkins. Ajoutez également l'utilisateur Jenkins au groupe Docker.

[,bash]
----
sudo usermod -aG docker jenkins
----

=== Jenkins-Plugin-Installation

Tout d'abord, allez dans votre navigateur à Jenkins pour rechercher le {product-name} plugin. Cela peut être trouvé dans:

-> Gérer Jenkins -> Gérer les plugins -> Disponible -> Filtrer -> Recherche `+{product-name} Vulnerability Scanner+` ->

Sélectionnez-le et cliquez sur `+install without restart.+`

Déployez le {product-name} conteneur de contrôleur et de scanner, si vous ne l'avez pas encore fait sur un hôte accessible par le serveur Jenkins. Cela peut se faire sur le même serveur que Jenkins, si désiré. Notez l'adresse IP de l'hôte sur lequel le contrôleur fonctionne. Remarque : Le port API REST par défaut est 10443. Ce port doit être ouvert via Allinone ou le contrôleur par un service dans Kubernetes ou un mappage de port (par exemple, - 10443:10443) dans le fichier Docker-Run ou Compose.

Assurez-vous également qu'un {product-name} conteneur de scanner autonome est déployé et configuré pour se connecter au contrôleur (si le contrôleur est utilisé).

Il existe deux scénarios pour le scan d'images : le scan local et le scan des registries.

. *Scan d'image local*. Si vous utilisez le plugin pour scanner des images locales (avant de les télécharger dans les registries), vous pouvez scanner sur le même hôte que le contrôleur/scanner ou configurer le scanner pour accéder à l'engine Docker sur un hôte distant.
. *Scan d'image de registry*. Si vous utilisez le plugin pour scanner des images de registry (après les avoir téléchargées dans les registries, mais dans le cadre du processus de construction Jenkins), le {product-name} scanner peut être installé sur n'importe quel nœud du réseau qui a une connexion entre la registry, le {product-name} scanner et Jenkins.

=== Configuration globale dans Jenkins

Après l'installation du plugin, vous trouverez la section '\`+{product-name} Scanner de vulnérabilités\+`' sur la page de configuration globale (Jenkins '\`+Configurer le système\+`'). Entrez les valeurs pour l'adresse IP du {product-name} contrôleur, le port, le nom d'utilisateur et le mot de passe. Vous pouvez cliquer sur le bouton '\`+Tester la connexion\+`' pour valider les valeurs. Un message '\`+Succès de la connexion\+`' ou un message d'erreur s'affichera.

La valeur de délai d'attente termine l'étape de construction dans le temps saisi. La valeur par défaut de 0 signifie qu'aucun délai d'attente ne se produit.

Cliquez sur la '\`+Ajouter un registre\+`', pour entrer des valeurs pour le registre que vous utiliserez dans votre projet. Si vous ne scannez que des images locales, vous n'avez pas besoin d'ajouter de registre ici.

Scénario 1 : Exemple de configuration globale pour scanner des images locales

image:jenkins1a.png[global-image]

Scénario 2 : Exemple de configuration globale pour scanner des images de registre

Pour la configuration globale du registre, suivez les instructions ci-dessus pour local et ajoutez ensuite les détails du registre comme ci-dessous.

image:registry_console.png[registre-global]

==== Scanner autonome

Exécuter le scan Jenkins en mode autonome est un moyen simple de scanner les vulnérabilités des images dans le pipeline. Le scanner est appelé dynamiquement et aucune installation de la configuration du contrôleur n'est requise. C'est particulièrement utile lorsque vous scannez une image avant de la télécharger dans un registre. Il n'y a également aucune limite au nombre de tâches de scan pouvant être exécutées simultanément.

Pour exécuter un scan de vulnérabilités en mode autonome, le plugin Jenkins doit tirer l'image du scanner sur l'hôte sur lequel l'agent s'exécute. Par conséquent, vous devez entrer l'URL du registre du scanner {product-name}, le dépôt d'images et les informations d'identification, si nécessaire, sur la page de configuration du plugin {product-name}.

Le résultat du scan peut également être transmis au contrôleur et utilisé dans la fonction de contrôle d'approbation. Dans ce cas, vous aurez besoin d'une configuration de contrôleur et devrez indiquer comment vous vous connectez au contrôleur sur la page de configuration du plugin {product-name}.

=== Configuration locale pour scanner un hôte Docker distant

==== Conditions requises pour l'analyse locale sur un hôte Docker distant

Pour activer {product-name} afin de scanner une image qui n'est pas sur le même hôte que le contrôleur/allinone :

* Assurez-vous que le socket API de Docker Runtime est exposé via TCP.
* Ajoutez la variable d'environnement suivante au contrôleur/allinone : SCANNER_DOCKER_URL=tcp://192.168.1.10:2376

=== Projektkonfiguration

Dans votre projet, sélectionnez le plugin '{product-name} Scanner de vulnérabilités' dans le menu déroulant 'Ajouter une étape de construction'. Cochez la case "Scanner avec le scanner autonome" si vous souhaitez effectuer l'analyse en mode scanner autonome. Par défaut, il utilise le mode "Contrôleur & Scanner" pour effectuer l'analyse.

Sélectionnez Local ou un nom de registre qui est le surnom que vous avez saisi dans la configuration globale. Entrez le nom du dépôt et le tag de l'image à scanner. Vous pouvez choisir les variables d'environnement par défaut de Jenkins pour le dépôt ou le tag, par exemple $JOB_NAME, $BUILD_TAG, $BUILD_NUMBER. Entrez les valeurs pour le nombre de vulnérabilités élevées ou moyennes et pour chaque nom de vulnérabilité existante afin de faire échouer le build.

À la fin du build, un rapport {product-name} sera généré. Il affichera les détails de l'analyse et les erreurs, le cas échéant.

Scénario 1 : Exemple de configuration locale

image:jenkins_local.png[local-image]

Scénario 2 : Exemple de configuration de registre

image:jenkins_registry.png[registre-local]

=== Pipeline Jenkins

Pour le projet de pipeline Jenkins, vous pouvez écrire votre propre script de pipeline directement ou cliquer sur '\`+syntaxe de pipeline\+`'' pour générer le script si vous êtes nouveau dans la tâche de style pipeline.

image:jenkins5a.png[pipeline]

Sélectionnez le {product-name} scanner de vulnérabilités dans le menu déroulant, configurez-le et générez le script.

image:jenkins6a.png[Skript]

Copiez le script dans votre script de tâche Jenkins.

Scénario 1 : Exemple simple d'un script de pipeline local (à insérer dans votre script de pipeline) :

[,shell]
----
...
  stage('Scan local image') \{
    neuvector registrySelection: 'Local', repository: 'your_username/your_image'
  \}
...
----

Scénario 2 : Exemple simple d'un script de pipeline de registre (à insérer dans votre script de pipeline) :

[,shell]
----
...
  stage('Scan local image') \{
    neuvector registrySelection: 'your_registry', repository: 'your_username/your_image'
  \}
...
----

=== Zusätzliche Stufen

Ajoutez vos propres étapes de scan d'image avant et après, par exemple dans l'exemple de la vue des étapes de pipeline ci-dessous.

image:jenkins7a.png[stages]

Vous êtes maintenant prêt à démarrer vos constructions Jenkins et à déclencher le {product-name} scanner de vulnérabilités pour signaler toutes les vulnérabilités !

=== Configuration de la pipeline pour effectuer des scans parallèles à grande échelle

Disponible avec NeuVector v5.4.3 et ultérieur, le plugin Jenkins NeuVector Vulnerability Scanner v2.5 et ultérieur prend en charge le scan parallèle de jusqu'à 2000 scans simultanés en mode clé API. Pour les versions antérieures de NeuVector, le nombre maximal de scans simultanés est limité à 32 en mode token. Cliquez ici pour développer les exemples ci-dessous et afficher les configurations de pipeline d'exemple.

.Configuration d'exemple en mode token (plugin v2.4 et inférieur ou v2.5 et ultérieur) 
[%collapsible]
====
[,groovy]
----
pipeline {
    agent any
    environment {
        REPO_NAME = 'your repo'
        REGISTRY_SELECTION = 'your registry'
        CONTROLLER = 'your controller'
        MAX_CONCURRENT_SCANS = 32
    }
    stages {
        stage('Parallel Vulnerability Scanning') {
            steps {
                script {
                    // There is a limit of 250 tags per list (by Jenkins) 
                    TAGS_LIST_PART1 = ["your tags"...]
                    TAGS_LIST_PART2 = ["your tags"...]
                    TAGS_LIST_PART3 = ["your tags"...]
                    TAGS_LIST_PART4 = ["your tags"...]
                    TAGS_LIST_PART5 = ["your tags"...]...
                    def allTags = TAGS_LIST_PART1 + TAGS_LIST_PART2 + TAGS_LIST_PART3 + TAGS_LIST_PART4 + TAGS_LIST_PART5
                    def batches = allTags.collate(MAX_CONCURRENT_SCANS.toInteger()) // Ensure MAX_CONCURRENT_SCANS is an integer
                    def batchCounter = 1                    for (batch in batches) {
                        stage("Batch ${batchCounter}") {
                            def scans = [:]
                            batch.each { tag ->
                                def currentTag = tag
                                scans["Scan ${currentTag}"] = {
                                    stage("Scan ${currentTag}") {
                                        neuvector(
                                            controllerEndpointUrlSelection: CONTROLLER,
                                            registrySelection: REGISTRY_SELECTION,
                                            repository: REPO_NAME,
                                            scanTimeout: 20,
                                            tag: "${currentTag}"
                                        )
                                        echo "Scan for tag ${currentTag} complete"
                                    }
                                }
                            }
                            parallel scans
                        }
                        batchCounter++
                    }
                }
            }
        }
    }
}
----
====

.Utilisation du mode clé API (plugin v2.5 et ultérieur)
[%collapsible]
====
[,groovy]
----
pipeline {
    agent any
    environment {
        REPO_NAME = 'your repo'
        REGISTRY_SELECTION = 'your registry'
        CONTROLLER = 'your controller'
    }
    stages {
        stage('Parallel Vulnerability Scanning') {
            steps {
                script {
                    // There is a limit of 250 tags per list (by Jenkins) 
                    TAGS_LIST_PART1 = ["your tags"...]
                    TAGS_LIST_PART2 = ["your tags"...]
                    TAGS_LIST_PART3 = ["your tags"...]
                    TAGS_LIST_PART4 = ["your tags"...]
                    TAGS_LIST_PART5 = ["your tags"...]...
                    def allTags = TAGS_LIST_PART1 + TAGS_LIST_PART2 + TAGS_LIST_PART3 + TAGS_LIST_PART4 + TAGS_LIST_PART5
                    def scans = [:]

                    allTags.each { tag ->
                        def currentTag = tag
                        scans["Scan ${currentTag}"] = {
                            stage("Scan ${currentTag}") {
                                neuvector(
                                    controllerEndpointUrlSelection: CONTROLLER,
                                    registrySelection: REGISTRY_SELECTION,
                                    repository: REPO_NAME,
                                    scanTimeout: 20,
                                    tag: "${currentTag}"
                                )
                                echo "Scan for tag ${currentTag} complete"
                            }
                        }
                    }
                    parallel scans
                }
            }
        }
    }
}
----
====

== Exemple de route OpenShift et de token de registre

Pour configurer le plugin avec une route OpenShift pour accéder au contrôleur, ajoutez la route dans le champ IP du contrôleur.

image:rhos_jenkins_route.png[openshift]

Pour utiliser l'authentification basée sur un token pour le registre OpenShift, utilisez NONAME comme utilisateur et entrez le token dans le mot de passe.

== Cas d'utilisation particulier pour Jenkins dans le même cluster Kubernetes

Pour effectuer des analyses pendant la phase de construction, où le logiciel Jenkins s'exécute dans le même cluster Kubernetes que le scanner, assurez-vous que le scanner et Jenkins s'exécutent sur le même nœud. Le nœud doit être étiqueté afin que les conteneurs Jenkins et Scanner s'exécutent sur le même nœud, car le scanner a besoin d'accéder au docker.sock du nœud local pour accéder à l'image.
