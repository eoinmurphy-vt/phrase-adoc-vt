= Ersetzen von internen Zertifikaten
:revdate: 2025-01-27
:page-revdate: {revdate}
:page-opendocs-origin: /02.deploying/01.production/04.internal/04.internal.md
:page-opendocs-slug: /deploying/production/internal

[IMPORTANT]
====
NeuVector Versionen 5.4.2 und später müssen die Benutzer interne Zertifikate generieren/ersetzen, bevor sie NeuVector verwenden.
Nach März 2025 müssen Benutzer von NeuVector-Versionen vor 5.4.2 interne Zertifikate generieren/ersetzen, bevor sie NeuVector verwenden.
====

== Interne Kommunikation und Bescheinigungen

{product-name} enthält standardmäßig selbstsignierte Zertifikate für die Verschlüsselung der Kommunikation von Manager (Konsole/UI-Zugriff), Controller (REST-API, intern), Enforcer (intern) und Scanner (intern).

Diese Bescheinigungen können durch Ihre eigenen ersetzt werden, um die Kommunikation weiter zu festigen. Zum Ersetzen von Zertifikaten, die für den externen Zugriff auf {product-name} verwendet werden (d. h. Browser zum Manager oder REST-API zum Controller), lesen Sie bitte xref:replacecert.adoc[diesen Abschnitt]. Siehe unten zum Ersetzen der Zertifikate, die in der internen Kommunikation zwischen {product-name} Containern verwendet werden.

[WARNING]
====
Es wird empfohlen, die Zertifikate nur bei der erstmaligen Bereitstellung von {product-name} zu ersetzen. Das Ersetzen in einem laufenden Cluster (auch mit rollierendem Upgrade) kann zu einem instabilen Zustand führen, in dem {product-name} Pods aufgrund von nicht übereinstimmenden Zertifikaten nicht miteinander kommunizieren können, und es kann zu Datenverlusten kommen.
====

=== Ersetzen von Zertifikaten, die in der internen Kommunikation von {product-name}

Ersetzen Sie die internen Verschlüsselungsdateien `+ca.crt+`, `+tls.key+`, `+tls.crt+` wie folgt:

* Erstellen Sie eine neue Datei `+ca.cfg+` mit Ihrem bevorzugten Editor:

[,shell]
----
[req]
distinguished_name = req_distinguished_name
x509_extensions = v3_req
prompt = no
[req_distinguished_name]
C = US
ST = California
L = San Jose
O = {product-name} Inc.
OU = Neuvector
CN = Neuvector
[v3_req]
keyUsage = digitalSignature, keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth, clientAuth
subjectAltName = @alt_names
[alt_names]
DNS.1 = Neuvector
----

[IMPORTANT]
====
Weitere Informationen über `+ca.cfg+` finden Sie unter https://open-docs.neuvector.com/configuration/console/replacecert.
====

* Wählen Sie Ihr Szenario aus den untenstehenden Optionen aus:

[tabs]
========
Neues Zertifikat::
+
Wenn Ihr Zertifikat demnächst abläuft und Sie ein neues generieren müssen, gehen Sie wie folgt vor:
+
* Löschen Sie die alten `+ca.crt+`, `+tls.key+`, `+tls.crt+`, kubernetes secret, und erzeugen Sie neue:
+
[source,bash]
----
kubectl delete secret internal-cert -n neuvector 
openssl genrsa -out ca.key 2048 
openssl req -x509 -sha256 -new -nodes -key ca.key -days 3650 -out ca.crt 
openssl genrsa -out tls.key 2048 
openssl req -new -key tls.key -sha256 -out cert.csr -config ca.cfg 
openssl req -in cert.csr -noout -text 
openssl x509 -req -sha256 -in cert.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out tls.crt -days 3650 -extensions 'v3_req' -extfile ca.cfg 
openssl x509 -in tls.crt -text 
kubectl create secret generic internal-cert -n neuvector --from-file=tls.key --from-file=tls.crt --from-file=ca.crt
----
+
* Bearbeiten Sie dann die Verteilungsjournale für Controller, Enforcer und Scanner und fügen Sie sie hinzu:
+
[source,yaml]
----
      containers:
        - name: neuvector-controller/enforcer/scanner-pod
          volumeMounts:
            - mountPath: /etc/neuvector/certs/internal/cert.key
              name: internal-cert
              readOnly: true
              subPath: tls.key
            - mountPath: /etc/neuvector/certs/internal/cert.pem
              name: internal-cert
              readOnly: true
              subPath: tls.crt
            - mountPath: /etc/neuvector/certs/internal/ca.cert
              name: internal-cert
              readOnly: true
              subPath: ca.crt
      volumes:
        - name: internal-cert
          secret:
            defaultMode: 420
            secretName: internal-cert
----
+
Fahren Sie dann mit der Bereitstellung von {product-name} wie zuvor fort. Sie können sich auch in die Controller/Enforcer/Scanner-Pods einklinken, um zu überprüfen, ob die Dateien ca.crt, tls.key und tls.crt die angepassten Dateien sind und ob die Kommunikation mit {product-name} mit den neuen Zertifikaten funktioniert.
+
Beispiel-Patch-Befehle für Controller (ändern Sie den Namensraum in cattle-neuvector-system, falls erforderlich, und ändern Sie ihn für die Verwendung auf Enforcer und Scanner)
+
[source,bash]
----
NAMESPACE=neuvector

kubectl patch deployment -n $\{NAMESPACE} neuvector-controller-pod --type='json' -p='[{"op": "add", "path": "/spec/template/spec/volumes/-", "value": {"name": "internal-cert", "secret": {"defaultMode": 420, "secretName": "internal-cert"}} } ]'

kubectl patch deployment -n $\{NAMESPACE} neuvector-controller-pod --type='json' -p='[{"op": "add", "path": "/spec/template/spec/containers/0/volumeMounts", "value": [{"mountPath": "/etc/neuvector/certs/internal/cert.key", "name": "internal-cert", "readOnly": true, "subPath": "cert.key"}, {"mountPath": "/etc/neuvector/certs/internal/cert.pem", "name": "internal-cert", "readOnly": true, "subPath": "cert.pem"}, {"mountPath": "/etc/neuvector/certs/internal/ca.cert", "name": "internal-cert", "readOnly": true, "subPath": "ca.cert"} ] } ]'
----

Aktuelles Zertifikat mit SANs aktualisieren::
+
Wenn Ihre Zertifikatsdateien vor {product-name} Version 5.3 erstellt wurden, müssen Sie das Zertifikat mit mindestens einem Subject Alternative Name, kurz SAN, aktualisieren. Wenn Sie noch Zugriff auf die Dateien `+ca.key+` und `+ca.crt+` haben, führen Sie die Befehle wie folgt aus:
+
[source,bash]
----
kubectl delete secret internal-cert -n neuvector 
openssl genrsa -out tls.key 2048 
openssl req -new -key tls.key -sha256 -out cert.csr -config ca-new.cfg 
openssl req -in cert.csr -noout -text 
openssl x509 -req -sha256 -in cert.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out tls.crt -days 3650 -extensions 'v3_req' -extfile ca-new.cfg 
openssl x509 -in tls.crt -text 
kubectl create secret generic internal-cert -n neuvector --from-file=tls.key --from-file=tls.crt --from-file=ca.crt
----
+
Sobald die Zertifikatsdateien aktualisiert wurden, starten Sie die Bereitstellungen neu, um das aktualisierte Zertifikat zu verwenden: 
+
[source,bash]
----
kubectl rollout restart deployment neuvector-controller-pod 
kubectl rollout restart deployment neuvector-scanner-pod 
kubectl rollout restart deployment neuvector-registry-adapter-pod 
kubectl rollout restart ds neuvector-enforcer-pod
----

Zertifikatsdateien neu generieren und SANs hinzufügen::
+
Wenn Ihre Zertifikatsdateien vor {product-name} Version 5.3 erstellt wurden, müssen Sie das Zertifikat mit mindestens einem Subject Alternative Name, kurz SAN, aktualisieren. Wenn Sie die Dateien `+ca.key+` und `+ca.crt+` nicht mehr haben, folgen Sie den nachstehenden Schritten: 
+
* Sichern Sie Ihr Originalzertifikat 
+
[source,bash]
----
kubectl get secret internal-cert -o yaml > internal-cert.yaml
----
+
* Exportieren Sie das vorhandene interne Zertifikat
+
[source,bash]
----
kubectl get secret internal-cert -o json | jq -r '.data."ca.crt"' | base64 -d > old-ca.crt 
kubectl get secret internal-cert -o json | jq -r '.data."tls.crt"' | base64 -d > old-tls.crt 
kubectl get secret internal-cert -o json | jq -r '.data."tls.key"' | base64 -d > old-tls.key 
----
+
* Neue Zertifikatsdateien und interne Zertifikate erstellen 
+
[source,bash]
----
openssl genrsa -out ca.key 2048 
openssl req -x509 -sha256 -new -nodes -key ca.key -days 3650 -out ca.crt 
openssl genrsa -out tls.key 2048 
openssl req -new -key tls.key -sha256 -out cert.csr -config ca.cfg 
openssl req -in cert.csr -noout -text 
openssl x509 -req -sha256 -in cert.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out tls.crt -days 3650 -extensions 'v3_req' -extfile ca.cfg 
openssl x509 -in tls.crt -text 
----
+
* Zusammenführen der alten und neuen `+ca.crt+` Dateien 
+
[source,bash]
----
cat old-ca.crt > /tmp/ca.crt cat ca.crt >> /tmp/ca.crt 
----
+
* Aktualisieren Sie das Kubernetes-Geheimnis mit der zusammengeführten `+ca.crt+`
+
[source,bash]
----
kubectl delete secret internal-cert -n neuvector 
kubectl create secret generic internal-cert -n neuvector --from-file=tls.key=old-tls.key --from-file=tls.crt=old-tls.crt --from-file=ca.crt=/tmp/ca.crt 
----
+
* Starten Sie die Bereitstellungen neu, um das aktualisierte Zertifikat zu verwenden 
+
[source,bash]
----
kubectl rollout restart deployment neuvector-controller-pod 
kubectl rollout restart deployment neuvector-scanner-pod 
kubectl rollout restart deployment neuvector-registry-adapter-pod 
kubectl rollout restart ds neuvector-enforcer-pod 
----
+
* Warten, bis der Neustart abgeschlossen ist 
+
[source,bash]
----
kubectl rollout status deployment neuvector-controller-pod 
kubectl rollout status deployment neuvector-scanner-pod 
kubectl rollout status deployment neuvector-registry-adapter-pod 
kubectl rollout status ds neuvector-enforcer-pod 
----
+
* Stellen Sie sicher, dass auf die Konsole zugegriffen werden kann und alle Controller online sind * Aktualisieren Sie das Kubernetes-Geheimnis mit dem neuen `+tls.key+` 
+
[source,bash]
----
kubectl delete secret internal-cert -n neuvector 
kubectl create secret generic internal-cert -n neuvector --from-file=tls.key=tls.key --from-file=tls.crt=tls.crt --from-file=ca.crt=/tmp/ca.crt 
----
+
* Starten Sie die Bereitstellungen neu, um das aktualisierte Zertifikat zu verwenden 
+
[source,bash]
----
kubectl rollout restart deployment neuvector-controller-pod 
kubectl rollout restart deployment neuvector-scanner-pod 
kubectl rollout restart deployment neuvector-registry-adapter-pod 
kubectl rollout restart ds neuvector-enforcer-pod 
----
+
* Warten, bis der Neustart abgeschlossen ist 
+
[source,bash]
----
kubectl rollout status deployment neuvector-controller-pod
kubectl rollout status deployment neuvector-scanner-pod
kubectl rollout status deployment neuvector-registry-adapter-pod
kubectl rollout status ds neuvector-enforcer-pod 
----
+
* Stellen Sie sicher, dass auf die Konsole zugegriffen werden kann und alle Controller online sind * Aktualisieren Sie das Kubernetes-Geheimnis mit dem neuen `+ca.crt+` 
+
[source,bash]
----
kubectl delete secret internal-cert -n neuvector
kubectl create secret generic internal-cert -n neuvector --from-file=tls.key=tls.key --from-file=tls.crt=tls.crt --from-file=ca.crt=ca.crt 
----
+
* Starten Sie die Bereitstellungen neu, um das aktualisierte Zertifikat zu verwenden 
+
[source,bash]
----
kubectl rollout restart deployment neuvector-controller-pod
kubectl rollout restart deployment neuvector-scanner-pod
kubectl rollout restart deployment neuvector-registry-adapter-pod
kubectl rollout restart ds neuvector-enforcer-pod 
----
+
* Warten, bis der Neustart abgeschlossen ist 
+
[source,bash]
----
kubectl rollout status deployment neuvector-controller-pod
kubectl rollout status deployment neuvector-scanner-pod
kubectl rollout status deployment neuvector-registry-adapter-pod
kubectl rollout status ds neuvector-enforcer-pod 
----
+
* Vergewissern Sie sich, dass auf die Konsole zugegriffen werden kann und dass alle Steuergeräte online sind.

Zertifikat neu generieren, wenn das integrierte Zertifikat verwendet wird::
+
Wenn Sie das interne Zertifikat noch nicht ersetzt haben und auf einen neuen Satz von Zertifikaten migrieren möchten, führen Sie die folgenden Schritte aus:
+
* Prüfen Sie, ob Sie das interne Zertifikat bereits automatisch generiert haben.
+
[source,bash]
----
kubectl get secret internal-cert -o yaml
----
+
Wenn Sie dort `+tls.key+`, `+tls.crt+` und `+ca.crt+` sehen, bedeutet dies, dass Sie das automatisch generierte Zertifikat verwendet haben und diesen Abschnitt überspringen können.
+
Wenn Sie die Geheimnisse sehen, aber nicht finden können, sollten Sie in Erwägung ziehen, `+internal.autoRotateCert+` in den Steuerkarten zu aktivieren. Mit dieser Option wird Ihr internes Zertifikat automatisch generiert und rotiert.
+
Wenn Sie das automatisch generierte interne Zertifikat nicht verwenden und dies nicht möglich ist, führen Sie die folgenden Schritte aus:
+
* Befolgen Sie die Schritte auf der Registerkarte `+New certificate+`, um ein Kubernetes-Geheimnis zur Verwaltung des internen Zertifikats zu verwenden. Anstatt ein neues Zertifikat zu erstellen, verwenden Sie die unten abgerufenen Zertifikate `+old-ca.crt+`, `+old-tls.crt+` und `+old-tls.key+`:
+
[source,shell]
----
docker run -it --entrypoint=bash neuvector/scanner:3.654 -c "cat /etc/neuvector/certs/internal/ca.cert" > old-ca.crt
docker run -it --entrypoint=bash neuvector/scanner:3.654 -c "cat /etc/neuvector/certs/internal/cert.pem" > old-tls.crt
docker run -it --entrypoint=bash neuvector/scanner:3.654 -c "cat /etc/neuvector/certs/internal/cert.key" > old-tls.key
----
+
* Stellen Sie sicher, dass alle Komponenten fehlerfrei laufen.
+
* Folgen Sie dann den Schritten auf der Registerkarte `+Regenerate certificate files and add SANs+` und migrieren Sie zu Ihrem eigenen Zertifikat.

========

=== Aktualisierung/Verteilung mit Helm

Ab Helm Chart `+2.4.1+` können wir jetzt die interne Zertifikatsinstallation verwalten. Die Tabelle https://github.com/neuvector/neuvector-helm/blob/master/charts/core/values.yaml[values.yaml] sollte auf alle Einstellungen hin überprüft werden. Das folgende Beispiel verwendet RKE2, Standard-Ingress- und Installateur-Zertifikate.

[,bash]
----
# add chart
helm repo add neuvector https://neuvector.github.io/neuvector-helm/

# update chart
helm repo update

# add domain for ingress
export domain=awesome.sauce

# run the helm
helm upgrade -i neuvector -n neuvector neuvector/core --create-namespace  --set imagePullSecrets=regsecret --set k3s.enabled=true --set k3s.runtimePath=/run/k3s/containerd/containerd.sock --set manager.ingress.enabled=true --set manager.ingress.host=neuvector.$domain --set manager.svc.type=ClusterIP --set controller.pvc.enabled=true --set controller.pvc.capacity=500Mi --set controller.internal.certificate.secret=internal-cert --set cve.scanner.internal.certificate.secret=internal-cert --set enforcer.internal.certificate.secret=internal-cert
----
