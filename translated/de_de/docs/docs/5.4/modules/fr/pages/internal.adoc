= Ersetzung der internen Zertifikate
:revdate: 2025-01-27
:page-revdate: {revdate}
:page-opendocs-origin: /02.deploying/01.production/04.internal/04.internal.md
:page-opendocs-slug: /déploiement/production/interne

[IMPORTANT]
====
Die Versionen von NeuVector 5.4.2 und höher müssen die Benutzer dazu bringen, die internen Zertifikate zu generieren/ersetzen, bevor sie NeuVector verwenden.
Nach März 2025 müssen die Versionen von NeuVector vor 5.4.2 die Benutzer dazu bringen, die internen Zertifikate zu generieren/ersetzen, bevor sie NeuVector verwenden.
====

== Interne Kommunikation und Zertifikate

{product-name} enthält standardmäßig selbstsignierte Zertifikate für die Verschlüsselung für den Manager (Konsolen-/UI-Zugriff), den Controller (REST-API, intern), den Enforcer (intern) und die Kommunikation des Scanners (intern).

Diese Zertifikate können durch Ihre eigenen ersetzt werden, um die Kommunikation weiter zu sichern. Um die Zertifikate zu ersetzen, die für den externen Zugriff auf {product-name} verwendet werden (d.h. Browser zum Manager oder REST-API zum Controller), konsultieren Sie bitte xref:replacecert.adoc[dieser Abschnitt]. Siehe unten, um die Zertifikate zu ersetzen, die in der internen Kommunikation zwischen den Containern {product-name} verwendet werden.

[WARNING]
====
Es wird empfohlen, die Zertifikate nur bei der Erstbereitstellung von {product-name} zu ersetzen. Die Ersetzung in einem laufenden Cluster (auch bei einem schrittweisen Upgrade) kann zu einem instabilen Zustand führen, in dem die Pods {product-name} nicht miteinander kommunizieren können, aufgrund einer Diskrepanz in den Zertifikaten, und es kann zu DATENVERLUST kommen.
====

=== Ersetzung der in den internen Kommunikationen von {product-name} verwendeten Zertifikate

Ersetzen Sie die internen Verschlüsselungsdateien `+ca.crt+`, `+tls.key+`, `+tls.crt+` wie folgt:

* Erstellen Sie eine neue Datei `+ca.cfg+` mit Ihrem bevorzugten Editor:

[,shell]
----
[req]
distinguished_name = req_distinguished_name
x509_extensions = v3_req
prompt = no
[req_distinguished_name]
C = US
ST = California
L = San Jose
O = {product-name} Inc.
OU = Neuvector
CN = Neuvector
[v3_req]
keyUsage = digitalSignature, keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth, clientAuth
subjectAltName = @alt_names
[alt_names]
DNS.1 = Neuvector
----

[IMPORTANT]
====
Für weitere Informationen zu `+ca.cfg+` siehe https://open-docs.neuvector.com/configuration/console/replacecert.
====

* Wählen Sie Ihr Szenario aus den folgenden Optionen:

[tabs]
========
Neues Zertifikat::
+
Wenn Ihr Zertifikat kurz vor dem Ablauf steht und Sie ein neues generieren müssen, folgen Sie bitte den folgenden Schritten:
+
* Supprimez l'ancien `+ca.crt+`, `+tls.key+`, `+tls.crt+`, secret kubernetes, et générez-en de nouveaux :
+
[source,bash]
----
kubectl delete secret internal-cert -n neuvector 
openssl genrsa -out ca.key 2048 
openssl req -x509 -sha256 -new -nodes -key ca.key -days 3650 -out ca.crt 
openssl genrsa -out tls.key 2048 
openssl req -new -key tls.key -sha256 -out cert.csr -config ca.cfg 
openssl req -in cert.csr -noout -text 
openssl x509 -req -sha256 -in cert.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out tls.crt -days 3650 -extensions 'v3_req' -extfile ca.cfg 
openssl x509 -in tls.crt -text 
kubectl create secret generic internal-cert -n neuvector --from-file=tls.key --from-file=tls.crt --from-file=ca.crt
----
+
* Ändern Sie dann die YAML-Bereitstellungsdateien des Controllers, des Enforcers und des Scanners, indem Sie hinzufügen:
+
[source,yaml]
----
      containers:
        - name: neuvector-controller/enforcer/scanner-pod
          volumeMounts:
            - mountPath: /etc/neuvector/certs/internal/cert.key
              name: internal-cert
              readOnly: true
              subPath: tls.key
            - mountPath: /etc/neuvector/certs/internal/cert.pem
              name: internal-cert
              readOnly: true
              subPath: tls.crt
            - mountPath: /etc/neuvector/certs/internal/ca.cert
              name: internal-cert
              readOnly: true
              subPath: ca.crt
      volumes:
        - name: internal-cert
          secret:
            defaultMode: 420
            secretName: internal-cert
----
+
Fahren Sie dann fort, {product-name} wie zuvor bereitzustellen. Sie können auch auf den Befehlsinterpreter in den Pods Controller/Enforcer/Scanner zugreifen, um zu bestätigen, dass die Dateien ca.crt, tls.key, tls.crt die benutzerdefinierten sind und dass die Kommunikationen {product-name} mit den neuen Zertifikaten funktionieren.
+
Beispiele für Patch-Befehle für den Controller (ändern Sie den Namespace in cattle-neuvector-system, falls erforderlich, und passen Sie ihn für die Verwendung auf dem Enforcer, dem Scanner an)
+
[source,bash]
----
NAMESPACE=neuvector

kubectl patch deployment -n $\{NAMESPACE} neuvector-controller-pod --type='json' -p='[{"op": "add", "path": "/spec/template/spec/volumes/-", "value": {"name": "internal-cert", "secret": {"defaultMode": 420, "secretName": "internal-cert"}} } ]'

kubectl patch deployment -n $\{NAMESPACE} neuvector-controller-pod --type='json' -p='[{"op": "add", "path": "/spec/template/spec/containers/0/volumeMounts", "value": [{"mountPath": "/etc/neuvector/certs/internal/cert.key", "name": "internal-cert", "readOnly": true, "subPath": "cert.key"}, {"mountPath": "/etc/neuvector/certs/internal/cert.pem", "name": "internal-cert", "readOnly": true, "subPath": "cert.pem"}, {"mountPath": "/etc/neuvector/certs/internal/ca.cert", "name": "internal-cert", "readOnly": true, "subPath": "ca.cert"} ] } ]'
----

Aktualisierung des aktuellen Zertifikats mit SANs::
+
Wenn Ihre Zertifikatdateien vor der Version {product-name} 5.3 erstellt wurden, müssen Sie das Zertifikat mit mindestens einem Subject Alternative Name oder SAN kurz aktualisieren. Wenn Sie die Dateien `+ca.key+` und `+ca.crt+` noch zugänglich haben, führen Sie die Befehle wie folgt aus:
+
[source,bash]
----
kubectl delete secret internal-cert -n neuvector 
openssl genrsa -out tls.key 2048 
openssl req -new -key tls.key -sha256 -out cert.csr -config ca-new.cfg 
openssl req -in cert.csr -noout -text 
openssl x509 -req -sha256 -in cert.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out tls.crt -days 3650 -extensions 'v3_req' -extfile ca-new.cfg 
openssl x509 -in tls.crt -text 
kubectl create secret generic internal-cert -n neuvector --from-file=tls.key --from-file=tls.crt --from-file=ca.crt
----
+
Sobald die Zertifikatdateien aktualisiert wurden, starten Sie die Deployments neu, um das aktualisierte Zertifikat zu verwenden: 
+
[source,bash]
----
kubectl rollout restart deployment neuvector-controller-pod 
kubectl rollout restart deployment neuvector-scanner-pod 
kubectl rollout restart deployment neuvector-registry-adapter-pod 
kubectl rollout restart ds neuvector-enforcer-pod
----

Regénérez les fichiers de certificat et ajoutez des SANs::
+
Wenn Ihre Zertifikatdateien vor der Version {product-name} 5.3 erstellt wurden, müssen Sie das Zertifikat mit mindestens einem Subject Alternative Name oder SAN kurz aktualisieren. Si vous n'avez plus les fichiers `+ca.key+` et `+ca.crt+`, suivez les étapes ci-dessous : 
+
* Sichern Sie Ihr ursprüngliches Zertifikat 
+
[source,bash]
----
kubectl get secret internal-cert -o yaml > internal-cert.yaml
----
+
* Exportieren Sie das vorhandene interne Zertifikat
+
[source,bash]
----
kubectl get secret internal-cert -o json | jq -r '.data."ca.crt"' | base64 -d > old-ca.crt 
kubectl get secret internal-cert -o json | jq -r '.data."tls.crt"' | base64 -d > old-tls.crt 
kubectl get secret internal-cert -o json | jq -r '.data."tls.key"' | base64 -d > old-tls.key 
----
+
* Erstellen Sie neue Zertifikatdateien und interne Zertifikate 
+
[source,bash]
----
openssl genrsa -out ca.key 2048 
openssl req -x509 -sha256 -new -nodes -key ca.key -days 3650 -out ca.crt 
openssl genrsa -out tls.key 2048 
openssl req -new -key tls.key -sha256 -out cert.csr -config ca.cfg 
openssl req -in cert.csr -noout -text 
openssl x509 -req -sha256 -in cert.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out tls.crt -days 3650 -extensions 'v3_req' -extfile ca.cfg 
openssl x509 -in tls.crt -text 
----
+
* Fügen Sie die alten und neuen Dateien `+ca.crt+` zusammen 
+
[source,bash]
----
cat old-ca.crt > /tmp/ca.crt cat ca.crt >> /tmp/ca.crt 
----
+
* Aktualisieren Sie das Kubernetes-Secret mit dem `+ca.crt+` zusammengeführten
+
[source,bash]
----
kubectl delete secret internal-cert -n neuvector 
kubectl create secret generic internal-cert -n neuvector --from-file=tls.key=old-tls.key --from-file=tls.crt=old-tls.crt --from-file=ca.crt=/tmp/ca.crt 
----
+
* Starten Sie die Deployments neu, um das aktualisierte Zertifikat zu verwenden 
+
[source,bash]
----
kubectl rollout restart deployment neuvector-controller-pod 
kubectl rollout restart deployment neuvector-scanner-pod 
kubectl rollout restart deployment neuvector-registry-adapter-pod 
kubectl rollout restart ds neuvector-enforcer-pod 
----
+
* Warten Sie, bis der Neustart abgeschlossen ist 
+
[source,bash]
----
kubectl rollout status deployment neuvector-controller-pod 
kubectl rollout status deployment neuvector-scanner-pod 
kubectl rollout status deployment neuvector-registry-adapter-pod 
kubectl rollout status ds neuvector-enforcer-pod 
----
+
* Stellen Sie sicher, dass die Konsole zugänglich ist und dass alle Controller online sind.* Aktualisieren Sie das Kubernetes-Secret mit dem neuen `+tls.key+` 
+
[source,bash]
----
kubectl delete secret internal-cert -n neuvector 
kubectl create secret generic internal-cert -n neuvector --from-file=tls.key=tls.key --from-file=tls.crt=tls.crt --from-file=ca.crt=/tmp/ca.crt 
----
+
* Starten Sie die Deployments neu, um das aktualisierte Zertifikat zu verwenden 
+
[source,bash]
----
kubectl rollout restart deployment neuvector-controller-pod 
kubectl rollout restart deployment neuvector-scanner-pod 
kubectl rollout restart deployment neuvector-registry-adapter-pod 
kubectl rollout restart ds neuvector-enforcer-pod 
----
+
* Warten Sie, bis der Neustart abgeschlossen ist 
+
[source,bash]
----
kubectl rollout status deployment neuvector-controller-pod
kubectl rollout status deployment neuvector-scanner-pod
kubectl rollout status deployment neuvector-registry-adapter-pod
kubectl rollout status ds neuvector-enforcer-pod 
----
+
* Stellen Sie sicher, dass die Konsole zugänglich ist und dass alle Controller online sind.* Aktualisieren Sie das Kubernetes-Secret mit dem neuen `+ca.crt+` 
+
[source,bash]
----
kubectl delete secret internal-cert -n neuvector
kubectl create secret generic internal-cert -n neuvector --from-file=tls.key=tls.key --from-file=tls.crt=tls.crt --from-file=ca.crt=ca.crt 
----
+
* Starten Sie die Deployments neu, um das aktualisierte Zertifikat zu verwenden 
+
[source,bash]
----
kubectl rollout restart deployment neuvector-controller-pod
kubectl rollout restart deployment neuvector-scanner-pod
kubectl rollout restart deployment neuvector-registry-adapter-pod
kubectl rollout restart ds neuvector-enforcer-pod 
----
+
* Warten Sie, bis der Neustart abgeschlossen ist 
+
[source,bash]
----
kubectl rollout status deployment neuvector-controller-pod
kubectl rollout status deployment neuvector-scanner-pod
kubectl rollout status deployment neuvector-registry-adapter-pod
kubectl rollout status ds neuvector-enforcer-pod 
----
+
* Stellen Sie sicher, dass die Konsole zugänglich ist und dass alle Controller online sind.

Regenerieren Sie das Zertifikat, wenn das integrierte Zertifikat verwendet wird::
+
Wenn Sie das interne Zertifikat zuvor nicht ersetzt haben und zu einem neuen Satz von Zertifikaten migrieren möchten, folgen Sie den folgenden Schritten:
+
* Überprüfen Sie, ob Sie bereits das automatisch generierte interne Zertifikat haben.
+
[source,bash]
----
kubectl get secret internal-cert -o yaml
----
+
Wenn Sie `+tls.key+`, `+tls.crt+` und `+ca.crt+` dort drüben sehen, bedeutet das, dass Sie das automatisch generierte Zertifikat verwendet haben und diesen Abschnitt ignorieren können.
+
Wenn Sie das Geheimnis sehen können, aber diese Geheimnisse nicht finden, ziehen Sie in Betracht, `+internal.autoRotateCert+` im Helm-Grafikersatz zu aktivieren. Diese Option generiert und dreht Ihr internes Zertifikat automatisch.
+
Wenn Sie das automatisch generierte interne Zertifikat nicht verwenden und es nicht tun können, folgen Sie den folgenden Schritten:
+
* Befolgen Sie die Schritte im Tab `+New certificate+`, um ein Kubernetes-Geheimnis zu verwenden, um das interne Zertifikat zu verwalten. Anstatt ein neues Zertifikat zu generieren, verwenden Sie das Zertifikat, `+old-ca.crt+`, `+old-tls.crt+` und `+old-tls.key+`, das unten abgerufen wurde:
+
[source,shell]
----
docker run -it --entrypoint=bash neuvector/scanner:3.654 -c "cat /etc/neuvector/certs/internal/ca.cert" > old-ca.crt
docker run -it --entrypoint=bash neuvector/scanner:3.654 -c "cat /etc/neuvector/certs/internal/cert.pem" > old-tls.crt
docker run -it --entrypoint=bash neuvector/scanner:3.654 -c "cat /etc/neuvector/certs/internal/cert.key" > old-tls.key
----
+
* Stellen Sie sicher, dass alle Komponenten ohne Fehler funktionieren.
+
* Danach folgen Sie den Schritten im Tab `+Regenerate certificate files and add SANs+` und migrieren zu Ihrem eigenen Zertifikat.

========

=== Aktualisierung/Bereitstellung mit Helm

Aus dem Helm-Diagramm `+2.4.1+` können wir jetzt die Installation des internen Zertifikats verwalten. Das Diagramm https://github.com/neuvector/neuvector-helm/blob/master/charts/core/values.yaml[values.yaml] muss auf alle Parameter überprüft werden. Das folgende Beispiel verwendet RKE2, Standard-Ingress und Installationszertifikate.

[,bash]
----
# add chart
helm repo add neuvector https://neuvector.github.io/neuvector-helm/

# update chart
helm repo update

# add domain for ingress
export domain=awesome.sauce

# run the helm
helm upgrade -i neuvector -n neuvector neuvector/core --create-namespace  --set imagePullSecrets=regsecret --set k3s.enabled=true --set k3s.runtimePath=/run/k3s/containerd/containerd.sock --set manager.ingress.enabled=true --set manager.ingress.host=neuvector.$domain --set manager.svc.type=ClusterIP --set controller.pvc.enabled=true --set controller.pvc.capacity=500Mi --set controller.internal.certificate.secret=internal-cert --set cve.scanner.internal.certificate.secret=internal-cert --set enforcer.internal.certificate.secret=internal-cert
----
