= Test_DreiBewertung und Testen \{product-name}
:revdate: 2025-05-08
:page-revdate: {revdate}
:page-opendocs-origin: /09.testing/01.testing/01.testing.md
:page-opendocs-slug:  /testen/testen

== Test_DreiBeispielanwendungen

Nachdem Sie die \{product-name} Komponenten bereitgestellt haben, können Sie sie mit den bereitgestellten Beispiel-Testanwendungen bewerten. Diese befinden sich im `'nvbeta`' Repository auf Docker Hub.

Eine typische Kubernetes-basierte Testumgebung hätte einen Master-Knoten und zwei bis drei Arbeitsknoten. Sie können steuern, ob Anwendungs-Pods und \{product-name} Container auf einem Master-Knoten bereitgestellt werden (standardmäßig deaktiviert).

== Test_ThreeKubernetes Test Plan

Um eine mehrschichtige Anwendung mit Nginx, Nodejs und Redis bereitzustellen, verwenden Sie die folgenden Beispiele (in der angegebenen Reihenfolge). Diese müssen möglicherweise für die Bereitstellung auf OpenShift, Rancher und anderen Kubernetes-basierten Tools bearbeitet werden.

Erstellen Sie einen Demo-Namespace

[,shell]
----
kubectl create namespace demo
----

[NOTE]
====
Das folgende Beispiel verwendet apiVersion: apps/v1, die von Kubernetes 1.16+ erforderlich ist.
====

Erstellen Sie den Redis-Dienst und die Bereitstellung mit diesem YAML:

[,yaml]
----
apiVersion: v1
kind: Service
metadata:
  name: redis
  namespace: demo
spec:
  ports:
  - port: 6379
    protocol: "TCP"
    name: "cluster-tcp-6379"
  clusterIP: None
  selector:
    app: redis-pod

---

apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis-pod
  namespace: demo
spec:
  selector:
    matchLabels:
      app: redis-pod
  template:
    metadata:
      labels:
        app: redis-pod
    spec:
      containers:
      - name: redis-pod
        image: redis
----

Erstellen Sie den Nodejs-Dienst und die Bereitstellung mit diesem YAML:

[,yaml]
----
apiVersion: v1
kind: Service
metadata:
  name: node
  namespace: demo
spec:
  ports:
  - port: 8888
    protocol: "TCP"
    name: "cluster-tcp-8888"
  clusterIP: None
  selector:
    app: node-pod

---

apiVersion: apps/v1
kind: Deployment
metadata:
  name: node-pod
  namespace: demo
spec:
  selector:
    matchLabels:
      app: node-pod
  replicas: 3
  template:
    metadata:
      labels:
        app: node-pod
    spec:
      containers:
      - name: node-pod
        image: nvbeta/node
----

Erstellen Sie den Nginx-Dienst und die Bereitstellung mit diesem YAML:

[,yaml]
----
apiVersion: v1
kind: Service
metadata:
  name: nginx-webui
  namespace: demo
spec:
  ports:
    - port: 80
      name: webui
      protocol: TCP
  type: NodePort
  selector:
    app: nginx-pod

---

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-pod
  namespace: demo
spec:
  selector:
    matchLabels:
      app: nginx-pod
  template:
    metadata:
      labels:
        app: nginx-pod
    spec:
      containers:
      - name: nginx-pod
        image: nvbeta/swarm_nginx
        ports:
        - containerPort: 80
          protocol: TCP
----

Um auf den Nginx-Webui-Dienst extern zuzugreifen, finden Sie den zufällig zugewiesenen Port (auf Port 80 abgebildet) durch den NodePort:

[,shell]
----
kubectl get svc -n demo
----

Verbinden Sie sich dann mit der öffentlichen IP-Adresse/Port eines der Kubernetes-Knoten, z.B. `++http://(public_IP):(NodePort)++`

Nach der Bereitstellung von \{product-name} können Sie Testverkehr durch die Demo-Anwendungen leiten, um die Whitelist-Regeln zu generieren, und dann alle Dienste in den Überwachungs- oder Schutzmodus versetzen, um Verstöße und Angriffe zu sehen.

=== Test_DreiGenerierung von Netzwerkverletzungen auf Kubernetes

Um eine Verletzung von einem Node.js-Pod zu erzeugen, finden Sie einen Pod:

[,shell]
----
kubectl get pod -n demo
----

Versuchen Sie dann einige Verletzungen (ersetzen Sie node-pod-name):

[,shell]
----
kubectl exec node-pod-name curl www.google.com -n demo
----

Oder finden Sie die interne IP-Adresse eines anderen Node-Pods, wie 172.30.2.21 im folgenden Beispiel, um von einem Knoten zu einem anderen zu verbinden:

[,shell]
----
kubectl exec node-pod-name curl 172.30.2.21:8888 -n demo
----

==== Test_DreiErzeugen Sie eine Bedrohung/Angriff

Um einen Angriff zu simulieren, melden Sie sich in einem Container an und versuchen Sie dann einen Ping-Angriff:

[,shell]
----
kubectl exec -it node-pod-name bash -n demo
----

Verwenden Sie die interne IP eines anderen Node-Pods:

[,shell]
----
ping 172.30.2.21 -s 40000
----

Für all das oben Genannte können Sie die Sicherheitsereignisse in der \{product-name} Konsole Netzwerkaktivitätskarte sowie im Tab Benachrichtigungen anzeigen.

=== Test_DreiProzess- und Dateischutztests

Versuchen Sie verschiedene Prozess- und Dateiaktivitäten, indem Sie in einen Container exec'en und Befehle wie apt-get update, ssh, scp oder andere ausführen. Jede nicht erlaubte Prozessaktivität oder Dateizugriff wird Benachrichtigungen auslösen.

=== Test_DreiRegistry-Scanning und Zulassungssteuerung

Ein beliebter Test besteht darin, das Scannen von Bildern eines Registrys in Assets -> Registries zu konfigurieren. Nachdem der Scan abgeschlossen ist, konfigurieren Sie eine Zulassungssteuerungsregel in der Richtlinie. Stellen Sie sicher, dass Sie die Zulassungssteuerungen aktivieren und eine Regel festlegen, um abzulehnen, wenn es hohe Schwachstellen in einem Bild gibt. Wählen Sie dann ein Bild mit hohen Schwachstellen aus und versuchen Sie, es in Kubernetes bereitzustellen. Die Bereitstellung wird im Schutzmodus blockiert und Sie sehen ein Ereignis in den Benachrichtigungen -> Sicherheitsrisiken.

Fortgeschrittenere Tests der Zulassungssteuerung können unter Verwendung verschiedener Kriterien in Regeln oder durch Kombination von Kriterien durchgeführt werden.

==== Test_ThreeDeploy Another App

Die Kubernetes Guestbook-Demo-Anwendung kann ebenfalls auf Kubernetes bereitgestellt werden. Es wird empfohlen, sie in ihrem eigenen Namespace bereitzustellen, damit Sie die namespacenbasierte Filterung in der \{product-name} Konsole sehen können.

== Test_DreiDocker-native Testplan

Nach der Bereitstellung der \{product-name}-Komponenten und der Beispielanwendung(en) können Sie laufende Container entdecken, überwachen und schützen. Der untenstehende Testplan bietet Vorschläge zur Erzeugung von Laufzeitverletzungen des erlaubten Anwendungsverhaltens und zum Scannen von Containern auf Schwachstellen.

xref:attachment$testplan.pdf[\{product-name} Testplan]

Wenn der obige Link nicht funktioniert, können Sie http://neuvector.com/sample-applications-test-plan/[es von unserer Website herunterladen] mit dem Passwort nv1851blvd.

\{product-name} kann auch Bedrohungen für Ihre Container erkennen, wie z.B. DDOS-Angriffe. Wenn Sie ein Tool ausführen, um solche Angriffe auf Ihre Container zu generieren, werden diese Ergebnisse in der Netzwerkaktivität und im Dashboard angezeigt.

Zum Beispiel wird ein einfacher Ping-Befehl mit hohem Payload den Ping.Death-Angriff in der Konsole anzeigen. Um dies auszuprobieren, führen Sie Folgendes an der IP-Adresse eines der Container (interne IP des Containers) aus.

[,shell]
----
ping <container_ip> -s 40000
----

In Kubernetes können Sie dies von jedem Knoten aus tun, einschließlich des Masters. In anderen Umgebungen müssen Sie möglicherweise in den Knoten eingeloggt sein, auf dem der Container läuft.
