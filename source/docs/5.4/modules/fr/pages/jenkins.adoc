= Jenkins-Details
:revdate: 2025-05-05
:page-revdate: {revdate}
:page-opendocs-origin: /06.scanning/03.build/01.jenkins/01.jenkins.md
:page-opendocs-slug:  /scanning/build/jenkins

== Detaillierte Konfiguration für das Jenkins-Plugin

Container bieten eine einfache und effektive Möglichkeit, Anwendungen bereitzustellen. Aber Container-Images können Open-Source-Code enthalten, über den Sie nicht die volle Kontrolle haben. Zahlreiche Schwachstellen in Open-Source-Projekten wurden gemeldet, und Sie können entscheiden, ob Sie diese Bibliotheken mit Schwachstellen verwenden möchten oder nicht, nachdem Sie die Images analysiert und die Informationen zu den Schwachstellen überprüft haben.

Das {product-name} Jenkins Vulnerability Scanner-Plugin kann die Images analysieren, nachdem Ihr Image in Jenkins erstellt wurde. Der Quellcode des Plugins und die neueste Dokumentation finden Sie https://github.com/jenkinsci/neuvector-vulnerability-scanner-plugin[hier] auf der GitHub-Seite {product-name}.

Das Plugin unterstützt zwei Analysemodi. Der erste ist der "Controller & Scanner"-Modus. Der zweite ist der autonome Scanner-Modus. Sie können den Analysemodus auf der Projektkonfigurationsseite auswählen. Standardmäßig verwendet es den "Controller & Scanner"-Modus.

Für den "Controller & Scanner"-Modus müssen Sie den Controller und den Scanner {product-name} im Netzwerk bereitstellen. Um das lokale Image (das Image auf der Jenkins-Maschine) zu analysieren, muss der "Controller & Scanner" auf demselben Knoten installiert sein, auf dem das Image existiert.

Für den autonomen Scanner-Modus muss die Docker-Laufzeit auf demselben Host wie Jenkins installiert sein. Außerdem fügen Sie den Benutzer jenkins zur Docker-Gruppe hinzu.

[,bash]
----
sudo usermod -aG docker jenkins
----

=== Installation des Jenkins-Plugins

Zuerst gehen Sie in Ihrem Browser zu Jenkins, um das Plugin {product-name} zu suchen. Das kann gefunden werden in:

-> Jenkins verwalten -> Plugins verwalten -> Verfügbar -> Filter -> Suche `{product-name} Vulnerability Scanner` ->

Sélectionnez-le et cliquez sur `install without restart.`

Stellen Sie den {product-name} Controller- und Scanner-Container bereit, wenn Sie dies noch nicht auf einem vom Jenkins-Server zugänglichen Host getan haben. Dies kann auf demselben Server wie Jenkins erfolgen, wenn gewünscht. Notieren Sie die IP-Adresse des Hosts, auf dem der Controller läuft. Hinweis: Der Standard-REST-API-Port ist 10443. Dieser Port muss über das All-in-One oder den Controller über einen Dienst in Kubernetes oder eine Portweiterleitung (z. B. - 10443:10443) in der Docker-Run- oder Compose-Datei exponiert werden.

Stellen Sie außerdem sicher, dass ein {product-name} Scanner-Container im Standalone-Modus bereitgestellt und konfiguriert ist, um sich mit dem Controller zu verbinden (wenn der Controller verwendet wird).

Es gibt zwei Szenarien für das Scannen von Bildern: das lokale Scannen und das Scannen von Registries.

. *Lokales Bild scannen*. Wenn Sie das Plugin verwenden, um lokale Bilder zu scannen (bevor Sie sie in Registries pushen), können Sie auf demselben Host wie der Controller/Scanner scannen oder den Scanner so konfigurieren, dass er auf die Docker-Engine auf einem entfernten Host zugreift.
. *Registry-Bild scannen*. Wenn Sie das Plugin verwenden, um Bilder von Registries zu scannen (nachdem Sie sie in Registries gepusht haben, aber im Rahmen des Jenkins-Bauprozesses), kann der {product-name} Scanner auf jedem Knoten im Netzwerk installiert werden, der eine Verbindung zwischen der Registry, dem {product-name} Scanner und Jenkins hat.

=== Globale Konfiguration in Jenkins

Nachdem Sie das Plugin installiert haben, finden Sie den Abschnitt '\`{product-name} Schwachstellenscanner\`' auf der Seite für die globale Konfiguration (Jenkins '\`System konfigurieren\`'). Geben Sie die Werte für die IP des {product-name} Controllers, den Port, den Benutzernamen und das Passwort ein. Sie können auf die Schaltfläche '\`Verbindung testen\`' klicken, um die Werte zu validieren. Dies zeigt '\`Verbindung erfolgreich\`' oder eine Fehlermeldung an.

Der Wert der Wartezeit wird die Bauphase zum eingegebenen Zeitpunkt beenden. Der Standardwert von 0 bedeutet, dass keine Wartezeit auftritt.

Klicken Sie auf '\`Registry hinzufügen\`'', um die Werte für das Register einzugeben, das Sie in Ihrem Projekt verwenden werden. Si vous ne scannez que des images locales, vous n'avez pas besoin d'ajouter un registre ici.

Szenario 1: Beispiel für eine globale Konfiguration zum Scannen lokaler Bilder.

image:jenkins1a.png[global-image]

Szenario 2: Beispiel für eine globale Konfiguration zum Scannen von Registerbildern.

Für die globale Registerkonfiguration folgen Sie den obigen Anweisungen für lokal und fügen Sie dann die Registrierungsdetails wie unten hinzu.

image:registry_console.png[registre-global]

==== Eigenständiger Scanner.

Das Ausführen des Jenkins-Scans im eigenständigen Modus ist eine einfache Möglichkeit, die Schwachstellen von Bildern in der Pipeline zu scannen. Der Scanner wird dynamisch aufgerufen und es ist keine Installation oder Konfiguration des Controllers erforderlich. Dies ist besonders nützlich, wenn Sie ein Bild scannen, bevor es in ein Register gepusht wird. Es gibt auch keine Begrenzung für die Anzahl der Scanaufgaben, die gleichzeitig ausgeführt werden können.

Um einen Schwachstellenscan im eigenständigen Modus auszuführen, muss das Jenkins-Plugin das Scanner-Bild auf den Host ziehen, auf dem der Agent ausgeführt wird. Daher müssen Sie die URL des Registers {product-name} Scanner, das Bild-Repository und die Anmeldeinformationen, falls erforderlich, auf der Konfigurationsseite des Plugins {product-name} eingeben.

Das Ergebnis des Scans kann auch an den Controller übermittelt und in der Admission Control-Funktion verwendet werden. In diesem Fall benötigen Sie eine Controller-Konfiguration und müssen angeben, wie Sie sich auf der Konfigurationsseite des Plugins {product-name} mit dem Controller verbinden.

=== Lokale Konfiguration zum Scannen eines entfernten Docker-Hosts.

==== Voraussetzungen für einen lokalen Scan auf einem entfernten Docker-Host.

Um {product-name} zu ermöglichen, ein Bild zu scannen, das sich nicht auf demselben Host wie der Controller/allinone befindet:

* Stellen Sie sicher, dass der Socket der Docker-Runtime-API über TCP exponiert ist.
* Fügen Sie die folgende Umgebungsvariable zum Controller/allinone hinzu: SCANNER_DOCKER_URL=tcp://192.168.1.10:2376

=== Projektkonfiguration

Wählen Sie in Ihrem Projekt das Plugin '{product-name} Schwachstellenscanner' im Dropdown-Menü 'Bau-Schritt hinzufügen'. Aktivieren Sie das Kontrollkästchen "Mit dem eigenständigen Scanner scannen", wenn Sie den Scan im Modus des eigenständigen Scanners durchführen möchten. Standardmäßig verwendet es den Modus "Controller & Scanner", um den Scan durchzuführen.

Wählen Sie Lokal oder einen Registrierungsnamen, der der Spitzname ist, den Sie in der globalen Konfiguration eingegeben haben. Entrez le dépôt et le nom de la balise d'image à scanner. Sie können die Standard-Umgebungsvariablen von Jenkins für das Repository oder den Tag auswählen, z. B. $JOB_NAME, $BUILD_TAG, $BUILD_NUMBER. Geben Sie die Werte für die Anzahl der hohen oder mittleren Schwachstellen und für alle Namen der vorhandenen Schwachstellen ein, um den Bau zu fehlschlagen.

Nach Abschluss des Builds wird ein Bericht {product-name} erstellt. Il affichera les détails du scan et les erreurs s'il y en a.

Szenario 1: Beispiel für lokale Konfiguration

image:jenkins_local.png[local-image]

Szenario 2: Beispiel für Registrierungs-Konfiguration

image:jenkins_registry.png[registre-local]

=== Jenkins-Pipeline

Für das Jenkins-Pipeline-Projekt können Sie Ihr eigenes Pipeline-Skript direkt schreiben oder auf den '\`Pipeline-Syntax\`' klicken, um das Skript zu generieren, wenn Sie neu in der Pipeline-Stilaufgabe sind.

image:jenkins5a.png[pipeline]

Wählen Sie den {product-name} Schwachstellenscanner im Dropdown-Menü, konfigurieren Sie ihn und generieren Sie das Skript.

image:jenkins6a.png[skript]

Kopieren Sie das Skript in Ihr Jenkins-Aufgabenskript.

Scénario 1 : Beispiel für ein einfaches lokales Pipeline-Skript (in Ihr Pipeline-Skript einfügen):

[,shell]
----
...
  stage('Scan local image') \{
    neuvector registrySelection: 'Local', repository: 'your_username/your_image'
  \}
...
----

Szenario 2: Beispiel für ein einfaches Registrierungs-Pipeline-Skript (in Ihr Pipeline-Skript einfügen):

[,shell]
----
...
  stage('Scan local image') \{
    neuvector registrySelection: 'your_registry', repository: 'your_username/your_image'
  \}
...
----

=== Zusätzliche Schritte

Fügen Sie Ihre eigenen Bild-Scan-Schritte vor und nach dem hinzu, zum Beispiel im folgenden Beispiel für die Pipeline-Schrittansicht.

image:jenkins7a.png[étapes]

Sie sind jetzt bereit, Ihre Jenkins-Bauten zu starten und den {product-name} Schwachstellenscanner auszulösen, um alle Schwachstellen zu melden!

=== Configuration du pipeline pour construire des scans parallèles à grande échelle

Verfügbar mit NeuVector v5.4.3 und höher, unterstützt das Jenkins-Plugin NeuVector Vulnerability Scanner v2.5 und höher paralleles Scannen von bis zu 2000 gleichzeitigen Scans im API-Schlüsselmodus. Für frühere Versionen von NeuVector ist die maximale Anzahl gleichzeitiger Scans auf 32 im Token-Modus beschränkt. Klicken Sie, um die Beispiele unten für Beispiel-Pipeline-Konfigurationen zu erweitern und anzuzeigen.

.Verwendung der Beispielkonfiguration im Token-Modus (Plugin v2.4 und niedriger, oder v2.5 und höher) 
[%collapsible]
====
[,groovy]
----
pipeline {
    agent any
    environment {
        REPO_NAME = 'your repo'
        REGISTRY_SELECTION = 'your registry'
        CONTROLLER = 'your controller'
        MAX_CONCURRENT_SCANS = 32
    }
    stages {
        stage('Parallel Vulnerability Scanning') {
            steps {
                script {
                    // There is a limit of 250 tags per list (by Jenkins) 
                    TAGS_LIST_PART1 = ["your tags"...]
                    TAGS_LIST_PART2 = ["your tags"...]
                    TAGS_LIST_PART3 = ["your tags"...]
                    TAGS_LIST_PART4 = ["your tags"...]
                    TAGS_LIST_PART5 = ["your tags"...]...
                    def allTags = TAGS_LIST_PART1 + TAGS_LIST_PART2 + TAGS_LIST_PART3 + TAGS_LIST_PART4 + TAGS_LIST_PART5
                    def batches = allTags.collate(MAX_CONCURRENT_SCANS.toInteger()) // Ensure MAX_CONCURRENT_SCANS is an integer
                    def batchCounter = 1                    for (batch in batches) {
                        stage("Batch ${batchCounter}") {
                            def scans = [:]
                            batch.each { tag ->
                                def currentTag = tag
                                scans["Scan ${currentTag}"] = {
                                    stage("Scan ${currentTag}") {
                                        neuvector(
                                            controllerEndpointUrlSelection: CONTROLLER,
                                            registrySelection: REGISTRY_SELECTION,
                                            repository: REPO_NAME,
                                            scanTimeout: 20,
                                            tag: "${currentTag}"
                                        )
                                        echo "Scan for tag ${currentTag} complete"
                                    }
                                }
                            }
                            parallel scans
                        }
                        batchCounter++
                    }
                }
            }
        }
    }
}
----
====

.Utilisation du mode clé API (plug-in v2.5 et ultérieur)
[%collapsible]
====
[,groovy]
----
pipeline {
    agent any
    environment {
        REPO_NAME = 'your repo'
        REGISTRY_SELECTION = 'your registry'
        CONTROLLER = 'your controller'
    }
    stages {
        stage('Parallel Vulnerability Scanning') {
            steps {
                script {
                    // There is a limit of 250 tags per list (by Jenkins) 
                    TAGS_LIST_PART1 = ["your tags"...]
                    TAGS_LIST_PART2 = ["your tags"...]
                    TAGS_LIST_PART3 = ["your tags"...]
                    TAGS_LIST_PART4 = ["your tags"...]
                    TAGS_LIST_PART5 = ["your tags"...]...
                    def allTags = TAGS_LIST_PART1 + TAGS_LIST_PART2 + TAGS_LIST_PART3 + TAGS_LIST_PART4 + TAGS_LIST_PART5
                    def scans = [:]

                    allTags.each { tag ->
                        def currentTag = tag
                        scans["Scan ${currentTag}"] = {
                            stage("Scan ${currentTag}") {
                                neuvector(
                                    controllerEndpointUrlSelection: CONTROLLER,
                                    registrySelection: REGISTRY_SELECTION,
                                    repository: REPO_NAME,
                                    scanTimeout: 20,
                                    tag: "${currentTag}"
                                )
                                echo "Scan for tag ${currentTag} complete"
                            }
                        }
                    }
                    parallel scans
                }
            }
        }
    }
}
----
====

== Beispiel für OpenShift-Routen und Registrierungs-Token

Um das Plugin mit einer OpenShift-Route für den Zugriff auf den Controller zu konfigurieren, fügen Sie die Route in das IP-Feld des Controllers ein.

image:rhos_jenkins_route.png[openshift]

Um die tokenbasierte Authentifizierung für das OpenShift-Register zu verwenden, verwenden Sie NONAME als Benutzer und geben Sie das Token im Passwortfeld ein.

== Sonderanwendungsfall für Jenkins im selben Kubernetes-Cluster

Um einen Scan in der Build-Phase durchzuführen, in der die Jenkins-Software im selben Kubernetes-Cluster wie der Scanner ausgeführt wird, stellen Sie sicher, dass der Scanner und Jenkins so konfiguriert sind, dass sie auf demselben Knoten ausgeführt werden. Der Knoten muss so gekennzeichnet sein, dass die Jenkins- und Scanner-Container auf demselben Knoten ausgeführt werden, da der Scanner Zugriff auf das docker.sock des lokalen Knotens benötigt, um auf das Bild zuzugreifen.
